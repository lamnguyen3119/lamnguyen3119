import React, { useState, useEffect, useCallback, useRef } from 'react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from 'firebase/auth';
import { getFirestore, doc, setDoc, getDoc, collection, addDoc, getDocs, updateDoc, deleteDoc, serverTimestamp, onSnapshot, query, where, orderBy, limit } from 'firebase/firestore';
// Icons
const FireIcon = ({className="w-5 h-5 mr-1"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path fillRule="evenodd" d="M12.963 2.286a.75.75 0 0 0-1.071 1.071l9 9a.75.75 0 0 0 1.071-1.071l-9-9ZM12 3a.75.75 0 0 1 .75.75v6a.75.75 0 0 1-1.5 0v-6A.75.75 0 0 1 12 3ZM8.625 5.652a.75.75 0 0 1 0 1.5c-1.375 0-2.5 1.125-2.5 2.5a.75.75 0 0 1-1.5 0c0-2.21 1.79-4 4-4a.75.75 0 0 1 0 1.5ZM5.625 8.652a.75.75 0 0 1 0 1.5c-1.375 0-2.5 1.125-2.5 2.5a.75.75 0 0 1-1.5 0c0-2.21 1.79-4 4-4a.75.75 0 0 1 0 1.5ZM12 8.25a.75.75 0 0 1 .75.75v6a.75.75 0 0 1-1.5 0v-6a.75.75 0 0 1 .75-.75Zm3.375-2.598a.75.75 0 0 1 0-1.5c2.21 0 4 1.79 4 4a.75.75 0 0 1-1.5 0c0-1.375-1.125-2.5-2.5-2.5Zm3.375 2.598a.75.75 0 0 1 0-1.5c2.21 0 4 1.79 4 4a.75.75 0 0 1-1.5 0c0-1.375-1.125-2.5-2.5-2.5Z" clipRule="evenodd" /></svg>;
const WrenchScrewdriverIcon = ({className="w-5 h-5 mr-1"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path fillRule="evenodd" d="M12 6.75a5.25 5.25 0 0 1 5.25 5.25a.75.75 0 0 1-1.5 0a3.75 3.75 0 1 0-7.341 1.012a.75.75 0 0 1-1.341.668A5.25 5.25 0 0 1 12 6.75Z" clipRule="evenodd" /><path d="M4.328 15.023a.75.75 0 0 0 1.055-.098l1.498-1.748a.75.75 0 0 0 .126-.558V10.5a.75.75 0 0 1 .75-.75h2.25a.75.75 0 0 1 .75.75v.75a.75.75 0 0 0 1.5 0v-.75a2.25 2.25 0 0 0-2.25-2.25H7.5a2.25 2.25 0 0 0-2.25 2.25v2.126c0 .245-.079.484-.225.688l-1.5 2.063a.75.75 0 0 0 .944 1.132Z" /><path d="M19.728 15.023a.75.75 0 0 1-1.055-.098l-1.498-1.748a.75.75 0 0 1-.126-.558V10.5a.75.75 0 0 0-.75-.75h-2.25a.75.75 0 0 0-.75.75v.75a.75.75 0 0 1-1.5 0v-.75a2.25 2.25 0 0 1 2.25-2.25h2.25a2.25 2.25 0 0 1 2.25 2.25v2.126c0 .245.079.484.225.688l1.5 2.063a.75.75 0 0 1-.944 1.132Z" /></svg>;
const PlayIcon = () => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-6 h-6 mr-2"><path fillRule="evenodd" d="M4.5 5.653c0-1.427 1.529-2.33 2.779-1.643l11.54 6.347c1.295.712 1.295 2.573 0 3.286L7.28 19.99c-1.25.687-2.779-.217-2.779-1.643V5.653Z" clipRule="evenodd" /></svg>;
const CogIcon = () => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-5 h-5 mr-2"><path fillRule="evenodd" d="M11.078 2.25c-.917 0-1.699.663-1.905 1.523L9.017 8.429a1.875 1.875 0 0 1-.445 1.035l-2.833 2.833a1.875 1.875 0 0 0 0 2.652l2.833 2.833c.28.28.626.445.994.445s.714-.165.994-.445l2.832-2.833a1.875 1.875 0 0 1 1.036-.445l4.906-.153c.94-.03 1.686-.786 1.686-1.727V9.28c0-.94-.747-1.697-1.686-1.727l-4.906-.153a1.875 1.875 0 0 1-1.036-.445l-2.832-2.833A1.875 1.875 0 0 0 11.078 2.25ZM12.75 9a3.75 3.75 0 1 0 0 7.5 3.75 3.75 0 0 0 0-7.5Z" clipRule="evenodd" /></svg>;
const SaveIcon = () => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-5 h-5 mr-2"><path d="M3.375 3C2.339 3 1.5 3.84 1.5 4.875v14.25C1.5 20.16 2.339 21 3.375 21h17.25c1.035 0 1.875-.84 1.875-1.875V4.875C22.5 3.839 21.66 3 20.625 3H3.375Z" /><path d="M9 3.75a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5A.75.75 0 0 1 9 3.75Zm6.75 0a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-1.5 0v-4.5a.75.75 0 0 1 .75-.75Z" /></svg>;
const CheckIcon = () => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-5 h-5 mr-2"><path fillRule="evenodd" d="M19.916 4.626a.75.75 0 0 1 .208 1.04l-9 13.5a.75.75 0 0 1-1.154.114l-6-6a.75.75 0 0 1 1.06-1.06l5.353 5.353 8.493-12.74a.75.75 0 0 1 1.04-.207Z" clipRule="evenodd" /></svg>;
const ArrowPathIcon = () => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-5 h-5 mr-2"><path fillRule="evenodd" d="M4.755 10.059a7.5 7.5 0 0 1 12.548-3.364l1.903 1.903h-4.5a.75.75 0 0 0 0 1.5h6a.75.75 0 0 0 .75-.75V4.5a.75.75 0 0 0-1.5 0v2.72a9 9 0 1 0-10.713 9.926.75.75 0 0 0 1.214-.882A7.474 7.474 0 0 1 5.353 10.5H4.755Z" clipRule="evenodd" /></svg>;
const PlusCircleIcon = () => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-6 h-6 mr-2"><path fillRule="evenodd" d="M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25ZM12.75 9a.75.75 0 0 0-1.5 0v2.25H9a.75.75 0 0 0 0 1.5h2.25V15a.75.75 0 0 0 1.5 0v-2.25H15a.75.75 0 0 0 0-1.5h-2.25V9Z" clipRule="evenodd" /></svg>;
const ArrowLeftStartOnRectangleIcon = () => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-5 h-5 mr-1"><path fillRule="evenodd" d="M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25Zm-2.625 6c-.54 0-.828.419-.936.634a1.96 1.96 0 0 0-.189.866c0 .298.012.626.035.95.023.324.075.72.14 1.062.066.34.152.673.253.97.102.296.223.543.358.745.136.201.287.34.45.425.164.086.342.12.524.12.182 0 .36-.034.524-.12a1.32 1.32 0 0 0 .45-.425c.135-.202.256-.449.357-.745.101-.297.187-.63.253-.97.065-.342.117-.738.14-1.062.023-.324.035-.652.035-.95a1.96 1.96 0 0 0-.189-.866c-.108-.215-.396-.634-.936-.634H9.375Z" clipRule="evenodd" /></svg>;
const InformationCircleIcon = ({className = "w-6 h-6 mr-2 text-blue-400"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path fillRule="evenodd" d="M2.25 12c0-5.385 4.365-9.75 9.75-9.75s9.75 4.365 9.75 9.75-4.365 9.75-9.75 9.75S2.25 17.385 2.25 12Zm8.706-1.442c1.146-.573 2.437.463 2.126 1.706l-.709 2.836.042-.02a.75.75 0 0 1 .67 1.34l-.04.022c-1.147.573-2.438-.463-2.127-1.706l.71-2.836-.042.02a.75.75 0 1 1-.671-1.34l.041-.022ZM12 9a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5Z" clipRule="evenodd" /></svg>;
const ExclamationTriangleIcon = ({className = "w-6 h-6 mr-2 text-yellow-400"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path fillRule="evenodd" d="M9.401 3.003c1.155-2 4.043-2 5.197 0l7.519 13.007c1.155 2-.772 4.5-3.298 4.5H5.18c-2.526 0-4.453-2.5-3.298-4.5L9.4 3.003ZM12 8.25a.75.75 0 0 1 .75.75v3.75a.75.75 0 0 1-1.5 0V9a.75.75 0 0 1 .75-.75Zm0 8.25a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5Z" clipRule="evenodd" /></svg>;
const UserCircleIcon = () => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-6 h-6 mr-2 text-sky-400"><path fillRule="evenodd" d="M18.685 19.097A9.723 9.723 0 0 0 21.75 12c0-5.385-4.365-9.75-9.75-9.75S2.25 6.615 2.25 12a9.723 9.723 0 0 0 3.065 7.097A9.716 9.716 0 0 0 12 21.75a9.716 9.716 0 0 0 6.685-2.653Zm-12.54-1.285A7.486 7.486 0 0 1 12 15a7.486 7.486 0 0 1 5.855 2.812A8.224 8.224 0 0 1 12 20.25a8.224 8.224 0 0 1-5.855-2.438ZM15.75 9a3.75 3.75 0 1 1-7.5 0 3.75 3.75 0 0 1 7.5 0Z" clipRule="evenodd" /></svg>;
const SparklesIcon = ({className = "w-4 h-4"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className={className}><path fillRule="evenodd" d="M10.868 2.884c-.321-.772-1.415-.772-1.736 0l-1.83 4.401-4.753.39-3.423 3.11a.75.75 0 0 0 .44 1.316l4.861 1.214 1.83 4.401c.321.772 1.415.772 1.736 0l1.83-4.401 4.753-.39 3.423-3.11a.75.75 0 0 0-.44-1.316l-4.861-1.214-1.83-4.401Z" clipRule="evenodd" /></svg>;
const LightBulbIcon = ({className = "w-5 h-5 mr-1"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path d="M12 2.25a.75.75 0 0 1 .75.75v2.519c.04.004.079.008.118.012l.001.001.001.001a4.499 4.499 0 0 1 3.02 3.895C16.5 10.5 18 12 18 13.5V15a1.5 1.5 0 0 1-1.5 1.5H7.5A1.5 1.5 0 0 1 6 15v-1.5c0-1.5 1.5-3 2.092-3.824A4.499 4.499 0 0 1 11.13 5.53l.001-.001.001-.001.118-.012V3a.75.75 0 0 1 .75-.75Zm4.525 15.75a.75.75 0 0 0-.75.75 3 3 0 0 1-6 0 .75.75 0 0 0-.75-.75h-.496a.75.75 0 0 0 0 1.5h.496c.21 1.204 1.256 2.142 2.492 2.241A2.252 2.252 0 0 0 12 21.75a2.252 2.252 0 0 0 2.242-.759c1.236-.1 2.281-1.037 2.492-2.241h.496a.75.75 0 0 0 0-1.5h-.496Z" /></svg>;
const UserGroupIcon = ({className="w-5 h-5 mr-2"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path d="M4.5 6.375a.75.75 0 0 1 .75-.75h2.25a.75.75 0 0 1 0 1.5H5.25a.75.75 0 0 1-.75-.75Z" /><path fillRule="evenodd" d="M5.25 7.5A2.25 2.25 0 0 1 3 5.25v-1.5A2.25 2.25 0 0 1 5.25 1.5h13.5A2.25 2.25 0 0 1 21 3.75v1.5A2.25 2.25 0 0 1 18.75 7.5h-1.5a.75.75 0 0 1 0-1.5h1.5a.75.75 0 0 0 .75-.75v-1.5a.75.75 0 0 0-.75-.75H5.25a.75.75 0 0 0-.75.75v1.5c0 .414.336.75.75.75Zm2.03 4.72a.75.75 0 0 1 1.06 0l.97.97a.75.75 0 1 1-1.06 1.06l-.97-.97a.75.75 0 0 1 0-1.06Zm-2.25 2.25a.75.75 0 0 0 0 1.06l.97.97a.75.75 0 1 0 1.06-1.06l-.97-.97a.75.75 0 0 0-1.06 0Z" clipRule="evenodd" /><path d="M12.75 11.625a.75.75 0 0 0-1.5 0v6.75a.75.75 0 0 0 1.5 0v-6.75Z" /><path d="M14.25 12.375a.75.75 0 0 1 .75-.75h2.25a.75.75 0 0 1 0 1.5H15a.75.75 0 0 1-.75-.75Z" /><path fillRule="evenodd" d="M15 13.5A2.25 2.25 0 0 1 12.75 11.25v-1.5A2.25 2.25 0 0 1 15 7.5h3.75A2.25 2.25 0 0 1 21 9.75v1.5A2.25 2.25 0 0 1 18.75 13.5h-1.5a.75.75 0 0 1 0-1.5h1.5a.75.75 0 0 0 .75-.75v-1.5a.75.75 0 0 0-.75-.75H15a.75.75 0 0 0-.75.75v1.5c0 .414.336.75.75.75Zm-2.03 4.72a.75.75 0 0 1 1.06 0l.97.97a.75.75 0 0 1-1.06 1.06l-.97-.97a.75.75 0 0 1 0-1.06Zm-2.25 2.25a.75.75 0 0 0 0 1.06l.97.97a.75.75 0 1 0 1.06-1.06l-.97-.97a.75.75 0 0 0-1.06 0Z" clipRule="evenodd" /><path d="M5.25 12.375a.75.75 0 0 1 .75-.75h2.25a.75.75 0 0 1 0 1.5H6a.75.75 0 0 1-.75-.75Z" /><path fillRule="evenodd" d="M6 13.5A2.25 2.25 0 0 1 3.75 11.25v-1.5A2.25 2.25 0 0 1 6 7.5h3.75A2.25 2.25 0 0 1 12 9.75v1.5A2.25 2.25 0 0 1 9.75 13.5H8.25a.75.75 0 0 1 0-1.5h1.5a.75.75 0 0 0 .75-.75v-1.5a.75.75 0 0 0-.75-.75H6a.75.75 0 0 0-.75.75v1.5c0 .414.336.75.75.75Z" clipRule="evenodd" /></svg>;
const PlusIcon = ({className="w-5 h-5"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className={className}><path d="M10.75 4.75a.75.75 0 0 0-1.5 0v4.5h-4.5a.75.75 0 0 0 0 1.5h4.5v4.5a.75.75 0 0 0 1.5 0v-4.5h4.5a.75.75 0 0 0 0-1.5h-4.5v-4.5Z" /></svg>;
const TrashIcon = ({className="w-5 h-5"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className={className}><path fillRule="evenodd" d="M8.75 1A2.75 2.75 0 0 0 6 3.75v.443c-.795.077-1.58.177-2.34.297A1.875 1.875 0 0 0 2.05 6.22l.83 9.126A3.375 3.375 0 0 0 6.199 18.75h7.602a3.375 3.375 0 0 0 3.319-3.398l.83-9.126a1.875 1.875 0 0 0-1.61-1.731c-.76-.12-1.546-.22-2.34-.297V3.75A2.75 2.75 0 0 0 11.25 1h-2.5ZM7.5 3.75c0-.69.56-1.25 1.25-1.25h2.5c.69 0 1.25.56 1.25 1.25V4h-5V3.75Z" clipRule="evenodd" /></svg>;
const BuildingStorefrontIcon = ({className="w-5 h-5 mr-2"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path d="M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25Z" /><path d="M6.262 6.072a8.25 8.25 0 0 1 11.477 0 7.5 7.5 0 0 1 0 11.855.75.75 0 0 0 .36.968l1.43 1.072a.75.75 0 0 0 .968-.36 8.25 8.25 0 0 0-11.477 0 .75.75 0 0 0 .968.36l1.43-1.072a.75.75 0 0 0 .36-.968 7.5 7.5 0 0 1 0-11.856Z" /></svg>;
const BackpackIcon = ({className="w-5 h-5 mr-1"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path fillRule="evenodd" d="M8.25 1.5A2.25 2.25 0 0 0 6 3.75v16.5A2.25 2.25 0 0 0 8.25 22.5h7.5A2.25 2.25 0 0 0 18 20.25V3.75A2.25 2.25 0 0 0 15.75 1.5h-7.5ZM9 3a.75.75 0 0 0 0 1.5h6A.75.75 0 0 0 15 3H9Z" clipRule="evenodd" /></svg>;
const BoltIcon = ({className="w-5 h-5 mr-1"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path fillRule="evenodd" d="M11.278 2.232a.75.75 0 0 1 .444 0l9 5.25a.75.75 0 0 1 0 1.316l-7.16 4.177a.75.75 0 0 1-.722 0L4.68 9.316a1.5 1.5 0 0 0-1.5.715L2.25 12a.75.75 0 0 0 .888.933l.003-.001a.75.75 0 0 1 .444 0l9 5.25a.75.75 0 0 1 0 1.316l-7.16 4.177a.75.75 0 0 1-.722 0L2.28 19.498a.75.75 0 0 1-.03-.018A.75.75 0 0 1 3 18.75v-5.25a.75.75 0 0 1 .375-.65l6.375-3.72V6.75a.75.75 0 0 1-.375-.65L3 2.384A.75.75 0 0 1 3.375 1.5H4.5a.75.75 0 0 1 .658.397l.003.003L7.44 3.75l1.68-1.023a.75.75 0 0 1 .678-.075l.02.01.005.002.002.001.001.001.001.001c.003 0 .003 0 .003-.001a.753.753 0 0 1 .042-.021l1.43-.833ZM12.75 12.19l4.5-2.625L12.75 7v5.19ZM11.25 7l-4.5 2.625L11.25 12.19V7Z" clipRule="evenodd" /></svg>;
const HeartIcon = ({className="w-5 h-5 mr-1"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path d="M11.645 20.91a.75.75 0 0 1-1.29 0A18.377 18.377 0 0 1 4.5 9.285c0-3.995 3.05-7.285 6.75-7.285 1.74 0 3.341.81 4.5 2.125 1.159-1.315 2.76-2.125 4.5-2.125 3.7 0 6.75 3.29 6.75 7.285 0 3.071-1.703 6.082-5.234 9.335A18.377 18.377 0 0 1 11.645 20.91Z" /></svg>;
const CharacterSheetIcon = ({className="w-5 h-5 mr-1"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path d="M5.625 1.5c-1.036 0-1.875.84-1.875 1.875v17.25c0 1.035.84 1.875 1.875 1.875h12.75c1.035 0 1.875-.84 1.875-1.875V12.75A3.75 3.75 0 0 0 16.5 9h-1.875a.375.375 0 0 1-.375-.375V6.75A3.75 3.75 0 0 0 10.5 3H5.625Z" /><path d="M12.75 3H10.5a.75.75 0 0 0-.75.75v3c0 .414.336.75.75.75h3c.414 0 .75-.336.75-.75v-3a.75.75 0 0 0-.75-.75Z" /><path d="M12.75 12.75h3.75a.75.75 0 0 0 .75-.75V9.375a.75.75 0 0 0-.75-.75h-3.75a.75.75 0 0 0-.75.75v2.625c0 .414.336.75.75.75Z" /></svg>;
const FaceSmileIcon = ({className="w-5 h-5 mr-1"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path fillRule="evenodd" d="M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25Zm-2.055 9.995a.75.75 0 0 0 1.06 1.061L12 12.25l.995 1.06a.75.75 0 0 0 1.06-1.06L13.06 11.25l1.06-.995a.75.75 0 1 0-1.06-1.06L12 10.19l-.995-1.06a.75.75 0 0 0-1.06 1.06l1.06.995-1.06.995Zm3.035-2.478a.75.75 0 0 0-1.02-.096 9.096 9.096 0 0 0-3.93 0 .75.75 0 0 0-1.02.096 7.483 7.483 0 0 0-2.024 5.115c-.04.33.22.615.55.615h10.818c.33 0 .59-.284.55-.615a7.483 7.483 0 0 0-2.024-5.115Z" clipRule="evenodd" /></svg>;
const BullseyeIcon = ({className="w-5 h-5 mr-1 text-red-400"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path fillRule="evenodd" d="M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25ZM12.75 6a.75.75 0 0 0-1.5 0v6c0 .414.336.75.75.75s.75-.336.75-.75V6ZM12 15a.75.75 0 0 1 .75.75v.008c0 .414-.336.75-.75.75s-.75-.336-.75-.75V15.75A.75.75 0 0 1 12 15Z" clipRule="evenodd" /></svg>;
const HeartCrackIcon = ({className="w-5 h-5 mr-1"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path d="m11.645 20.91-1.008-1.008c-5.633-5.633-8.38-9.115-8.38-12.354C2.257 4.092 5.092 1.5 8.25 1.5c1.818 0 3.515.887 4.633 2.317l.117-.117a.75.75 0 0 1 1.06 1.06l-1.06 1.06.06.06a5.25 5.25 0 0 1 4.196 2.002l1.086 1.086-7.424 7.424a.75.75 0 0 0-.22.53V16.5a.75.75 0 0 1-.75.75h-2.25a.75.75 0 0 0-.53.22L9 18.168l-3.47-3.47a.75.75 0 0 1 0-1.06Z" /><path d="M12.963 2.317A5.23 5.23 0 0 0 8.25 1.5C5.092 1.5 2.257 4.092 2.257 7.543c0 3.24 2.747 6.721 8.38 12.354l1.008 1.008a.75.75 0 0 0 1.29-.001l6.737-6.737a5.252 5.252 0 0 0 .218-7.963 5.202 5.202 0 0 0-4.196-2.002 5.175 5.175 0 0 0-3.731 1.568l-.001.001Z" /></svg>; 
const ShieldCheckIcon = ({className="w-5 h-5 mr-1"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path fillRule="evenodd" d="M12.75 2.239c.204-.063.419-.063.622 0l8.25 2.526c.07.021.136.05.2.084a1.124 1.124 0 0 1 .602 1.01V12c0 5.084-3.158 9.734-7.752 11.563a.75.75 0 0 1-.642 0C8.658 21.734 5.5 17.084 5.5 12V5.86c0-.39.223-.748.552-.926.068-.036.136-.064.203-.084L12.75 2.24ZM11.25 16.12l7.22-7.22a.75.75 0 0 0-1.06-1.06l-6.69 6.69-2.72-2.72a.75.75 0 0 0-1.06 1.06l3.25 3.25a.75.75 0 0 0 1.06 0Z" clipRule="evenodd" /></svg>; 
const MegaphoneIcon = ({className = "w-5 h-5 mr-2"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path d="M10.5 1.5H5.25A2.25 2.25 0 0 0 3 3.75v16.5A2.25 2.25 0 0 0 5.25 22.5h13.5A2.25 2.25 0 0 0 21 20.25V10.5A2.25 2.25 0 0 0 18.75 8.25h-3.573L13.5 4.577A2.25 2.25 0 0 0 10.5 1.5ZM5.625 15.75a.75.75 0 0 1 .75-.75h11.25a.75.75 0 0 1 0 1.5H6.375a.75.75 0 0 1-.75-.75Zm0-3a.75.75 0 0 1 .75-.75h11.25a.75.75 0 0 1 0 1.5H6.375a.75.75 0 0 1-.75-.75Zm0-3a.75.75 0 0 1 .75-.75H12a.75.75 0 0 1 0 1.5H6.375a.75.75 0 0 1-.75-.75Z" /><path d="M12.75 6a.75.75 0 0 0-1.5 0v1.5h-1.5a.75.75 0 0 0 0 1.5h1.5v1.5a.75.75 0 0 0 1.5 0v-1.5h1.5a.75.75 0 0 0 0-1.5h-1.5V6Z" /></svg>;
const ClipboardDocumentCheckIcon = ({className = "w-5 h-5 mr-1"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path fillRule="evenodd" d="M10.5 3A2.25 2.25 0 0 0 8.25 5.25v2.036a3.001 3.001 0 0 1 .368.258l3.75 2.25a1.875 1.875 0 0 1 0 3.194l-3.75 2.25a3.001 3.001 0 0 1-.368.258V18.75A2.25 2.25 0 0 0 10.5 21h6A2.25 2.25 0 0 0 18.75 18.75V5.25A2.25 2.25 0 0 0 16.5 3h-6Zm5.03 4.72a.75.75 0 0 0-1.06-1.06l-1.72 1.72-1.72-1.72a.75.75 0 0 0-1.06 1.06L11.94 9 9.72 11.22a.75.75 0 1 0 1.06 1.06L13 10.06l2.22 2.22a.75.75 0 1 0 1.06-1.06L14.06 9l2.22-2.22Z" clipRule="evenodd" /><path d="M3.75 6A2.25 2.25 0 0 0 1.5 8.25v10.5A2.25 2.25 0 0 0 3.75 21H5.25V18.75a3.75 3.75 0 0 1 3.75-3.75h.75V9.563a4.501 4.501 0 0 0-.099-.728A.75.75 0 0 1 9.375 8.25H3.75Z" /></svg>;
//icon new
const WrenchIcon = ({className="w-4 h-4"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" className={className}><path fillRule="evenodd" d="M8.832 2.036a1.5 1.5 0 0 0-2.122 0l-4.5 4.5a1.5 1.5 0 0 0 0 2.122L5.5 12.04a.75.75 0 0 0 1.06 0l2-2a.75.75 0 0 0 0-1.06l-2-2a.75.75 0 0 0-1.06 0L4.19 8.243l1.28-1.28 2.122-2.121 1.242 1.242a.75.75 0 0 0 1.06 0l2.5-2.5a.75.75 0 0 0 0-1.06l-2.5-2.5Z" clipRule="evenodd" /><path d="m11.121 9.343 1.626 1.627a1.5 1.5 0 0 1 0 2.121l-1.06 1.061a1.5 1.5 0 0 1-2.122 0l-1.626-1.627-1.243 1.243a.75.75 0 0 1-1.06 0l-2-2a.75.75 0 0 1 0-1.06l2-2a.75.75 0 0 1 1.06 0l1.243 1.243Z" /></svg>;
const ArrowUpCircleIcon = ({className="w-4 h-4"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" className={className}><path d="M8 12.5a4.5 4.5 0 1 0 0-9 4.5 4.5 0 0 0 0 9ZM.5 8a7.5 7.5 0 1 1 15 0 7.5 7.5 0 0 1-15 0Z" /><path d="M8 6.25a.75.75 0 0 1 .75.75v3a.75.75 0 0 1-1.5 0v-3a.75.75 0 0 1 .75-.75Z" /><path d="m7.47 6.03 1.03-1.03a.75.75 0 1 1 1.06 1.06l-1.5 1.5a.75.75 0 0 1-1.06 0l-1.5-1.5a.75.75 0 1 1 1.06-1.06l.47.47Z" /></svg>;
const PaintBrushIcon = ({className="w-4 h-4"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" className={className}><path d="M4 2.5A1.5 1.5 0 0 1 5.5 1h5A1.5 1.5 0 0 1 12 2.5v1.889a.75.75 0 0 0 .135.437l3.153 4.204a1.5 1.5 0 0 1 0 1.74l-3.153 4.204a.75.75 0 0 0-.135.437V17.5a.5.5 0 0 1-.5.5h-7a.5.5 0 0 1-.5-.5v-1.581a.75.75 0 0 0-.135-.437L.865 10.78a1.5 1.5 0 0 1 0-1.74L4 4.826a.75.75 0 0 0 .135-.437V2.5Z" /><path d="M8.5 11a.5.5 0 0 1-.5.5H4a.5.5 0 0 1 0-1h4a.5.5 0 0 1 .5.5Z" /></svg>;
const Upload = () => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-5 h-5 mr-2"><path fillRule="evenodd" d="M11.25 2.25c.414 0 .75.336.75.75v11.59l3.22-3.22a.75.75 0 011.06 1.06l-4.5 4.5a.75.75 0 01-1.06 0l-4.5-4.5a.75.75 0 111.06-1.06l3.22 3.22V3a.75.75 0 01.75-.75zm-3 15.09a.75.75 0 01.75.75v.008c0 .414.336.75.75.75h3a.75.75 0 000-1.5H9.75a.75.75 0 01-.75-.75v-.008a.75.75 0 01-.75-.75z" clipRule="evenodd" /><path d="M3.375 19.5a.75.75 0 01.75-.75h15a.75.75 0 010 1.5h-15a.75.75 0 01-.75-.75z" /></svg>;
// icon trang bị
const ArmorIcon = ({className="w-5 h-5 mr-1"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path fillRule="evenodd" d="M11.968 2.583a1.5 1.5 0 0 0-1.406 0L2.253 6.944a1.5 1.5 0 0 0-.913 1.341l.274 7.6A1.5 1.5 0 0 0 2.97 17.5h18.06a1.5 1.5 0 0 0 1.416-1.615l-.274-7.6a1.5 1.5 0 0 0-.913-1.341l-8.309-4.361ZM12 8.528a1.5 1.5 0 0 0-1.491 1.352l-1.385 5.548a.75.75 0 0 0 .572.937l3.665.733a.75.75 0 0 0 .572-.937l-1.385-5.548A1.5 1.5 0 0 0 12 8.528Z" clipRule="evenodd" /></svg>;
const SwordIcon = ({className="w-5 h-5 mr-1"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path fillRule="evenodd" d="M12.97 10.97a.75.75 0 0 1 1.06 0l4.5 4.5a.75.75 0 0 1-1.06 1.06l-4.5-4.5a.75.75 0 0 1 0-1.06Z" clipRule="evenodd" /><path fillRule="evenodd" d="M14.47 5.03a.75.75 0 0 1 1.06 0l6 6a.75.75 0 0 1 0 1.06L18.06 17.5a.75.75 0 0 1-1.06 0l-1.5-1.5a.75.75 0 0 1 0-1.06l1.5-1.5a.75.75 0 0 0 0-1.06l-3-3a.75.75 0 0 0-1.06 0l-1.5 1.5a.75.75 0 0 1-1.06 0l-1.5-1.5a.75.75 0 0 0-1.06 0l-3 3a.75.75 0 0 0 0 1.06L7.94 16.5a.75.75 0 0 1-1.06 0L5.38 14.94a.75.75 0 0 1 0-1.06l4.5-4.5a.75.75 0 0 1 1.06 0Z" clipRule="evenodd" /><path fillRule="evenodd" d="M9.94 2.03a.75.75 0 0 1 1.06 0l6 6a.75.75 0 0 1 0 1.06l-2.25 2.25a.75.75 0 0 1-1.06 0L14.44 10a.75.75 0 0 0-1.06 0l-3-3a.75.75 0 0 0-1.06 0l-2.25 2.25a.75.75 0 0 1-1.06 0l-1.5-1.5a.75.75 0 0 1 0-1.06l6-6Z" clipRule="evenodd" /></svg>;
const HelmetIcon = ({className="w-5 h-5 mr-1"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path d="M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25Zm0 1.5a.75.75 0 0 1 .75.75v5.752a.75.75 0 0 1-1.5 0V4.5a.75.75 0 0 1 .75-.75ZM7.781 5.922a.75.75 0 0 1 0 1.06l-1.47 1.47a.75.75 0 0 1-1.06-1.06l1.47-1.47a.75.75 0 0 1 1.06 0ZM16.219 5.922a.75.75 0 0 0 0 1.06l1.47 1.47a.75.75 0 0 0 1.06-1.06l-1.47-1.47a.75.75 0 0 0-1.06 0ZM4.5 12a.75.75 0 0 1 .75-.75H7.5a.75.75 0 0 1 0 1.5H5.25a.75.75 0 0 1-.75-.75ZM16.5 12a.75.75 0 0 1 .75-.75h2.25a.75.75 0 0 1 0 1.5H17.25a.75.75 0 0 1-.75-.75ZM12 16.5a.75.75 0 0 1 .75.75v2.25a.75.75 0 0 1-1.5 0v-2.25a.75.75 0 0 1 .75-.75Z" /></svg>;
const ChestPlateIcon = ({className="w-5 h-5 mr-1"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path fillRule="evenodd" d="M11.968 2.583a1.5 1.5 0 0 0-1.406 0L2.253 6.944a1.5 1.5 0 0 0-.913 1.341l.274 7.6A1.5 1.5 0 0 0 2.97 17.5h18.06a1.5 1.5 0 0 0 1.416-1.615l-.274-7.6a1.5 1.5 0 0 0-.913-1.341l-8.309-4.361ZM12 8.528a1.5 1.5 0 0 0-1.491 1.352l-1.385 5.548a.75.75 0 0 0 .572.937l3.665.733a.75.75 0 0 0 .572-.937l-1.385-5.548A1.5 1.5 0 0 0 12 8.528Z" clipRule="evenodd" /></svg>;
const GloveIcon = ({className="w-5 h-5 mr-1"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path fillRule="evenodd" d="M1.5 5.625c0-1.036.84-1.875 1.875-1.875h1.293c.969 0 1.815.59 2.222 1.424l.056.11a13.308 13.308 0 0 0 3.125 3.256m9.15-2.617c-2.38.752-4.506 1.905-6.182 3.493L13.5 10.5h1.75c1.036 0 1.875.84 1.875 1.875v1.077c0 .414.336.75.75.75s.75-.336.75-.75V12.375a3.375 3.375 0 0 0-3.375-3.375H13.5ZM20.25 4.5a.75.75 0 0 0-.75.75v.063a2.25 2.25 0 0 1-.371 1.258l-.75 1.302a.75.75 0 0 0 .832 1.144l.75-.433c.976-.563 2.05-.837 3.125-.722A.75.75 0 0 0 22.5 7.5c0-1.036-.84-1.875-1.875-1.875h-.063a2.25 2.25 0 0 1-1.258-.371L20.25 4.5Zm-14.733 1.77C3.593 6.578 1.5 8.847 1.5 12a.75.75 0 0 0 1.5 0c0-2.091 1.523-3.993 3.617-4.417a.75.75 0 0 0-.384-1.413ZM12 17.25a.75.75 0 0 1 .75-.75h.5a.75.75 0 0 1 .75.75v3a.75.75 0 0 1-.75.75H12.75a.75.75 0 0 1-.75-.75v-3ZM15 15.75a.75.75 0 0 1 .75-.75h.5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-.75.75h-.5a.75.75 0 0 1-.75-.75v-4.5ZM9 15.75a.75.75 0 0 1 .75-.75h.5a.75.75 0 0 1 .75.75v4.5a.75.75 0 0 1-.75.75H9.75a.75.75 0 0 1-.75-.75v-4.5ZM6 18.75a.75.75 0 0 1 .75-.75h.5a.75.75 0 0 1 .75.75v1.5a.75.75 0 0 1-.75.75H6.75a.75.75 0 0 1-.75-.75v-1.5ZM21.75 12a.75.75 0 0 0-.75.75v.063a2.25 2.25 0 0 1-.371 1.258l-.75 1.302a.75.75 0 0 0 .832 1.144l.75-.433c.976-.563 2.05-.837 3.125-.722A.75.75 0 0 0 24 13.5c0-1.036-.84-1.875-1.875-1.875h-.063a2.25 2.25 0 0 1-1.258-.371L21.75 12Zm-.013-4.912c-2.38.752-4.506 1.905-6.182 3.493L19.5 10.5h1.75c1.036 0 1.875.84 1.875 1.875v1.077c0 .414.336.75.75.75s.75-.336.75-.75V12.375a3.375 3.375 0 0 0-3.375-3.375H19.5Z" clipRule="evenodd" /></svg>;
const BootsIcon = ({className="w-5 h-5 mr-1"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path fillRule="evenodd" d="M1.5 5.625c0-1.036.84-1.875 1.875-1.875h17.25c1.035 0 1.875.84 1.875 1.875v12.75c0 1.035-.84 1.875-1.875 1.875H3.375A1.875 1.875 0 0 1 1.5 18.375V5.625ZM3 16.035a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 .75.75v1.5a.75.75 0 0 1-.75.75H3.75a.75.75 0 0 1-.75-.75v-1.5Z" clipRule="evenodd" /></svg>;
const RingIcon = ({className="w-5 h-5 mr-1"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path fillRule="evenodd" d="M9.94 2.03c-1.144-.817-2.73-1.042-4.004-.555C4.089 1.766 3 2.766 3 4.25v2.25c0 1.082.84 1.875 1.875 1.875H6.5c1.036 0 1.875.84 1.875 1.875V12a3 3 0 0 0 3 3h.75a3 3 0 0 0 3-3V10.25c0-1.035.84-1.875 1.875-1.875H19.5c1.036 0 1.875-.84 1.875-1.875V4.25c0-1.484-1.089-2.484-2.936-3.118a5.25 5.25 0 0 0-4.004.555L12 3.25l-2.06-1.22Z" clipRule="evenodd" /><path fillRule="evenodd" d="M12.97 10.97a.75.75 0 0 1 1.06 0l2.25 2.25a.75.75 0 0 1 0 1.06l-2.25 2.25a.75.75 0 0 1-1.06 0l-2.25-2.25a.75.75 0 0 1 0-1.06l2.25-2.25a.75.75 0 0 1 1.06 0Z" clipRule="evenodd" /></svg>;
const BookOpenIcon = ({className="w-5 h-5 mr-1"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path fillRule="evenodd" d="M1.5 5.625c0-1.036.84-1.875 1.875-1.875h17.25c1.035 0 1.875.84 1.875 1.875v12.75c0 1.035-.84 1.875-1.875 1.875H3.375A1.875 1.875 0 0 1 1.5 18.375V5.625ZM3 16.035a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 .75.75v1.5a.75.75 0 0 1-.75.75H3.75a.75.75 0 0 1-.75-.75v-1.5Z" clipRule="evenodd" /><path fillRule="evenodd" d="M12.97 10.97a.75.75 0 0 1 1.06 0l4.5 4.5a.75.75 0 0 1-1.06 1.06l-4.5-4.5a.75.75 0 0 1 0-1.06Z" clipRule="evenodd" /><path fillRule="evenodd" d="M14.47 5.03a.75.75 0 0 1 1.06 0l6 6a.75.75 0 0 1 0 1.06L18.06 17.5a.75.75 0 0 1-1.06 0l-1.5-1.5a.75.75 0 0 1 0-1.06l1.5-1.5a.75.75 0 0 0 0-1.06l-3-3a.75.75 0 0 0-1.06 0l-1.5 1.5a.75.75 0 0 1-1.06 0l-1.5-1.5a.75.75 0 0 0-1.06 0l-3 3a.75.75 0 0 0 0 1.06L7.94 16.5a.75.75 0 0 1-1.06 0L5.38 14.94a.75.75 0 0 1 0-1.06l4.5-4.5a.75.75 0 0 1 1.06 0Z" clipRule="evenodd" /><path fillRule="evenodd" d="M9.94 2.03a.75.75 0 0 1 1.06 0l6 6a.75.75 0 0 1 0 1.06l-2.25 2.25a.75.75 0 0 1-1.06 0L14.44 10a.75.75 0 0 0-1.06 0l-3-3a.75.75 0 0 0-1.06 0l-2.25 2.25a.75.75 0 0 1-1.06 0l-1.5-1.5a.75.75 0 0 1 0-1.06l6-6Z" clipRule="evenodd" /></svg>;


// *** BẮT ĐẦU CODE MỚI VÀ SỬA ĐỔI (Yêu cầu 1) ***

// Icon mới cho Trình Chỉnh Sửa Thế Giới
const GlobeAltIcon = ({className="w-5 h-5 mr-2"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className={className}><path fillRule="evenodd" d="M12 2.25c-5.385 0-9.75 4.365-9.75 9.75s4.365 9.75 9.75 9.75 9.75-4.365 9.75-9.75S17.385 2.25 12 2.25ZM9 9.375a.75.75 0 0 1 .75-.75h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1-.75-.75Zm0 3.375a.75.75 0 0 1 .75-.75h4.5a.75.75 0 0 1 0 1.5h-4.5a.75.75 0 0 1-.75-.75Z" clipRule="evenodd" /><path d="M14.05 6.139a.75.75 0 0 1 .884.28l1.458 2.527a.75.75 0 0 1 0 .708l-1.458 2.527a.75.75 0 0 1-1.164-.672L13.5 9.75l.324-2.834a.75.75 0 0 1 .226-.777ZM8.84 12.213a.75.75 0 0 1 1.164.672L10.5 15l-.324 2.834a.75.75 0 0 1-1.451-.374l.83-7.247Z" /></svg>;
const CommandLineIcon = ({className="w-4 h-4"}) => <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor" className={className}><path fillRule="evenodd" d="M3.5 3A1.5 1.5 0 0 0 2 4.5v7A1.5 1.5 0 0 0 3.5 13h9a1.5 1.5 0 0 0 1.5-1.5v-7A1.5 1.5 0 0 0 12.5 3h-9ZM3 4.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-.5.5h-9a.5.5 0 0 1-.5-.5v-7Zm2.75 2a.75.75 0 0 0 0 1.5h4.5a.75.75 0 0 0 0-1.5h-4.5Z" clipRule="evenodd" /></svg>;
// *** BẮT ĐẦU COMPONENT NỀN HẠT MỚI ***
// *** BẮT ĐẦU COMPONENT NỀN HẠT PHIÊN BẢN MỚI ***
// *** BẮT ĐẦU COMPONENT NỀN HẠT PHIÊN BẢN CUỐI CÙNG (FIX STUTTER) ***
const ParticleBackground = () => {
    const canvasRef = useRef(null);
    const mouse = useRef({ x: 0, y: 0, isInside: false });
    const particlesArray = useRef([]);
    const animationFrameId = useRef(null);

    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;

        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        class Particle {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 2.5 + 1;
                this.speedX = (Math.random() - 0.5) * 2;
                this.speedY = (Math.random() - 0.5) * 2;
                this.life = 1;
                this.decay = 0.01;
            }

            update() {
                const dx = mouse.current.x - this.x;
                const dy = mouse.current.y - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 150) {
                    // Lực hút về phía chuột
                    const attractionForce = 0.05;
                    this.speedX += dx / (distance * 20);
                    this.speedY += dy / (distance * 20);
                    
                    // THÊM LỰC XOẮN ỐC - Tạo chuyển động xoay quanh chuột
                    const angle = Math.atan2(dy, dx);
                    const spiralForce = 0.03; // Điều chỉnh độ mạnh của xoắn ốc
                    
                    // Tạo lực vuông góc với hướng về chuột (tạo xoắn ốc)
                    this.speedX += Math.cos(angle + Math.PI / 2) * spiralForce;
                    this.speedY += Math.sin(angle + Math.PI / 2) * spiralForce;
                }

                this.speedX *= 0.98;
                this.speedY *= 0.98;
                this.x += this.speedX;
                this.y += this.speedY;

                if (this.life > 0) {
                    this.life -= this.decay;
                }
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = Math.max(0, this.life);
                ctx.fillStyle = 'black'; // Đổi từ 'white' thành 'black'
                ctx.shadowBlur = 8;
                ctx.shadowColor = 'rgba(0, 0, 0, 0.7)'; // Đổi shadow từ trắng thành đen
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        const animate = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Vòng lặp này giờ CHỈ CẬP NHẬT VÀ VẼ
            for (let i = particlesArray.current.length - 1; i >= 0; i--) {
                const particle = particlesArray.current[i];
                particle.update();
                particle.draw();

                if (particle.life <= 0) {
                    particlesArray.current.splice(i, 1);
                }
            }

            animationFrameId.current = requestAnimationFrame(animate);
        };

        const handleMouseMove = (e) => {
            const rect = canvas.getBoundingClientRect();
            mouse.current.x = e.clientX - rect.left;
            mouse.current.y = e.clientY - rect.top;

            // TẠO HẠT MỚI TRỰC TIẾP TẠI ĐÂY - VÙNG TẠO HẠT LỚN HƠN
            if (mouse.current.isInside && particlesArray.current.length < 200) {
                for (let i = 0; i < 3; i++) { // Tăng số lượng hạt mỗi lần tạo
                    particlesArray.current.push(new Particle(
                        mouse.current.x + (Math.random() - 0.5) * 300, // Tăng từ 25 lên 50
                        mouse.current.y + (Math.random() - 0.5) * 300  // Tăng từ 25 lên 50
                    ));
                }
            }
        };

        const handleMouseEnter = () => {
            mouse.current.isInside = true;
        };

        const handleMouseLeave = () => {
            mouse.current.isInside = false;
        };

        const handleResize = () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        };

        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseenter', handleMouseEnter);
        canvas.addEventListener('mouseleave', handleMouseLeave);
        window.addEventListener('resize', handleResize);

        animate(); // Bắt đầu vòng lặp animation

        return () => {
            canvas.removeEventListener('mousemove', handleMouseMove);
            canvas.removeEventListener('mouseenter', handleMouseEnter);
            canvas.removeEventListener('mouseleave', handleMouseLeave);
            window.removeEventListener('resize', handleResize);
            if (animationFrameId.current) {
                cancelAnimationFrame(animationFrameId.current);
            }
        };
    }, []);

    return (
        <canvas
            ref={canvasRef}
            style={{
                position: 'absolute', // QUAN TRỌNG: Phải là absolute, không phải fixed
                top: 0,
                left: 0,
                width: '100%',        // QUAN TRỌNG: Phải là 100%, không phải 100vw
                height: '100%',       // QUAN TRỌNG: Phải là 100%, không phải 100vh
                pointerEvents: 'auto' // QUAN TRỌNG: Đảm bảo nhận được sự kiện chuột
                // QUAN TRỌNG: Không có zIndex: -1 và background ở đây
            }}
        />
    );
};
// *** KẾT THÚC COMPONENT NỀN HẠT PHIÊN BẢN CUỐI CÙNG (FIX STUTTER) ***
// *** KẾT THÚC COMPONENT NỀN HẠT PHIÊN BẢN MỚI ***
// *** KẾT THÚC COMPONENT NỀN HẠT MỚI ***
// *** BẮT ĐẦU SỬA ĐỔI: Nâng cấp WorldEditorModal và sửa lỗi ***
const WorldEditorModal = ({ show, onClose, worldKnowledge, setWorldKnowledge, showNotification, onSaveWorldKnowledge }) => {
    if (!show) return null;

    const [activeTab, setActiveTab] = useState('items');
    const [currentItem, setCurrentItem] = useState(null);
    const [currentSkill, setCurrentSkill] = useState(null);
    const [currentSystem, setCurrentSystem] = useState(null);
    // *** BẮT ĐẦU ĐOẠN CODE CẦN THÊM ***
    const [currentRace, setCurrentRace] = useState(null);
    const [currentLocation, setCurrentLocation] = useState(null);
    const [currentConcept, setCurrentConcept] = useState(null);
    const [currentEvent, setCurrentEvent] = useState(null);
// *** KẾT THÚC ĐOẠN CODE CẦN THÊM ***
// *** BẮT ĐẦU ĐOẠN CODE CẦN THÊM ***
    const [currentNpc, setCurrentNpc] = useState(null);
// *** KẾT THÚC ĐOẠN CODE CẦN THÊM ***


    // Handlers for Items
    const handleAddNewItem = () => setCurrentItem({ id: crypto.randomUUID(), Name: '', Description: '', Type: 'Tạp vật', Equippable: false, Slot: '', Usable: false, Consumable: false, Uses: 0, EffectDescription: '', StatsBonus: '', SideEffect: '', craftingConditions: '', upgradeFrom: '' });
    const handleEditItem = (item) => setCurrentItem({ ...item });
    const handleSaveItem = () => {
        if (!currentItem.Name) {
            showNotification("Tên vật phẩm không được để trống.", "error");
            return;
        }
        setWorldKnowledge(prev => {
            const newItems = [...prev.items];
            const existingIndex = newItems.findIndex(i => i.id === currentItem.id);
            if (existingIndex > -1) {
                newItems[existingIndex] = currentItem;
            } else {
                newItems.push(currentItem);
            }
            return { ...prev, items: newItems };
        });
        setCurrentItem(null);
    };
    const handleDeleteItem = (itemId) => {
        setWorldKnowledge(prev => ({ ...prev, items: prev.items.filter(i => i.id !== itemId) }));
    };

    // Handlers for Skills
    const handleAddNewSkill = () => setCurrentSkill({ id: crypto.randomUUID(), Name: '', Description: '', Type: 'Chủ động', Equippable: false, EquipSlot: '', manaCost: 0, cooldown: 0, effect: '', upgradeFrom: '', upgradeConditions: '' });
    const handleEditSkill = (skill) => setCurrentSkill({ ...skill });
    const handleSaveSkill = () => {
        if (!currentSkill.Name) {
            showNotification("Tên kỹ năng không được để trống.", "error");
            return;
        }
        setWorldKnowledge(prev => {
            const newSkills = [...prev.skills];
            const existingIndex = newSkills.findIndex(s => s.id === currentSkill.id);
            if (existingIndex > -1) {
                newSkills[existingIndex] = currentSkill;
            } else {
                newSkills.push(currentSkill);
            }
            return { ...prev, skills: newSkills };
        });
        setCurrentSkill(null);
    };
    const handleDeleteSkill = (skillId) => {
        setWorldKnowledge(prev => ({ ...prev, skills: prev.skills.filter(s => s.id !== skillId) }));
    };

    // Handlers for Cultivation Systems
    const handleAddNewSystem = () => setCurrentSystem({ id: crypto.randomUUID(), systemName: '', realms: '' });
    const handleEditSystem = (system) => {
        setCurrentSystem({ ...system, realms: system.realms.join(', ') });
    };
    const handleSaveSystem = () => {
        if (!currentSystem.systemName || !currentSystem.realms) {
            showNotification("Tên hệ thống và danh sách cảnh giới không được để trống.", "error");
            return;
        }
        setWorldKnowledge(prev => {
            const systemToSave = {
                ...currentSystem,
                realms: currentSystem.realms.split(',').map(r => r.trim()).filter(r => r)
            };
            const newSystems = [...prev.cultivationSystems];
            const existingIndex = newSystems.findIndex(s => s.id === systemToSave.id);
            if (existingIndex > -1) {
                newSystems[existingIndex] = systemToSave;
            } else {
                newSystems.push(systemToSave);
            }
            return { ...prev, cultivationSystems: newSystems };
        });
        setCurrentSystem(null);
    };
    const handleDeleteSystem = (systemId) => {
        setWorldKnowledge(prev => ({ ...prev, cultivationSystems: prev.cultivationSystems.filter(s => s.id !== systemId) }));
    };

    // *** BẮT ĐẦU KHỐI CODE LỚN CẦN THÊM ***
    // Handlers for Races
    const handleAddNewRace = () => setCurrentRace({ id: crypto.randomUUID(), name: '', description: '', talents: '', weaknesses: '', relations: '' });
    const handleEditRace = (race) => setCurrentRace({ ...race });
    const handleSaveRace = () => {
        if (!currentRace.name) {
            showNotification("Tên Chủng Tộc không được để trống.", "error");
            return;
        }
        setWorldKnowledge(prev => {
            const newRaces = [...(prev.races || [])];
            const existingIndex = newRaces.findIndex(r => r.id === currentRace.id);
            if (existingIndex > -1) newRaces[existingIndex] = currentRace;
            else newRaces.push(currentRace);
            return { ...prev, races: newRaces };
        });
        setCurrentRace(null);
    };
    const handleDeleteRace = (raceId) => {
        setWorldKnowledge(prev => ({ ...prev, races: (prev.races || []).filter(r => r.id !== raceId) }));
    };

    // Handlers for Locations
    const handleAddNewLocation = () => setCurrentLocation({ id: crypto.randomUUID(), name: '', type: 'Dã ngoại', description: '', resources: '', dangerLevel: 'An toàn', entryCondition: '' });
    const handleEditLocation = (location) => setCurrentLocation({ ...location });
    const handleSaveLocation = () => {
        if (!currentLocation.name) {
            showNotification("Tên Địa Điểm không được để trống.", "error");
            return;
        }
        setWorldKnowledge(prev => {
            const newLocations = [...(prev.locations || [])];
            const existingIndex = newLocations.findIndex(l => l.id === currentLocation.id);
            if (existingIndex > -1) newLocations[existingIndex] = currentLocation;
            else newLocations.push(currentLocation);
            return { ...prev, locations: newLocations };
        });
        setCurrentLocation(null);
    };
    const handleDeleteLocation = (locationId) => {
        setWorldKnowledge(prev => ({ ...prev, locations: (prev.locations || []).filter(l => l.id !== locationId) }));
    };

    // Handlers for Concepts
    const handleAddNewConcept = () => setCurrentConcept({ id: crypto.randomUUID(), name: '', type: 'Quy tắc thế giới', description: '', influence: '' });
    const handleEditConcept = (concept) => setCurrentConcept({ ...concept });
    const handleSaveConcept = () => {
        if (!currentConcept.name) {
            showNotification("Tên Khái Niệm không được để trống.", "error");
            return;
        }
        setWorldKnowledge(prev => {
            const newConcepts = [...(prev.concepts || [])];
            const existingIndex = newConcepts.findIndex(c => c.id === currentConcept.id);
            if (existingIndex > -1) newConcepts[existingIndex] = currentConcept;
            else newConcepts.push(currentConcept);
            return { ...prev, concepts: newConcepts };
        });
        setCurrentConcept(null);
    };
    const handleDeleteConcept = (conceptId) => {
        setWorldKnowledge(prev => ({ ...prev, concepts: (prev.concepts || []).filter(c => c.id !== conceptId) }));
    };

    // Handlers for Events
    const handleAddNewEvent = () => setCurrentEvent({ id: crypto.randomUUID(), name: '', description: '', trigger: '', effect: '' });
    const handleEditEvent = (event) => setCurrentEvent({ ...event });
    const handleSaveEvent = () => {
        if (!currentEvent.name) {
            showNotification("Tên Sự Kiện không được để trống.", "error");
            return;
        }
        setWorldKnowledge(prev => {
            const newEvents = [...(prev.events || [])];
            const existingIndex = newEvents.findIndex(e => e.id === currentEvent.id);
            if (existingIndex > -1) newEvents[existingIndex] = currentEvent;
            else newEvents.push(currentEvent);
            return { ...prev, events: newEvents };
        });
        setCurrentEvent(null);
    };
    const handleDeleteEvent = (eventId) => {
        setWorldKnowledge(prev => ({ ...prev, events: (prev.events || []).filter(e => e.id !== eventId) }));
    };

    // *** BẮT ĐẦU KHỐI CODE LỚN CẦN THÊM ***
    // Handlers for NPCs
    const handleAddNewNpc = () => setCurrentNpc({ id: crypto.randomUUID(), name: '', type: 'Character', description: '', personality: '', cultivationSystem: worldKnowledge.cultivationSystems[0]?.systemName || '', realm: worldKnowledge.cultivationSystems[0]?.realms[0] || '', level: 1, talentTier: TALENT_TIERS[0]?.name || '', exp: 0, maxExp: 100, skills: [] }); // THÊM MỚI: skills: []
    const handleEditNpc = (npc) => setCurrentNpc({ ...npc });
    const handleSaveNpc = () => {
        if (!currentNpc.name) {
            showNotification("Tên NPC không được để trống.", "error");
            return;
        }
        // *** TÍNH TOÁN LẠI CHỈ SỐ TRƯỚC KHI LƯU ***
console.log(`[WorldEditor] Chuẩn bị lưu NPC: "${currentNpc.name}". Bắt đầu tính toán lại chỉ số.`);

// Tính toán maxExp trước
const npcWithMaxExp = {
    ...currentNpc,
    maxExp: calculateNpcMaxExp(currentNpc, worldKnowledge)
};
console.log(`[WorldEditor] Đã tính maxExp cho "${npcWithMaxExp.name}": ${npcWithMaxExp.maxExp}`);

// Sử dụng đối tượng đã có maxExp để tính toán các chỉ số còn lại
const finalStats = calculateBaseStats(npcWithMaxExp, worldKnowledge);
const npcToSave = { 
    ...npcWithMaxExp, 
    hp: finalStats.hp, 
    atk: finalStats.atk 
};
console.log(`[WorldEditor] Chỉ số cuối cùng của NPC để lưu:`, npcToSave);
        setWorldKnowledge(prev => {
            const newNpcs = [...(prev.npcs || [])];
            const existingIndex = newNpcs.findIndex(n => n.id === currentNpc.id);
            if (existingIndex > -1) newNpcs[existingIndex] = currentNpc;
            else newNpcs.push(currentNpc);
            return { ...prev, npcs: newNpcs };
        });
        setCurrentNpc(null);
    };
    const handleDeleteNpc = (npcId) => {
        setWorldKnowledge(prev => ({ ...prev, npcs: (prev.npcs || []).filter(n => n.id !== npcId) }));
    };

    const renderNpcEditor = () => {
        // Cần lấy danh sách cảnh giới tương ứng với hệ tu luyện đang được chọn cho NPC
        const selectedSystem = worldKnowledge.cultivationSystems.find(s => s.systemName === currentNpc.cultivationSystem);
        const availableRealms = selectedSystem ? selectedSystem.realms : [];
        // *** BẮT ĐẦU LOGIC TÍNH TOÁN ***
        // Tạo một entity tạm thời từ state của form để tính toán
        const tempEntityForCalc = {
            level: currentNpc.level || 1,
            realm: currentNpc.realm,
            cultivationSystem: currentNpc.cultivationSystem,
            talentTier: currentNpc.talentTier,
        };
        // Gọi hàm tính toán
        const calculatedStats = calculateBaseStats(tempEntityForCalc, worldKnowledge);
        // *** KẾT THÚC LOGIC TÍNH TOÁN ***
        
        return (
            <div className="bg-gray-700/50 p-4 rounded-lg border border-gray-600 space-y-3 mt-4 animate-fade-in">
                <h4 className="text-lg font-semibold text-teal-300">Sửa/Thêm NPC Cốt Lõi</h4>
                <input type="text" placeholder="Tên NPC" value={currentNpc.name} onChange={e => setCurrentNpc({ ...currentNpc, name: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" />
                <textarea placeholder="Mô tả, tiểu sử" value={currentNpc.description} onChange={e => setCurrentNpc({ ...currentNpc, description: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" rows="3"></textarea>
                <input type="text" placeholder="Tính cách" value={currentNpc.personality} onChange={e => setCurrentNpc({ ...currentNpc, personality: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" />
                
                <div className="grid grid-cols-2 md:grid-cols-4 gap-4 pt-3 border-t border-gray-600">
                    <div>
                        <label className="block text-sm font-medium text-gray-300 mb-1">Hệ Tu Luyện</label>
                        <select name="cultivationSystem" value={currentNpc.cultivationSystem} onChange={e => setCurrentNpc({ ...currentNpc, cultivationSystem: e.target.value, realm: worldKnowledge.cultivationSystems.find(s=>s.systemName === e.target.value)?.realms[0] || '' })} className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md text-xs">
                            {worldKnowledge.cultivationSystems.map(sys => <option key={sys.id} value={sys.systemName}>{sys.systemName}</option>)}
                        </select>
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-300 mb-1">Thiên Phú</label>
                        <select name="talentTier" value={currentNpc.talentTier} onChange={e => setCurrentNpc({ ...currentNpc, talentTier: e.target.value })} className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md text-xs">
                            {TALENT_TIERS.map(tier => <option key={tier.name} value={tier.name}>{tier.name}</option>)}
                        </select>
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-300 mb-1">Cảnh Giới</label>
                        <select 
                            name="realm" 
                            value={currentNpc.realm} 
                            onChange={e => {
                                const newRealm = e.target.value;
                                const realmIndex = availableRealms.indexOf(newRealm);
                                // Tự động cập nhật level về mức khởi đầu của cảnh giới mới
                                const newLevel = realmIndex !== -1 ? (realmIndex * 10) + 1 : 1;
                                setCurrentNpc({ ...currentNpc, realm: newRealm, level: newLevel });
                            }} 
                            className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md text-xs" 
                            disabled={!availableRealms.length}
                        >
                            {availableRealms.map(r => <option key={r} value={r}>{r}</option>)}
                        </select>
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-gray-300 mb-1">Cấp Độ</label>
                        <input type="number" name="level" value={currentNpc.level} onChange={e => setCurrentNpc({ ...currentNpc, level: parseInt(e.target.value) || 1 })} className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md" />
                    </div>
                </div>
                {/* *** BẮT ĐẦU KHU VỰC HIỂN THỊ CHỈ SỐ MỚI *** */}
                <div className="grid grid-cols-2 gap-4 pt-3 border-t border-dashed border-gray-600">
                    <div>
                        <label className="block text-sm font-medium text-red-300 mb-1">HP (Tự động)</label>
                        <input type="text" value={formatLargeNumber(calculatedStats.hp)} disabled className="w-full p-2 bg-gray-900 rounded border border-gray-500 text-red-200 cursor-not-allowed" title="Chỉ số này được tính toán tự động" />
                    </div>
                    <div>
                        <label className="block text-sm font-medium text-orange-300 mb-1">ATK (Tự động)</label>
                        <input type="text" value={formatLargeNumber(calculatedStats.atk)} disabled className="w-full p-2 bg-gray-900 rounded border border-gray-500 text-orange-200 cursor-not-allowed" title="Chỉ số này được tính toán tự động" />
                    </div>
                </div>
                {/* *** KẾT THÚC KHU VỰC HIỂN THỊ CHỈ SỐ MỚI *** */}
{/* === BẮT ĐẦU KHU VỰC QUẢN LÝ KỸ NĂNG NPC === */}
                <div className="pt-3 border-t border-dashed border-gray-600">
                    <label className="block text-sm font-medium text-gray-300 mb-1">Kỹ Năng Sở Hữu</label>
                    {/* Khu vực hiển thị các kỹ năng NPC đã có */}
                    <div className="flex flex-wrap gap-2 p-2 bg-gray-900/50 rounded-md min-h-[40px] mb-2 border border-gray-600">
                        {(currentNpc.skills || []).map(skill => {
                            // Tìm thông tin đầy đủ của kỹ năng từ worldKnowledge
                            const fullSkillInfo = (worldKnowledge.skills || []).find(s => s.id === skill.id);
                            return (
                                <div key={skill.id} className="flex items-center gap-2 bg-yellow-600 text-white text-xs font-semibold px-2.5 py-1 rounded-full">
                                    <span>{fullSkillInfo ? fullSkillInfo.Name : 'Kỹ năng không xác định'}</span>
                                    <button
                                        type="button"
                                        onClick={() => {
                                            console.log(`[DEBUG] Removing skill ID ${skill.id} from NPC ${currentNpc.name}`);
                                            const updatedSkills = (currentNpc.skills || []).filter(s => s.id !== skill.id);
                                            setCurrentNpc({ ...currentNpc, skills: updatedSkills });
                                        }}
                                        className="bg-yellow-800 hover:bg-red-600 w-4 h-4 rounded-full flex items-center justify-center text-white"
                                        title="Gỡ bỏ kỹ năng"
                                    >
                                        &times;
                                    </button>
                                </div>
                            );
                        })}
                        {(!currentNpc.skills || currentNpc.skills.length === 0) && (
                            <p className="text-xs text-gray-500 italic">NPC chưa có kỹ năng nào. Chọn từ danh sách bên dưới...</p>
                        )}
                    </div>
                    {/* Dropdown để thêm kỹ năng mới từ danh sách có sẵn */}
                    <select
                        value="" // Luôn reset để có thể chọn lại
                        onChange={e => {
                            const selectedSkillId = e.target.value;
                            if (selectedSkillId) {
                                // Tìm thông tin kỹ năng được chọn
                                const skillToAdd = (worldKnowledge.skills || []).find(s => s.id === selectedSkillId);
                                if (skillToAdd) {
                                    console.log(`[DEBUG] Adding skill "${skillToAdd.Name}" (ID: ${selectedSkillId}) to NPC ${currentNpc.name}`);
                                    const updatedSkills = [...(currentNpc.skills || []), { id: skillToAdd.id, Name: skillToAdd.Name }];
                                    setCurrentNpc({ ...currentNpc, skills: updatedSkills });
                                }
                            }
                        }}
                        className="w-full p-2 bg-gray-800 rounded border border-gray-500"
                    >
                        <option value="">-- Chọn để thêm kỹ năng cho NPC --</option>
                        {(worldKnowledge.skills || [])
                            .filter(s => !(currentNpc.skills || []).some(npcSkill => npcSkill.id === s.id)) // Lọc ra những kỹ năng NPC chưa có
                            .map(s => (
                                <option key={s.id} value={s.id}>{s.Name}</option>
                            ))
                        }
                    </select>
                </div>
                {/* === KẾT THÚC KHU VỰC QUẢN LÝ KỸ NĂNG NPC === */}
                <div className="flex justify-end gap-2">
                    <button onClick={() => setCurrentNpc(null)} className="py-2 px-4 bg-gray-600 rounded">Hủy</button>
                    <button onClick={handleSaveNpc} className="py-2 px-4 bg-green-600 rounded">Lưu</button>
                </div>
            </div>
        );
    }
// *** KẾT THÚC KHỐI CODE LỚN CẦN THÊM ***

    const renderRaceEditor = () => (
        <div className="bg-gray-700/50 p-4 rounded-lg border border-gray-600 space-y-3 mt-4 animate-fade-in">
            <h4 className="text-lg font-semibold text-lime-300">Sửa/Thêm Chủng Tộc</h4>
            <input type="text" placeholder="Tên Chủng Tộc" value={currentRace.name} onChange={e => setCurrentRace({ ...currentRace, name: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" />
            <textarea placeholder="Mô tả ngoại hình, nguồn gốc" value={currentRace.description} onChange={e => setCurrentRace({ ...currentRace, description: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" rows="3"></textarea>
            <textarea placeholder="Thiên phú/Đặc điểm bẩm sinh" value={currentRace.talents} onChange={e => setCurrentRace({ ...currentRace, talents: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" rows="2"></textarea>
            <textarea placeholder="Điểm yếu" value={currentRace.weaknesses} onChange={e => setCurrentRace({ ...currentRace, weaknesses: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" rows="2"></textarea>
            <textarea placeholder="Quan hệ với chủng tộc khác" value={currentRace.relations} onChange={e => setCurrentRace({ ...currentRace, relations: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" rows="2"></textarea>
            <div className="flex justify-end gap-2">
                <button onClick={() => setCurrentRace(null)} className="py-2 px-4 bg-gray-600 rounded">Hủy</button>
                <button onClick={handleSaveRace} className="py-2 px-4 bg-green-600 rounded">Lưu</button>
            </div>
        </div>
    );

    const renderLocationEditor = () => (
         <div className="bg-gray-700/50 p-4 rounded-lg border border-gray-600 space-y-3 mt-4 animate-fade-in">
            <h4 className="text-lg font-semibold text-cyan-300">Sửa/Thêm Địa Điểm</h4>
            <input type="text" placeholder="Tên Địa Điểm" value={currentLocation.name} onChange={e => setCurrentLocation({ ...currentLocation, name: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" />
            <select value={currentLocation.type} onChange={e => setCurrentLocation({ ...currentLocation, type: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500">
                <option>Dã ngoại</option><option>Thành trì</option><option>Phế tích</option><option>Cấm địa</option><option>Môn phái</option>
            </select>
            <textarea placeholder="Mô tả, lịch sử (lore)" value={currentLocation.description} onChange={e => setCurrentLocation({ ...currentLocation, description: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" rows="3"></textarea>
            <input type="text" placeholder="Tài nguyên/Cơ duyên đặc thù" value={currentLocation.resources} onChange={e => setCurrentLocation({ ...currentLocation, resources: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" />
            <select value={currentLocation.dangerLevel} onChange={e => setCurrentLocation({ ...currentLocation, dangerLevel: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500">
                <option>An toàn</option><option>Nguy hiểm</option><option>Cửu tử nhất sinh</option>
            </select>
            <input type="text" placeholder="Điều kiện ra/vào" value={currentLocation.entryCondition} onChange={e => setCurrentLocation({ ...currentLocation, entryCondition: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" />
            <div className="flex justify-end gap-2">
                <button onClick={() => setCurrentLocation(null)} className="py-2 px-4 bg-gray-600 rounded">Hủy</button>
                <button onClick={handleSaveLocation} className="py-2 px-4 bg-green-600 rounded">Lưu</button>
            </div>
        </div>
    );

    const renderConceptEditor = () => (
         <div className="bg-gray-700/50 p-4 rounded-lg border border-gray-600 space-y-3 mt-4 animate-fade-in">
            <h4 className="text-lg font-semibold text-orange-300">Sửa/Thêm Khái Niệm</h4>
            <input type="text" placeholder="Tên Khái Niệm" value={currentConcept.name} onChange={e => setCurrentConcept({ ...currentConcept, name: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" />
            <select value={currentConcept.type} onChange={e => setCurrentConcept({ ...currentConcept, type: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500">
                <option>Quy tắc thế giới</option><option>Tổ chức</option><option>Lời nguyền</option><option>Sự kiện lịch sử</option><option>Lời tiên tri</option>
            </select>
            <textarea placeholder="Mô tả chi tiết" value={currentConcept.description} onChange={e => setCurrentConcept({ ...currentConcept, description: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" rows="4"></textarea>
            <textarea placeholder="Ảnh hưởng tới thế giới" value={currentConcept.influence} onChange={e => setCurrentConcept({ ...currentConcept, influence: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" rows="2"></textarea>
            <div className="flex justify-end gap-2">
                <button onClick={() => setCurrentConcept(null)} className="py-2 px-4 bg-gray-600 rounded">Hủy</button>
                <button onClick={handleSaveConcept} className="py-2 px-4 bg-green-600 rounded">Lưu</button>
            </div>
        </div>
    );

    const renderEventEditor = () => (
         <div className="bg-gray-700/50 p-4 rounded-lg border border-gray-600 space-y-3 mt-4 animate-fade-in">
            <h4 className="text-lg font-semibold text-red-300">Sửa/Thêm Sự Kiện</h4>
            <input type="text" placeholder="Tên Sự Kiện" value={currentEvent.name} onChange={e => setCurrentEvent({ ...currentEvent, name: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" />
            <textarea placeholder="Mô tả" value={currentEvent.description} onChange={e => setCurrentEvent({ ...currentEvent, description: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" rows="3"></textarea>
            <input type="text" placeholder="Điều kiện kích hoạt (Trigger)" value={currentEvent.trigger} onChange={e => setCurrentEvent({ ...currentEvent, trigger: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" />
            <textarea placeholder="Tác động/Kết quả (Mô tả cho AI)" value={currentEvent.effect} onChange={e => setCurrentEvent({ ...currentEvent, effect: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" rows="3"></textarea>
            <div className="flex justify-end gap-2">
                <button onClick={() => setCurrentEvent(null)} className="py-2 px-4 bg-gray-600 rounded">Hủy</button>
                <button onClick={handleSaveEvent} className="py-2 px-4 bg-green-600 rounded">Lưu</button>
            </div>
        </div>
    );

// *** KẾT THÚC KHỐI CODE LỚN CẦN THÊM ***


    const renderItemEditor = () => (
        <div className="bg-gray-700/50 p-4 rounded-lg border border-gray-600 space-y-3 mt-4 animate-fade-in">
            <h4 className="text-lg font-semibold text-purple-300">{!currentItem.Name ? "Thêm Vật Phẩm Mới" : "Sửa Vật Phẩm"}</h4>
            <input type="text" placeholder="Tên Vật Phẩm" value={currentItem.Name} onChange={e => setCurrentItem({ ...currentItem, Name: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" />
            <textarea placeholder="Mô Tả" value={currentItem.Description} onChange={e => setCurrentItem({ ...currentItem, Description: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" rows="2"></textarea>
            <input type="text" placeholder="Loại (VD: Đan dược, Pháp bảo...)" value={currentItem.Type} onChange={e => setCurrentItem({ ...currentItem, Type: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" />
            <textarea placeholder="Công dụng" value={currentItem.EffectDescription} onChange={e => setCurrentItem({ ...currentItem, EffectDescription: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" rows="2"></textarea>
                        <div>
                <label className="block text-sm font-medium text-gray-300 mb-1 flex items-center">
                    Cộng Chỉ Số
                    <Tooltip content={
                        <div>
                            <h4 className="font-bold mb-1">Hướng Dẫn Nhập Chỉ Số Bonus</h4>
                            <p className="mb-2">Dùng để thêm các chỉ số vĩnh viễn cho vật phẩm hoặc kỹ năng.</p>
                            <p><strong>Cú Pháp:</strong> `tên_chỉ_số:giá_trị`</p>
                            <p><strong>Nhiều chỉ số:</strong> Ngăn cách bằng dấu phẩy. VD: `atk:10,maxHp:50`</p>
                            <p><strong>Phần trăm (%):</strong> Thêm dấu `%`. VD: `atk:%20` (Tăng 20% ATK cơ bản)</p>
                            <p className="mt-2"><strong>Các Chỉ Số Hợp Lệ:</strong></p>
                            <ul className="list-disc list-inside text-xs">
                                <li>`hp`, `maxHp`: Sinh lực</li>
                                <li>`mana`, `maxMana`: Năng lượng</li>
                                <li>`atk`: Công kích</li>
                                <li>`exp`: Kinh nghiệm (cộng một lần)</li>
                            </ul>
                        </div>
                    } />
                </label>
                <input type="text" placeholder="VD: atk:5,maxHp:20,exp:100" value={currentItem.StatsBonus} onChange={e => setCurrentItem({ ...currentItem, StatsBonus: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" />
                <p className="text-xs text-gray-500 mt-1 italic">Dùng dấu ',' để ngăn cách. Dùng '%' cho giá trị phần trăm.</p>
            </div>
            <textarea placeholder="Công thức & Điều kiện Chế tạo/Nâng cấp" value={currentItem.craftingConditions || ''} onChange={e => setCurrentItem({ ...currentItem, craftingConditions: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" rows="2"></textarea>
            <div>
                <label className="block text-sm font-medium text-gray-300 mb-1">Nâng cấp từ Vật phẩm:</label>
                <select value={currentItem.upgradeFrom || ''} onChange={e => setCurrentItem({ ...currentItem, upgradeFrom: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500">
                    <option value="">-- Không có --</option>
                    {(worldKnowledge.items || []).filter(i => i.id !== currentItem.id).map(i => (
                        <option key={i.id} value={i.id}>{i.Name}</option>
                    ))}
                </select>
            </div>
            <div className="grid grid-cols-2 gap-4">
                <label className="flex items-center gap-2"><input type="checkbox" checked={currentItem.Equippable} onChange={e => setCurrentItem({ ...currentItem, Equippable: e.target.checked })} /> Có thể trang bị</label>
                <input type="text" placeholder="Slot (VD: weapon, head)" disabled={!currentItem.Equippable} value={currentItem.Slot} onChange={e => setCurrentItem({ ...currentItem, Slot: e.target.value })} className="p-2 bg-gray-800 rounded border border-gray-500 disabled:bg-gray-600" />
                <label className="flex items-center gap-2"><input type="checkbox" checked={currentItem.Usable} onChange={e => setCurrentItem({ ...currentItem, Usable: e.target.checked })} /> Có thể dùng</label>
                <label className="flex items-center gap-2"><input type="checkbox" checked={currentItem.Consumable} onChange={e => setCurrentItem({ ...currentItem, Consumable: e.target.checked })} /> Tiêu hao</label>
            </div>
            <div className="flex justify-end gap-2">
                <button onClick={() => setCurrentItem(null)} className="py-2 px-4 bg-gray-600 rounded">Hủy</button>
                <button onClick={handleSaveItem} className="py-2 px-4 bg-green-600 rounded">Lưu</button>
            </div>
        </div>
    );

    const renderSkillEditor = () => (
        <div className="bg-gray-700/50 p-4 rounded-lg border border-gray-600 space-y-3 mt-4 animate-fade-in">
            <h4 className="text-lg font-semibold text-yellow-300">{!currentSkill.Name ? "Thêm Kỹ Năng Mới" : "Sửa Kỹ Năng"}</h4>
            <input type="text" placeholder="Tên Kỹ Năng" value={currentSkill.Name} onChange={e => setCurrentSkill({ ...currentSkill, Name: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" />
            <textarea placeholder="Mô Tả" value={currentSkill.Description} onChange={e => setCurrentSkill({ ...currentSkill, Description: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" rows="2"></textarea>
            <input type="text" placeholder="Loại (VD: Chủ động, Bị động, Công pháp...)" value={currentSkill.Type} onChange={e => setCurrentSkill({ ...currentSkill, Type: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" />
            <textarea placeholder="Hiệu ứng" value={currentSkill.effect} onChange={e => setCurrentSkill({ ...currentSkill, effect: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" rows="2"></textarea>
            <div className="grid grid-cols-2 gap-4">
                <input type="number" placeholder="Mana Cost" value={currentSkill.manaCost} onChange={e => setCurrentSkill({ ...currentSkill, manaCost: parseInt(e.target.value) || 0 })} className="p-2 bg-gray-800 rounded border border-gray-500" />
                <input type="number" placeholder="Cooldown" value={currentSkill.cooldown} onChange={e => setCurrentSkill({ ...currentSkill, cooldown: parseInt(e.target.value) || 0 })} className="p-2 bg-gray-800 rounded border border-gray-500" />
                <label className="flex items-center gap-2"><input type="checkbox" checked={currentSkill.Equippable} onChange={e => setCurrentSkill({ ...currentSkill, Equippable: e.target.checked })} /> Là Công pháp</label>
                <input type="text" placeholder="Slot Công pháp (main, sub1...)" disabled={!currentSkill.Equippable} value={currentSkill.EquipSlot} onChange={e => setCurrentSkill({ ...currentSkill, EquipSlot: e.target.value })} className="p-2 bg-gray-800 rounded border border-gray-500 disabled:bg-gray-600" />
                {/* === BẮT ĐẦU ĐOẠN CODE CẦN THÊM === */}
                <div className="col-span-2">
                    <label className="block text-sm font-medium text-gray-300 mb-1 flex items-center">
                        Cộng Chỉ Số (cho Thiên phú/Bị động)
                         <Tooltip content={
                            <div>
                                <h4 className="font-bold mb-1">Hướng Dẫn Nhập Chỉ Số Bonus</h4>
                                <p className="mb-2">Chỉ có tác dụng với các kỹ năng loại Bị động, Thiên phú, Nội tại.</p>
                                <p><strong>Cú Pháp:</strong> `tên_chỉ_số:giá_trị`</p>
                                <p><strong>Nhiều chỉ số:</strong> Ngăn cách bằng dấu phẩy. VD: `atk:10,maxHp:50`</p>
                                <p><strong>Phần trăm (%):</strong> Thêm dấu `%`. VD: `atk:%20` (Tăng 20% ATK cơ bản)</p>
                                <p className="mt-2"><strong>Các Chỉ Số Hợp Lệ:</strong></p>
                                <ul className="list-disc list-inside text-xs">
                                    <li>`hp`, `maxHp`: Sinh lực</li>
                                    <li>`mana`, `maxMana`: Năng lượng</li>
                                    <li>`atk`: Công kích</li>
                                    <li>`exp`: Kinh nghiệm (cộng một lần)</li>
                                </ul>
                            </div>
                        } />
                    </label>
                     <input type="text" placeholder="VD: maxHp:100,atk:%5" value={currentSkill.StatsBonus || ''} onChange={e => setCurrentSkill({ ...currentSkill, StatsBonus: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" />
                </div>
{/* === KẾT THÚC ĐOẠN CODE CẦN THÊM === */}
            </div>
<div>
    <label className="block text-sm font-medium text-gray-300 mb-1">Nâng cấp/Dung hợp từ Kỹ năng:</label>
    
    {/* Khu vực hiển thị các kỹ năng đã chọn */}
    <div className="flex flex-wrap gap-2 p-2 bg-gray-900/50 rounded-md min-h-[40px] mb-2 border border-gray-600">
        {(currentSkill.upgradeFrom || []).map(skillId => {
            const skill = (worldKnowledge.skills || []).find(s => s.id === skillId);
            return (
                <div key={skillId} className="flex items-center gap-2 bg-purple-600 text-white text-xs font-semibold px-2.5 py-1 rounded-full">
                    <span>{skill ? skill.Name : 'Kỹ năng không xác định'}</span>
                    <button 
                        type="button"
                        onClick={() => {
                            const newUpgradeFrom = (currentSkill.upgradeFrom || []).filter(id => id !== skillId);
                            setCurrentSkill({ ...currentSkill, upgradeFrom: newUpgradeFrom });
                        }}
                        className="bg-purple-800 hover:bg-red-600 w-4 h-4 rounded-full flex items-center justify-center text-white"
                    >
                        &times;
                    </button>
                </div>
            );
        })}
        {(currentSkill.upgradeFrom || []).length === 0 && <p className="text-xs text-gray-500 italic">Chọn kỹ năng nguyên liệu từ danh sách bên dưới...</p>}
    </div>

    {/* Dropdown để thêm kỹ năng mới */}
    <select 
        value="" // Luôn reset để có thể chọn lại
        onChange={e => {
            const selectedId = e.target.value;
            if (selectedId && !(currentSkill.upgradeFrom || []).includes(selectedId)) {
                const newUpgradeFrom = [...(currentSkill.upgradeFrom || []), selectedId];
                setCurrentSkill({ ...currentSkill, upgradeFrom: newUpgradeFrom });
            }
        }} 
        className="w-full p-2 bg-gray-800 rounded border border-gray-500"
    >
        <option value="">-- Chọn để thêm kỹ năng nguyên liệu --</option>
        {(worldKnowledge.skills || [])
            .filter(s => s.id !== currentSkill.id && !(currentSkill.upgradeFrom || []).includes(s.id)) // Lọc ra những skill chưa được chọn
            .map(s => (
                <option key={s.id} value={s.id}>{s.Name}</option>
        ))}
    </select>
</div>
            <textarea placeholder="Điều kiện nâng cấp (mô tả bằng chữ)" value={currentSkill.upgradeConditions || ''} onChange={e => setCurrentSkill({ ...currentSkill, upgradeConditions: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" rows="2"></textarea>
            <div className="flex justify-end gap-2">
                <button onClick={() => setCurrentSkill(null)} className="py-2 px-4 bg-gray-600 rounded">Hủy</button>
                <button onClick={handleSaveSkill} className="py-2 px-4 bg-green-600 rounded">Lưu</button>
            </div>
        </div>
    );

    const renderSystemEditor = () => (
        <div className="bg-gray-700/50 p-4 rounded-lg border border-gray-600 space-y-3 mt-4 animate-fade-in">
            <h4 className="text-lg font-semibold text-sky-300">{!currentSystem.systemName ? "Thêm Hệ Thống Mới" : "Sửa Hệ Thống"}</h4>
            <input type="text" placeholder="Tên Hệ Thống (VD: Tiên Đạo, Ma Đạo)" value={currentSystem.systemName} onChange={e => setCurrentSystem({ ...currentSystem, systemName: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" />
            <textarea placeholder="Các cảnh giới, cách nhau bằng dấu phẩy (,)" value={currentSystem.realms} onChange={e => setCurrentSystem({ ...currentSystem, realms: e.target.value })} className="w-full p-2 bg-gray-800 rounded border border-gray-500" rows="4"></textarea>
            <div className="flex justify-end gap-2">
                <button onClick={() => setCurrentSystem(null)} className="py-2 px-4 bg-gray-600 rounded">Hủy</button>
                <button onClick={handleSaveSystem} className="py-2 px-4 bg-green-600 rounded">Lưu</button>
            </div>
        </div>
    );

    const renderItemsTab = () => (
        <div className="space-y-2">
            {!currentItem && <button onClick={handleAddNewItem} className="w-full mb-2 py-2 bg-green-700 hover:bg-green-600 rounded-lg flex items-center justify-center gap-2"><PlusIcon /> Thêm Vật Phẩm Mới</button>}
            {currentItem && renderItemEditor()}
            {(worldKnowledge.items || []).map(item => (
                <div key={item.id} className="bg-gray-700 p-3 rounded-lg flex justify-between items-center">
                    <div>
                        <p className="font-semibold text-purple-300">{item.Name} ({item.Type})</p>
                        <p className="text-xs text-gray-400 truncate w-64 md:w-96" title={item.Description}>{item.Description}</p>
                    </div>
                    <div className="flex gap-2">
                        <button onClick={() => handleEditItem(item)} className="p-2 bg-blue-600 rounded"><WrenchIcon className="w-4 h-4" /></button>
                        <button onClick={() => handleDeleteItem(item.id)} className="p-2 bg-red-600 rounded"><TrashIcon className="w-4 h-4" /></button>
                    </div>
                </div>
            ))}
        </div>
    );
    const renderSkillsTab = () => (
        <div className="space-y-2">
            {!currentSkill && <button onClick={handleAddNewSkill} className="w-full mb-2 py-2 bg-green-700 hover:bg-green-600 rounded-lg flex items-center justify-center gap-2"><PlusIcon /> Thêm Kỹ Năng Mới</button>}
            {currentSkill && renderSkillEditor()}
            {(worldKnowledge.skills || []).map(skill => (
                <div key={skill.id} className="bg-gray-700 p-3 rounded-lg flex justify-between items-center">
                    <div>
                        <p className="font-semibold text-yellow-300">{skill.Name} ({skill.Type})</p>
                        <p className="text-xs text-gray-400 truncate w-64 md:w-96" title={skill.Description}>{skill.Description}</p>
                    </div>
                    <div className="flex gap-2">
                        <button onClick={() => handleEditSkill(skill)} className="p-2 bg-blue-600 rounded"><WrenchIcon className="w-4 h-4" /></button>
                        <button onClick={() => handleDeleteSkill(skill.id)} className="p-2 bg-red-600 rounded"><TrashIcon className="w-4 h-4" /></button>
                    </div>
                </div>
            ))}
        </div>
    );
    const renderCultivationSystemsTab = () => (
        <div className="space-y-2">
            {!currentSystem && <button onClick={handleAddNewSystem} className="w-full mb-2 py-2 bg-green-700 hover:bg-green-600 rounded-lg flex items-center justify-center gap-2"><PlusIcon /> Thêm Hệ Thống Tu Luyện Mới</button>}
            {currentSystem && renderSystemEditor()}
            {worldKnowledge.cultivationSystems.map(system => (
                <div key={system.id} className="bg-gray-700 p-3 rounded-lg flex justify-between items-center">
                    <div>
                        <p className="font-semibold text-sky-300">{system.systemName}</p>
                        <p className="text-xs text-gray-400 truncate w-64 md:w-96" title={system.realms.join(', ')}>{system.realms.join(', ')}</p>
                    </div>
                    <div className="flex gap-2">
                        <button onClick={() => handleEditSystem(system)} className="p-2 bg-blue-600 rounded"><WrenchIcon className="w-4 h-4" /></button>
                        <button onClick={() => handleDeleteSystem(system.id)} className="p-2 bg-red-600 rounded"><TrashIcon className="w-4 h-4" /></button>
                    </div>
                </div>
            ))}
        </div>
    );

    // *** BẮT ĐẦU KHỐI CODE LỚN CẦN THÊM ***
    const renderRacesTab = () => (
        <div className="space-y-2">
            {!currentRace && <button onClick={handleAddNewRace} className="w-full mb-2 py-2 bg-green-700 hover:bg-green-600 rounded-lg flex items-center justify-center gap-2"><PlusIcon /> Thêm Chủng Tộc Mới</button>}
            {currentRace && renderRaceEditor()}
            {(worldKnowledge.races || []).map(race => (
                <div key={race.id} className="bg-gray-700 p-3 rounded-lg flex justify-between items-center">
                    <div>
                        <p className="font-semibold text-lime-300">{race.name}</p>
                        <p className="text-xs text-gray-400 truncate w-64 md:w-96" title={race.description}>{race.description}</p>
                    </div>
                    <div className="flex gap-2">
                        <button onClick={() => handleEditRace(race)} className="p-2 bg-blue-600 rounded"><WrenchIcon className="w-4 h-4" /></button>
                        <button onClick={() => handleDeleteRace(race.id)} className="p-2 bg-red-600 rounded"><TrashIcon className="w-4 h-4" /></button>
                    </div>
                </div>
            ))}
        </div>
    );

    const renderLocationsTab = () => (
        <div className="space-y-2">
            {!currentLocation && <button onClick={handleAddNewLocation} className="w-full mb-2 py-2 bg-green-700 hover:bg-green-600 rounded-lg flex items-center justify-center gap-2"><PlusIcon /> Thêm Địa Điểm Mới</button>}
            {currentLocation && renderLocationEditor()}
            {(worldKnowledge.locations || []).map(location => (
                <div key={location.id} className="bg-gray-700 p-3 rounded-lg flex justify-between items-center">
                    <div>
                        <p className="font-semibold text-cyan-300">{location.name} ({location.type})</p>
                        <p className="text-xs text-gray-400 truncate w-64 md:w-96" title={location.description}>{location.description}</p>
                    </div>
                    <div className="flex gap-2">
                        <button onClick={() => handleEditLocation(location)} className="p-2 bg-blue-600 rounded"><WrenchIcon className="w-4 h-4" /></button>
                        <button onClick={() => handleDeleteLocation(location.id)} className="p-2 bg-red-600 rounded"><TrashIcon className="w-4 h-4" /></button>
                    </div>
                </div>
            ))}
        </div>
    );

    const renderConceptsTab = () => (
        <div className="space-y-2">
            {!currentConcept && <button onClick={handleAddNewConcept} className="w-full mb-2 py-2 bg-green-700 hover:bg-green-600 rounded-lg flex items-center justify-center gap-2"><PlusIcon /> Thêm Khái Niệm Mới</button>}
            {currentConcept && renderConceptEditor()}
            {(worldKnowledge.concepts || []).map(concept => (
                <div key={concept.id} className="bg-gray-700 p-3 rounded-lg flex justify-between items-center">
                    <div>
                        <p className="font-semibold text-orange-300">{concept.name} ({concept.type})</p>
                        <p className="text-xs text-gray-400 truncate w-64 md:w-96" title={concept.description}>{concept.description}</p>
                    </div>
                    <div className="flex gap-2">
                        <button onClick={() => handleEditConcept(concept)} className="p-2 bg-blue-600 rounded"><WrenchIcon className="w-4 h-4" /></button>
                        <button onClick={() => handleDeleteConcept(concept.id)} className="p-2 bg-red-600 rounded"><TrashIcon className="w-4 h-4" /></button>
                    </div>
                </div>
            ))}
        </div>
    );

    const renderEventsTab = () => (
        <div className="space-y-2">
            {!currentEvent && <button onClick={handleAddNewEvent} className="w-full mb-2 py-2 bg-green-700 hover:bg-green-600 rounded-lg flex items-center justify-center gap-2"><PlusIcon /> Thêm Sự Kiện Mới</button>}
            {currentEvent && renderEventEditor()}
            {(worldKnowledge.events || []).map(event => (
                <div key={event.id} className="bg-gray-700 p-3 rounded-lg flex justify-between items-center">
                    <div>
                        <p className="font-semibold text-red-300">{event.name}</p>
                        <p className="text-xs text-gray-400 truncate w-64 md:w-96" title={event.description}>{event.description}</p>
                    </div>
                    <div className="flex gap-2">
                        <button onClick={() => handleEditEvent(event)} className="p-2 bg-blue-600 rounded"><WrenchIcon className="w-4 h-4" /></button>
                        <button onClick={() => handleDeleteEvent(event.id)} className="p-2 bg-red-600 rounded"><TrashIcon className="w-4 h-4" /></button>
                    </div>
                </div>
            ))}
        </div>
    );
// *** KẾT THÚC KHỐI CODE LỚN CẦN THÊM ***

// *** BẮT ĐẦU ĐOẠN CODE CẦN THÊM ***
    const renderNpcsTab = () => (
        <div className="space-y-2">
            {!currentNpc && <button onClick={handleAddNewNpc} className="w-full mb-2 py-2 bg-green-700 hover:bg-green-600 rounded-lg flex items-center justify-center gap-2"><PlusIcon /> Thêm NPC Cốt Lõi</button>}
            {currentNpc && renderNpcEditor()}
            {(worldKnowledge.npcs || []).map(npc => (
                <div key={npc.id} className="bg-gray-700 p-3 rounded-lg flex justify-between items-center">
                    <div>
                        <p className="font-semibold text-teal-300">{npc.name}</p>
                        <p className="text-xs text-gray-400 truncate w-64 md:w-96" title={npc.description}>{npc.description}</p>
                    </div>
                    <div className="flex gap-2">
                        <button onClick={() => handleEditNpc(npc)} className="p-2 bg-blue-600 rounded"><WrenchIcon className="w-4 h-4" /></button>
                        <button onClick={() => handleDeleteNpc(npc.id)} className="p-2 bg-red-600 rounded"><TrashIcon className="w-4 h-4" /></button>
                    </div>
                </div>
            ))}
        </div>
    );
// *** KẾT THÚC ĐOẠN CODE CẦN THÊM ***


    return (
        <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center p-4 z-[100] animate-fade-in-up">
            <div className="bg-gradient-to-br from-gray-900 to-gray-800 p-6 rounded-2xl shadow-2xl w-full max-w-4xl border border-purple-700/60 flex flex-col max-h-[90vh]">
                <div className="flex justify-between items-center mb-4">
                    <h2 className="text-2xl font-bold text-purple-400 flex items-center"><GlobeAltIcon /> Trình Chỉnh Sửa Thế Giới</h2>
                    <div className="flex items-center gap-4">
                        <button onClick={onSaveWorldKnowledge} className="py-2 px-4 bg-green-600 hover:bg-green-700 rounded-lg text-sm font-semibold flex items-center gap-2">
                            <SaveIcon /> Lưu Thế Giới
                        </button>
                        <button onClick={onClose} className="text-gray-400 hover:text-white text-3xl font-semibold">&times;</button>
                    </div>
                </div>
                <div className="flex border-b border-gray-700 mb-4">
                    <TabButton label="Vật Phẩm" isActive={activeTab === 'items'} onClick={() => setActiveTab('items')} />
                    <TabButton label="Kỹ Năng" isActive={activeTab === 'skills'} onClick={() => setActiveTab('skills')} />
                    <TabButton label="Hệ Thống Tu Luyện" isActive={activeTab === 'cultivationSystems'} onClick={() => setActiveTab('cultivationSystems')} />
                    <TabButton label="Chủng Tộc" isActive={activeTab === 'races'} onClick={() => setActiveTab('races')} />
                    <TabButton label="Địa Điểm" isActive={activeTab === 'locations'} onClick={() => setActiveTab('locations')} />
                    <TabButton label="Khái Niệm" isActive={activeTab === 'concepts'} onClick={() => setActiveTab('concepts')} />
                    <TabButton label="Sự Kiện" isActive={activeTab === 'events'} onClick={() => setActiveTab('events')} />
                    <TabButton label="NPCs" isActive={activeTab === 'npcs'} onClick={() => setActiveTab('npcs')} /> {/* *** THÊM MỚI *** */}
                </div>
                <div className="flex-grow overflow-y-auto pr-2 scrollbar-thin scrollbar-thumb-purple-500 scrollbar-track-gray-700">
                    {activeTab === 'items' && renderItemsTab()}
                    {activeTab === 'skills' && renderSkillsTab()}
                    {activeTab === 'cultivationSystems' && renderCultivationSystemsTab()}
                    {activeTab === 'races' && renderRacesTab()}
                    {activeTab === 'locations' && renderLocationsTab()}
                    {activeTab === 'concepts' && renderConceptsTab()}
                    {activeTab === 'events' && renderEventsTab()}
                    {activeTab === 'npcs' && renderNpcsTab()} {/* *** THÊM MỚI *** */}
                </div>
            </div>
        </div>
    );
};
// *** KẾT THÚC SỬA ĐỔI ***
// *** KẾT THÚC CODE MỚI VÀ SỬA ĐỔI ***



// Firebase Config
const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
  apiKey: "YOUR_FALLBACK_API_KEY", 
  authDomain: "YOUR_FALLBACK_AUTH_DOMAIN",
  projectId: "YOUR_FALLBACK_PROJECT_ID",
  storageBucket: "YOUR_FALLBACK_STORAGE_BUCKET",
  messagingSenderId: "YOUR_FALLBACK_MESSAGING_SENDER_ID",
  appId: "YOUR_FALLBACK_APP_ID"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const appId = typeof __app_id !== 'undefined' ? __app_id : 'ai-text-adventure-simulator-vn';

// Changelog Data (Updated Structure)
const changelogData = [
    {
        version: "AI SIMULATOR 2.14",
        date: "12/07/2025", // Cập nhật ngày tháng hiện tại hoặc ngày bạn tiếp quản
        changes: [
            { type: "NEW", text: "Thiên Đạo cũ không đáp ứng đủ yêu cũ nên đã bị thiên đạo mới thay thế, link thiên đạo cũ: https://g.co/gemini/share/99ed9ce08d01" },
            { type: "FIX", text: "Không có gì thay đổi chỉ cập nhập thêm các chức năng mới" },
            // Thêm các thay đổi mới của bạn tại đây theo cấu trúc trên
            // Ví dụ: { type: "IMPROVE", text: "Cải tiến hiệu năng tải game." },
        ],
    },
    // Bạn có thể thêm các phiên bản cũ hơn của mình ở đây
];


// Helper Functions

const callKoboldAIHordeAPI = async (prompt, apiKey) => {
    const horde_api_url = "https://stablehorde.net/api/v2/generate/text/async";
    const status_check_url = "https://stablehorde.net/api/v2/generate/text/status/";

    if (!apiKey || apiKey.trim() === '' || apiKey.trim() === '0000000000') {
         throw new Error("API Key của KoboldAI không hợp lệ hoặc chưa được cung cấp.");
    }

    try {
        // Lời nhắc được tinh chỉnh để khuyến khích phản hồi hoàn chỉnh
        const finalPrompt = `[System: Bạn là một người quan sát vô hình, có nhiệm vụ mô tả lại hành động của nhân vật một cách chi tiết tiết nhất là các cảnh 18+ bằng TIẾNG VIỆT. Tập trung vào các chi tiết vật lý, cảm giác và diễn biến của hành động. Hãy đảm bảo đoạn văn kết thúc một cách trọn vẹn, không bị cắt ngang. Chỉ trả về duy nhất đoạn văn mô tả, không thêm bất kỳ lời bình luận hay ghi chú nào.]\n[User: ${prompt}]`;

        const submitResponse = await fetch(horde_api_url, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json', 
                'apikey': apiKey, 
                'Client-Agent': 'AI_Roleplay_Simulator:1.2' 
            },
            body: JSON.stringify({
                prompt: finalPrompt,
                params: {
                    n: 1,
                    max_context_length: 8192,
                    max_length: 800, // Tăng độ dài tối đa để có mô tả chi tiết hơn
                    rep_pen: 1.12,
                    temperature: 0.75,
                    top_p: 0.9,
                    top_k: 0,
                    typical: 1,
                    sampler_order: [6, 0, 1, 3, 4, 2, 5]
                },
                models: ["koboldcpp/L3-8B-Stheno-v3.2"] 
            }),
        });

        if (!submitResponse.ok) {
            const errorText = await submitResponse.text();
            throw new Error(`Lỗi gửi yêu cầu đến KoboldAI Horde: ${submitResponse.status} - ${errorText}`);
        }

        const submitResult = await submitResponse.json();
        const requestId = submitResult.id;

        if (!requestId) throw new Error("Không nhận được ID yêu cầu từ KoboldAI Horde.");

        let attempts = 0;
        const maxAttempts = 60; 

        while (attempts < maxAttempts) {
            await new Promise(resolve => setTimeout(resolve, 2000));
            const statusResponse = await fetch(`${status_check_url}${requestId}`);
            if (!statusResponse.ok) {
                console.warn(`Lỗi khi kiểm tra trạng thái KoboldAI: ${statusResponse.status}`);
                attempts++;
                continue; 
            }
            const statusResult = await statusResponse.json();
            if (statusResult.done) {
                if (statusResult.generations && statusResult.generations.length > 0) {
                     return statusResult.generations[0].text.trim();
                } else {
                     throw new Error("KoboldAI Horde đã hoàn thành nhưng không trả về nội dung.");
                }
            }
            attempts++;
        }
        throw new Error("KoboldAI Horde mất quá nhiều thời gian để phản hồi.");
    } catch (error) {
        console.error("Lỗi khi gọi KoboldAI Horde:", error);
        throw error;
    }
};
function parseKeyValueString(kvString) {
    const result = {};
    
    // ===== BƯỚC 1: CHUẨN HÓA DẤU NGOẶC KÉP =====
    // Chuyển đổi các dấu ngoặc kép thông minh (smart quotes) thành dấu ngoặc kép chuẩn
    // - " (left double quotation mark - U+201C) → "
    // - " (right double quotation mark - U+201D) → "
    // Tính năng này hỗ trợ xử lý văn bản từ Word, Google Docs, hay các editor có typography tự động
    const normalizedKvString = kvString.replace(/[""]/g, '"');
    
    // ===== BƯỚC 2: ĐỊNH NGHĨA REGEX PARSER =====
    // Regex phức tạp để bắt các cặp key=value với nhiều định dạng khác nhau:
    // - ([\w\u00C0-\u017F\s]+): Bắt key (chữ cái, số, tiếng Việt có dấu, khoảng trắng)
    // - \s*=\s*: Bắt dấu = với khoảng trắng tùy chọn
    // - "([^"]*)": Bắt value trong dấu ngoặc kép
    // - '([^']*)': Bắt value trong dấu nháy đơn  
    // - ([\w\u00C0-\u017F\s\d.:\/+\-_%À-ỹ]+?(?=\s*,\s*[\w\u00C0-\u017F\s]+\s*=|$)): 
    //   Bắt value không có dấu nháy (dừng khi gặp key tiếp theo hoặc kết thúc chuỗi)
    const pairRegex = /([\w\u00C0-\u017F\s]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|([\w\u00C0-\u017F\s\d.:\/+\-_%À-ỹ]+?(?=\s*,\s*[\w\u00C0-\u017F\s]+\s*=|$)))/gu;
    
    // ===== BƯỚC 3: XỬ LÝ TỪNG CẶP KEY-VALUE =====
    let match;
    // Sử dụng chuỗi đã được chuẩn hóa để phân tích (thay vì kvString gốc)
    while ((match = pairRegex.exec(normalizedKvString)) !== null) {
        // Lấy key và loại bỏ khoảng trắng thừa
        const key = match[1].trim();
        
        // Lấy value theo thứ tự ưu tiên:
        // match[2]: value trong dấu ngoặc kép "value"
        // match[3]: value trong dấu nháy đơn 'value'  
        // match[4]: value không có dấu nháy value
        let value = match[2] || match[3] || match[4];
        
        // ===== BƯỚC 4: XỬ LÝ VÀ CHUYỂN ĐỔI KIỂU DỮ LIỆU =====
        if (value !== undefined) {
            const trimmedValue = value.trim();
            
            // Chuyển đổi boolean: 'true'/'false' (không phân biệt hoa thường)
            if (trimmedValue.toLowerCase() === 'true') {
                result[key] = true;
            } else if (trimmedValue.toLowerCase() === 'false') {
                result[key] = false;
            } 
            // Chuyển đổi số: kiểm tra định dạng số nguyên hoặc thập phân
            // Regex ^\d+(\.\d+)?$ bắt: 123, 12.5, 0.25, etc.
            else if (/^\d+(\.\d+)?$/.test(trimmedValue) && !isNaN(parseFloat(trimmedValue))) {
                result[key] = parseFloat(trimmedValue);
            } 
            // Giữ nguyên dạng string cho các giá trị khác
            else {
                result[key] = trimmedValue;
            }
        }
    }
    
    // ===== BƯỚC 5: TRẢ VỀ KỂT QUẢ =====
    return result;
}

const PLAYER_PERSONALITIES = [
    'Để AI quyết định',
    // Positive / Neutral Traits
    "Dũng Cảm, Bộc Trực", "Thận Trọng, Đa Nghi", "Lạnh Lùng, Ít Nói", "Hài Hước, Thích Trêu Chọc",
    "Nhân Hậu, Vị Tha", "Trầm Tính, Thích Quan Sát", "Nhút Nhát, Hay Lo Sợ", "Tò Mò, Thích Khám Phá",
    "Trung Thành, Đáng Tin Cậy", "Lãng Mạn, Mơ Mộng", "Thực Dụng, Coi Trọng Lợi Ích", "Chính Trực, Ghét Sự Giả Dối",
    "Hoài Nghi, Luôn Đặt Câu Hỏi", "Lạc Quan, Luôn Nhìn Về Phía Trước", "Lý Trí, Giỏi Phân Tích",
    "Nghệ Sĩ, Tâm Hồn Bay Bổng", "Thích Phiêu Lưu, Không Ngại Mạo Hiểm", "Cẩn Thận Từng Chi Tiết, Cầu Toàn",
    "Hào Sảng, Thích Giúp Đỡ Người Khác", "Kiên Định, Không Dễ Bỏ Cuộc", "Khiêm Tốn, Không Khoe Khoang",
    "Sáng Tạo, Nhiều Ý Tưởng Độc Đáo",
    // Negative / Complex Traits
    "Mưu Mẹo, Gian Xảo", "Tham Lam, Ích Kỷ", "Khó Lường, Bí Ẩn", "Nóng Nảy, Liều Lĩnh",
    "Kiêu Ngạo, Tự Phụ", "Đa Sầu Đa Cảm, Dễ Tổn Thương", "Cố Chấp, Bảo Thủ", "Lười Biếng, Thích Hưởng Thụ",
    "Ghen Tị, Hay So Sánh", "Thù Dai, Khó Tha Thứ", "Ba Phải, Không Có Chính Kiến"
];
const WRITING_STYLES = [
    'Tiên hiệp', 'Huyền huyễn', 'Khoa huyễn', 'Đô thị', 'Lịch sử', 'Kiếm hiệp', 'Hài hước', 'Kinh dị', 'Võng Du', 'Vô Hạn Lưu', 'Xuyên Không', 'Trùng Sinh', 'Hài Hước', 'Kỳ Ảo', 'Sử Thi', 'Trinh Thám', 'Mạt Thế', 'Chư Thiên Vạn Giới',
];

const NARRATOR_PRONOUNS = [
    'Để AI quyết định',
    'Ngươi - Ta (Cổ trang/Kiếm hiệp)',
    'Bạn - Tôi (Hiện đại/Thân thiện)',
    'Cậu - Tớ (Học đường/Trẻ trung)',
    'Ngài - Kẻ hèn này (Trang trọng/Cung đình)'
];

const TABS = {
    WORLD: 'Thế Giới',
    CHARACTER: 'Nhân Vật Chính',
    ENTITIES: 'Thực Thể',
};
const SKILL_TYPES = [
    'Chủ động', 'Bị động', 'Nội tại', 'Thiên phú', 
    'Tuyệt kỹ', 'Thần thông', 'Pháp thuật', 'Võ kỹ', 'Sinh hoạt'
];
const ITEM_TYPES = [
    'Khác', 'Vũ khí', 'Pháp bảo', 'Giáp trụ', 'Đan dược', 'Linh thảo',
    'Công pháp', 'Tín vật', 'Tạp vật', 'Nguyên liệu'
];

const NPC_TYPES = [
    { value: 'Character', label: 'Nhân vật Cốt truyện' },
    { value: 'Monster', label: 'Quái vật/Kẻ địch' },
    { value: 'Populace', label: 'Dân thường/Quần chúng' },
];

// --- Helper Components ---
const TabButton = ({ label, isActive, onClick }) => (
    <button onClick={onClick} className={`px-4 py-2 text-sm font-medium rounded-md transition-colors duration-200 ${isActive ? 'bg-purple-600 text-white shadow' : 'text-gray-300 hover:bg-gray-700'}`}>
        {label}
    </button>
);

const FormRow = ({ label, children }) => (
    <div className="flex flex-col sm:flex-row sm:items-start sm:gap-4 py-4 border-b border-gray-700">
        <label className="w-full sm:w-1/4 text-gray-300 font-medium mb-2 sm:mb-0 pt-2">{label}:</label>
        <div className="w-full sm:w-3/4">{children}</div>
    </div>
);

const AiButton = ({ onClick, disabled, children, isGenerating }) => (
    <button type="button" onClick={onClick} disabled={disabled || isGenerating} className="flex items-center justify-center gap-1 px-3 py-1.5 text-xs font-semibold text-gray-200 bg-gray-600 hover:bg-purple-700 rounded-md transition-colors disabled:bg-gray-500 disabled:cursor-not-allowed">
        {isGenerating ? (<div className="w-4 h-4 border-2 border-t-transparent border-white rounded-full animate-spin"></div>) : (<SparklesIcon />)}
        {children}
    </button>
);
// UI Component Definitions
const InitialScreen = (props) => (
    <>
    {/*
      Container chính sử dụng Grid để chồng các lớp lên nhau.
      Đây là cách tiếp cận đáng tin cậy hơn.
    */}
    <div className="grid grid-cols-1 grid-rows-1 min-h-screen w-full bg-gray-200">
        {/* Lớp 1: Nền hiệu ứng hạt, chiếm toàn bộ không gian grid */}
        <div style={{ gridColumn: '1 / -1', gridRow: '1 / -1' }}>
            <ParticleBackground />
        </div>

        {/*
          Lớp 2: Nội dung chính, cũng chiếm toàn bộ không gian grid.
          'pointer-events-none' cho phép sự kiện chuột đi xuyên qua nó.
          'z-10' để đảm bảo nó hiển thị trên canvas.
        */}
        <div 
            className="flex flex-col items-center justify-center min-h-screen p-6 z-10 pointer-events-none"
            style={{ gridColumn: '1 / -1', gridRow: '1 / -1' }}
        >
      <h1 className="text-5xl font-bold text-transparent mb-12 text-center animate-wave-sweep">
                    AI SIMULATOR 2.14
            </h1>
            {/*
              Container cho các nút bấm.
              Quan trọng: 'pointer-events-auto' được đặt ở đây để các nút
              CÓ THỂ nhận lại sự kiện chuột.
            */}
            <div className="space-y-4 w-full max-w-md pointer-events-auto">
                <button
                    onClick={() => props.setCurrentScreen('setup')}
                    className="w-full flex items-center justify-center bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 text-white font-bold py-4 px-6 rounded-xl shadow-xl hover:shadow-2xl transition-all transform hover:scale-105 text-xl focus:outline-none focus:ring-4 focus:ring-pink-400 focus:ring-opacity-50"
                >
                    <PlayIcon /> Bắt Đầu Cuộc Phiêu Lưu Mới
                </button>
                <button
                    onClick={() => props.setShowLoadGameModal(true)}
                    disabled={props.savedGames.length === 0}
                    className="w-full flex items-center justify-center bg-gradient-to-r from-sky-500 to-cyan-500 hover:from-sky-600 hover:to-cyan-600 text-white font-semibold py-3 px-6 rounded-xl shadow-lg hover:shadow-xl transition-all transform hover:scale-105 text-lg disabled:from-gray-500 disabled:to-gray-600 disabled:cursor-not-allowed focus:outline-none focus:ring-4 focus:ring-cyan-400 focus:ring-opacity-50"
                >
                    <SaveIcon /> Tải Game Đã Lưu ({props.savedGames.length})
                </button>
                <button
                    onClick={() => props.fileInputRef.current && props.fileInputRef.current.click()}
                    className="w-full flex items-center justify-center bg-gradient-to-r from-sky-500 to-cyan-500 hover:from-sky-600 hover:to-cyan-600 text-white font-semibold py-3 px-6 rounded-xl shadow-lg hover:shadow-xl transition-all transform hover:scale-105 text-lg disabled:from-gray-500 disabled:to-gray-600 disabled:cursor-not-allowed focus:outline-none focus:ring-4 focus:ring-cyan-400 focus:ring-opacity-50"
                >
                    <Upload /> Tải Game Từ Tệp
                </button>
                <button
                    onClick={() => props.setShowUpdateLogModal(true)}
                    className="w-full flex items-center justify-center bg-gradient-to-r from-green-500 to-teal-500 hover:from-green-600 hover:to-teal-600 text-white font-semibold py-3 px-6 rounded-xl shadow-lg hover:shadow-xl transition-all transform hover:scale-105 text-lg focus:outline-none focus:ring-4 focus:ring-teal-400 focus:ring-opacity-50"
                >
                    <MegaphoneIcon /> Xem Cập Nhật Game
                </button>
                <button
                    onClick={() => { props.setInputApiKey(props.apiMode === 'userKey' ? props.apiKey : ''); props.setShowApiModal(true);}}
                    className="w-full flex items-center justify-center bg-gray-700 hover:bg-gray-600 text-white font-semibold py-3 px-6 rounded-xl shadow-md hover:shadow-lg transition-all transform hover:scale-105 text-lg focus:outline-none focus:ring-4 focus:ring-gray-500 focus:ring-opacity-50"
                >
                    <CogIcon /> Thiết Lập API Key
                </button>
            </div>
            <p className={`mt-6 text-sm ${props.apiKeyStatus.color}`}>{props.apiKeyStatus.status}: {props.apiKeyStatus.message}</p>
            {props.userId && <p className="mt-1 text-xs text-gray-400">UserID: {props.userId}</p>}
        </div>
    </div>
    <input type="file" ref={props.fileInputRef} onChange={props.handleLoadGame} accept=".json" className="hidden" />
    </>
);
const UpdateLogModal = ({ show, onClose, changelog }) => {
    if (!show) return null;

    const getChangeTag = (type) => {
        const baseClasses = "text-xs font-bold px-2.5 py-1 rounded-full flex-shrink-0 flex items-center gap-1.5 tracking-wider";
        switch (type) {
            case 'NEW':
                return <span className={`${baseClasses} bg-green-500/20 text-green-300`}><PlusIcon className="w-3 h-3"/> MỚI</span>;
            case 'FIX':
                return <span className={`${baseClasses} bg-orange-500/20 text-orange-300`}><WrenchIcon className="w-3 h-3"/> SỬA LỖI</span>;
            case 'IMPROVE':
                return <span className={`${baseClasses} bg-sky-500/20 text-sky-300`}><ArrowUpCircleIcon className="w-3 h-3"/> CẢI TIẾN</span>;
            case 'UI':
                 return <span className={`${baseClasses} bg-purple-500/20 text-purple-300`}><PaintBrushIcon className="w-3 h-3"/> GIAO DIỆN</span>;
            case 'AI':
                return <span className={`${baseClasses} bg-pink-500/20 text-pink-300`}><SparklesIcon className="w-3 h-3"/> AI</span>;
            default:
                return <span className={`${baseClasses} bg-gray-500/20 text-gray-300`}>{type.toUpperCase()}</span>;
        }
    };

    return (
        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-[110]">
            <div className="bg-gradient-to-br from-gray-900 to-gray-800 p-6 rounded-2xl shadow-2xl w-full max-w-2xl max-h-[85vh] flex flex-col border border-teal-700/50">
                <div className="flex items-center mb-6">
                    <MegaphoneIcon className="text-teal-400 w-8 h-8 mr-3"/>
                    <h2 className="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-teal-300 to-green-400">Nhật Ký Cập Nhật</h2>
                </div>
                <div className="overflow-y-auto flex-grow pr-3 scrollbar-thin scrollbar-thumb-teal-500 scrollbar-track-gray-700 space-y-8">
                    {changelog.map((log, index) => (
                        <div key={index} className="relative pl-8">
                            {/* Timeline line */}
                            <div className="absolute left-3 top-2 bottom-0 w-0.5 bg-gray-600"></div>
                            {/* Timeline dot */}
                            <div className="absolute left-0 top-1 w-6 h-6 bg-gray-700 rounded-full border-4 border-gray-900 flex items-center justify-center">
                                <div className="w-2 h-2 bg-teal-400 rounded-full"></div>
                            </div>
                            
                            <div className="bg-gray-800/60 p-4 rounded-lg shadow-lg border border-gray-700/80">
                                <h3 className="text-xl font-bold text-teal-300">{log.version}</h3>
                                <p className="text-xs text-gray-500 mb-4">{log.date}</p>
                                <ul className="space-y-2.5 text-sm text-gray-300">
                                    {log.changes.map((change, cIndex) => (
                                        <li key={cIndex} className="flex items-start gap-3">
                                            {getChangeTag(change.type)}
                                            <span className="flex-1 leading-relaxed">{change.text}</span>
                                        </li>
                                    ))}
                                </ul>
                            </div>
                        </div>
                    ))}
                </div>
                <button
                    onClick={onClose}
                    className="mt-6 w-full bg-gradient-to-r from-teal-600 to-green-600 hover:from-teal-700 hover:to-green-700 text-white font-bold py-3 px-4 rounded-lg shadow-lg hover:shadow-xl transition-all"
                >
                    Đã Hiểu
                </button>
            </div>
        </div>
    );
};


const ApiSetupModal = ({
    inputApiKey, setInputApiKey, apiKeyStatus, saveApiKey, testApiKey,
    isLoading, setShowApiModal, apiKey, setApiKeyStatus, apiMode, setApiMode,
    setModalMessage, koboldApiKey, setKoboldApiKey, useKoboldIntegration, setUseKoboldIntegration,
    saveKoboldApiKey 
}) => {
    const handleUseDefaultGemini = () => {
        setApiMode('defaultGemini');
        setInputApiKey('');
        setApiKeyStatus({
            status: 'Đang dùng Gemini AI Mặc Định',
            message: 'Không cần API Key. Nội dung sẽ được tạo bởi AI của nền tảng.',
            color: 'text-sky-400'
        });
        setModalMessage({show: true, title: "Chế Độ AI Mặc Định", content: "Đã chuyển sang sử dụng Gemini AI mặc định. Ngươi không cần cung cấp API Key.", type: "success"});
    };

    // *** HÀM MỚI ĐỂ KIỂM TRA TRƯỚC KHI ĐÓNG ***
    const handleAttemptClose = () => {
        // Kiểm tra xem tích hợp Kobold có đang bật hay không
        if (useKoboldIntegration) {
            // Nếu bật, kiểm tra xem API Key của Kobold đã được nhập chưa
            if (!koboldApiKey || koboldApiKey.trim() === '') {
                // Nếu chưa nhập, hiển thị thông báo lỗi và không cho đóng
                setModalMessage({
                    show: true,
                    title: 'Yêu Cầu Bắt Buộc',
                    content: 'Ngươi đã bật tích hợp KoboldAI, do đó ngươi PHẢI nhập và lưu API Key trước khi đóng cửa sổ này.',
                    type: 'error'
                });
                return; // Ngăn không cho đóng cửa sổ
            }
        }
        // Nếu mọi điều kiện đều ổn, đóng cửa sổ
        setShowApiModal(false);
    };

    return (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-[110]">
      <div className="bg-gray-800 p-8 rounded-xl shadow-2xl w-full max-w-lg transform transition-all border border-purple-800">
        <h2 className="text-3xl font-semibold text-purple-400 mb-6">Thiết Lập Nguồn AI</h2>

        {/* Gemini Section */}
        <fieldset className="border border-gray-600 p-4 rounded-lg mb-6">
            <legend className="text-lg font-semibold text-sky-400 px-2">Nguồn AI Chính (Gemini)</legend>
            <div className="mt-2 space-y-3">
                <button
                    onClick={handleUseDefaultGemini}
                    className={`w-full flex items-center justify-center font-semibold py-3 px-4 rounded-lg shadow-md transition-colors
                                ${apiMode === 'defaultGemini' ? 'bg-sky-600 hover:bg-sky-700 text-white ring-2 ring-sky-400' : 'bg-gray-600 hover:bg-gray-500 text-gray-300'}`}
                >
                    <SparklesIcon className="w-5 h-5 mr-2"/> Sử Dụng Gemini AI Mặc Định (Đề xuất)
                </button>
                <div>
                    <label htmlFor="apiKeyInputModal" className={`block text-sm font-medium mb-1 ${apiMode === 'userKey' ? 'text-gray-300' : 'text-gray-500'}`}>
                        Hoặc Sử Dụng API Key Gemini Của Ngươi:
                    </label>
                    <input
                        type="password" id="apiKeyInputModal" name="apiKeyInputModalName" autoComplete="new-password"
                        value={inputApiKey}
                        onChange={(e) => {
                            setInputApiKey(e.target.value);
                            if (apiMode !== 'userKey' && e.target.value.trim() !== '') {
                                setApiMode('userKey');
                                setApiKeyStatus({ status: 'Chưa cấu hình', message: 'Nhập API Key của bạn.', color: 'text-yellow-500' });
                            }
                        }}
                        placeholder="Nhập API Key Gemini của ngươi"
                        className={`w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white focus:ring-purple-500 focus:border-purple-500 ${apiMode !== 'userKey' ? 'opacity-50 cursor-not-allowed' : ''}`}
                        disabled={apiMode !== 'userKey'}
                    />
                </div>
                 {apiMode === 'userKey' && (
                    <>
                        <div className={`my-2 text-sm ${apiKeyStatus.color}`}>{apiKeyStatus.status}: {apiKeyStatus.message}</div>
                        <div className="flex space-x-3">
                        <button onClick={saveApiKey} disabled={isLoading || !inputApiKey} className="flex-1 flex items-center justify-center bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-3 rounded-lg disabled:bg-gray-500">
                            <SaveIcon /> Lưu Key Gemini
                        </button>
                        <button onClick={testApiKey} disabled={isLoading || !inputApiKey} className="flex-1 flex items-center justify-center bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-3 rounded-lg disabled:bg-gray-500">
                            <CheckIcon /> Kiểm Tra
                        </button>
                        </div>
                    </>
                )}
            </div>
        </fieldset>

        {/* KoboldAI Horde Section (Updated) */}
        <fieldset className="border border-red-600/70 p-4 rounded-lg bg-red-900/10">
            <legend className="text-lg font-semibold text-red-400 px-2">AI Hỗ Trợ (KoboldAI Horde)</legend>
            <div className="mt-2 space-y-3">
                 <div className="flex items-center">
                    <input
                        type="checkbox" id="useKobold" checked={useKoboldIntegration}
                        onChange={(e) => setUseKoboldIntegration(e.target.checked)}
                        className="h-5 w-5 text-red-500 bg-gray-600 border-gray-500 rounded focus:ring-red-600"
                    />
                    <label htmlFor="useKobold" className="ml-2 text-sm font-medium text-gray-300">Bật tích hợp KoboldAI cho cảnh NSFW chi tiết</label>
                </div>
                <div>
                    <label htmlFor="koboldApiKeyInput" className="block text-sm font-medium text-gray-300 mb-1">
                        KoboldAI Horde API Key <span className="text-red-400 font-semibold">(Bắt buộc nếu bật)</span>:
                    </label>
                    <input
                        type="password" id="koboldApiKeyInput" value={koboldApiKey}
                        onChange={(e) => setKoboldApiKey(e.target.value)}
                        placeholder="Nhập API Key KoboldAI Horde của ngươi"
                        className="w-full p-3 bg-gray-700 border border-gray-600 rounded-lg text-white focus:ring-red-500 focus:border-red-500"
                        disabled={!useKoboldIntegration}
                    />
                     <p className="text-xs text-gray-400 mt-1 italic">
                        Đăng ký tại <a href="https://stablehorde.net/register" target="_blank" rel="noopener noreferrer" className="text-sky-400 underline hover:text-sky-300">stablehorde.net/register</a>.
                     </p>
                </div>
                <button 
                    onClick={() => saveKoboldApiKey(koboldApiKey)} 
                    disabled={isLoading || !useKoboldIntegration || !koboldApiKey} 
                    className="w-full flex items-center justify-center bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-3 rounded-lg disabled:bg-gray-500 disabled:cursor-not-allowed">
                      Lưu Key KoboldAI
                </button>
            </div>
        </fieldset>

        <button
            onClick={handleAttemptClose} // SỬ DỤNG HÀM KIỂM TRA MỚI
            className="mt-6 w-full bg-gray-600 hover:bg-gray-500 text-white font-semibold py-2.5 px-4 rounded-lg shadow-md transition-colors"
        >
            Đóng
        </button>
      </div>
    </div>
  );
};
// *** BẮT ĐẦU SỬA ĐỔI: Cung cấp đầy đủ code cho GameSetupScreen để sửa lỗi ***
// *** BẮT ĐẦU SỬA ĐỔI: Cung cấp đầy đủ code cho GameSetupScreen để sửa lỗi ***
const GameSetupScreen = ({
    goHome, gameSettings, handleInputChange, isLoading,
    handleGenerate,
    isGenerating,
    activeTab,
    setActiveTab,
    addInitialWorldElement, removeInitialWorldElement, handleInitialElementChange, handleGenerateInitialElementDescription,
    isGeneratingInitialElementDesc, handleGenerateGoal, isGeneratingGoal,
    handleGenerateCharacterName, isGeneratingCharacterName,
    handleGenerateInitialSkill, isGeneratingInitialSkill,
    addInitialTrait, removeInitialTrait, handleInitialTraitChange,
    worldKnowledge // Prop này là bắt buộc
}) => {

    // --- Thêm hàm initializeGame mới, sử dụng worldKnowledge trong prompt ---
    const initializeGame = async () => {
        // ...existing validation code...

        const prompt = `
            // ...existing prompt content...

            KIẾN THỨC HIỆN CÓ VỀ THẾ GIỚI (ĐƯỢC TÍCH HỢP TỪ WORLD EDITOR):
            ** CHỈ TRONG KHỞI TẠO GAME - Hiển thị đầy đủ thông tin để AI có thể nắm bắt toàn bộ thế giới **
            Dữ liệu này đã được người chơi xây dựng và lưu trữ trước đó. Ngươi PHẢI sử dụng các thông tin này trước khi tạo ra bất kỳ thực thể mới nào:
            
            * Chủng tộc đã có: ${(worldKnowledge.races || []).map(r => `${r.name} (${r.description})`).join(', ') || "Chưa có"}
            * Địa điểm đã có: ${(worldKnowledge.locations || []).map(l => `${l.name} (${l.description})`).join(', ') || "Chưa có"}  
            * Vật phẩm đã có: ${(worldKnowledge.items || []).map(i => `${i.name} (${i.description})`).join(', ') || "Chưa có"}
            * Kỹ năng đã có: ${(worldKnowledge.skills || []).map(s => `${s.name} (${s.description})`).join(', ') || "Chưa có"}
            * Khái niệm đã có: ${(worldKnowledge.concepts || []).map(c => `${c.name} (${c.description})`).join(', ') || "Chưa có"}
            * Sự kiện đã có: ${(worldKnowledge.events || []).map(e => `${e.name} (${e.description})`).join(', ') || "Chưa có"}
            * NPCs đã có: ${(worldKnowledge.npcs || []).map(n => `${n.name} (${n.description})`).join(', ') || "Chưa có"}
            
            QUY TẮC ƯU TIÊN SỬ DỤNG KIẾN THỨC HIỆN CÓ:
            - Khi tạo câu chuyện, ngươi PHẢI ưu tiên sử dụng các entities đã có trong World Editor
            - TRƯỚC KHI tạo địa điểm/vật phẩm/nhân vật mới, hãy KIỂM TRA danh sách trên xem đã có gì phù hợp chưa
            - Nếu ĐÃ CÓ entity phù hợp, hãy sử dụng thẻ LORE_* để tham chiếu với TÊN CHÍNH XÁC:
              + [LORE_LOCATION: name="tên chính xác từ danh sách trên"]
              + [LORE_ITEM: name="tên chính xác từ danh sách trên"] 
              + [LORE_NPC: name="tên chính xác từ danh sách trên"]
              + [LORE_SKILL: name="tên chính xác từ danh sách trên"]
              + [LORE_CONCEPT: name="tên chính xác từ danh sách trên"]
              + [LORE_EVENT: name="tên chính xác từ danh sách trên"]
              + [LORE_RACE: name="tên chính xác từ danh sách trên"]
            - CHỈ KHI KHÔNG CÓ GÌ PHÙ HỢP mới được dùng thẻ DEFINE_* để tạo mới
            - LƯU Ý QUAN TRỌNG: Tên trong thẻ LORE_* phải KHỚP CHÍNH XÁC với tên trong danh sách (có thể khác chữ hoa/thường nhưng phải đúng từng ký tự)
            - Mọi thông tin mới tạo ra bằng DEFINE_* sẽ được tự động lưu vào World Editor để tái sử dụng cho các lần sau

            // ...rest of existing prompt...
        `;

        // ...rest of initializeGame logic...
    };

    const renderWorldTab = () => (
        <div className="space-y-2">
            <h3 className="text-xl font-bold text-gray-200 mb-4">1. Thiết Lập Thế Giới</h3>
            <FormRow label="Chủ đề">
                <div className="flex items-center gap-2">
                    <input type="text" name="theme" value={gameSettings.theme} onChange={handleInputChange} className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md focus:ring-purple-500 focus:border-purple-500" />
                    <AiButton onClick={() => handleGenerate('theme')} isGenerating={isGenerating.theme}>Tạo AI</AiButton>
                </div>
            </FormRow>
            <FormRow label="Bối cảnh">
                <textarea name="setting" value={gameSettings.setting} onChange={handleInputChange} rows="3" placeholder="Mô tả chi tiết về bối cảnh thế giới..." className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md focus:ring-purple-500 focus:border-purple-500" />
                <div className="flex justify-end mt-1">
                    <AiButton onClick={() => handleGenerate('setting')} isGenerating={isGenerating.setting}>Tạo AI</AiButton>
                </div>
            </FormRow>
            <FormRow label="Phong cách/Giọng văn">
                <div className="flex items-center gap-2">
                    <select name="writingStyle" value={gameSettings.writingStyle} onChange={handleInputChange} className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md focus:ring-purple-500 focus:border-purple-500">
                        {WRITING_STYLES.map(s => <option key={s} value={s}>{s}</option>)}
                    </select>
                </div>
            </FormRow>
            <FormRow label="Phong cách Xưng hô">
                <select name="narratorPronoun" value={gameSettings.narratorPronoun} onChange={handleInputChange} className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md focus:ring-purple-500 focus:border-purple-500">
                    {NARRATOR_PRONOUNS.map(s => <option key={s} value={s}>{s}</option>)}
                </select>
            </FormRow>
            <FormRow label="Độ khó">
                <select name="difficulty" value={gameSettings.difficulty} onChange={handleInputChange} className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md focus:ring-purple-500 focus:border-purple-500">
                    <option value="Dễ">Dễ - Dành cho người mới, ít thử thách</option>
                    <option value="Thường">Thường - Cân bằng, phù hợp đa số</option>
                    <option value="Khó">Khó - Thử thách cao, cần tính toán</option>
                    <option value="Ác Mộng">Ác Mộng - Cực kỳ khó, không khoan nhượng</option>
                    <option value="Tuỳ Chỉnh AI">Tuỳ Chỉnh AI - Để AI mô tả độ khó</option>
                </select>
                {(gameSettings.difficulty === "Tuỳ Chỉnh AI" || gameSettings.difficultyDescription) && (
                    <div>
                        <label htmlFor="difficultyDescription" className="block text-lg font-medium text-gray-300 mb-1">Mô Tả Độ Khó (AI hoặc Tự Điền):</label>
                        <div className="flex items-center gap-2">
                            <textarea name="difficultyDescription" id="difficultyDescription" value={gameSettings.difficultyDescription} onChange={handleInputChange} rows="2" placeholder="AI sẽ mô tả độ khó ở đây..." className="w-full p-3 bg-gray-600 border border-gray-500 rounded-lg focus:ring-teal-500 focus:border-teal-500" />
                            {gameSettings.difficulty === "Tuỳ Chỉnh AI" && (
                                <AiButton
                                    onClick={() => handleGenerate('difficultyDescription')}
                                    isGenerating={isGenerating.difficultyDescription}
                                >
                                    Tạo AI
                                </AiButton>
                            )}
                        </div>
                    </div>
                )}
            </FormRow>
            <FormRow label="Tên Đơn vị Tiền tệ">
                <div className="flex items-center gap-2">
                    <input
                        type="text"
                        name="currencyName"
                        value={gameSettings.currencyName}
                        onChange={handleInputChange}
                        className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md focus:ring-purple-500 focus:border-purple-500"
                        placeholder="VD: Linh thạch, Vàng, Credit..."
                    />
                    <AiButton onClick={() => handleGenerate('currencyName')} isGenerating={isGenerating.currencyName}>Tạo AI</AiButton>
                </div>
                <p className="text-xs text-gray-500 mt-1 italic">Tên gọi cho tiền tệ trong thế giới của ngươi.</p>
            </FormRow>

            <FormRow label="Nội dung NSFW">
                <div className="flex items-center h-full">
                    <input type="checkbox" name="allowNsfw" id="allowNsfw" checked={gameSettings.allowNsfw} onChange={handleInputChange} className="h-5 w-5 text-red-500 bg-gray-700 border-gray-600 rounded focus:ring-red-600" />
                    <label htmlFor="allowNsfw" className="ml-3 text-sm text-gray-300">Cho phép nội dung 18+ (Cảnh báo: Có thể chứa nội dung bạo lực, khiêu dâm chi tiết)</label>
                </div>
            </FormRow>
        </div>
    );

    const renderCharacterTab = () => (
        <div className="space-y-2">
            <h3 className="text-xl font-bold text-gray-200 mb-4">2. Thiết Lập Nhân Vật Chính</h3>
            <FormRow label="Danh Xưng/Tên">
                <div className="flex items-center gap-2">
                    <input type="text" name="characterName" value={gameSettings.characterName} onChange={handleInputChange} className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md focus:ring-purple-500 focus:border-purple-500" />
                    <AiButton onClick={() => handleGenerateCharacterName()} isGenerating={isGeneratingCharacterName}>Tạo AI</AiButton>
                </div>
            </FormRow>
            <FormRow label="Giới tính">
                <select name="characterGender" value={gameSettings.characterGender} onChange={handleInputChange} className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md focus:ring-purple-500 focus:border-purple-500">
                    <option value="Không xác định">Không xác định / Để AI quyết định</option>
                    <option value="Nam">Nam</option>
                    <option value="Nữ">Nữ</option>
                    <option value="Khác">Khác</option>
                </select>
            </FormRow>
            <FormRow label="Hệ Tu Luyện Ban Đầu">
                <select name="initialCultivationSystem" value={gameSettings.initialCultivationSystem} onChange={handleInputChange} className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md focus:ring-purple-500 focus:border-purple-500">
                    {worldKnowledge && worldKnowledge.cultivationSystems && worldKnowledge.cultivationSystems.length > 0 ? (
                        worldKnowledge.cultivationSystems.map(system => (
                            <option key={system.id} value={system.systemName}>{system.systemName}</option>
                        ))
                    ) : (
                        <option value="" disabled>Không có hệ thống tu luyện nào</option>
                    )}
                </select>
            </FormRow>
                        {/* *** BẮT ĐẦU CODE MỚI CHO VẤN ĐỀ 2 *** */}
            <FormRow label="Bậc Thiên Phú">
                <select name="initialTalentTier" value={gameSettings.initialTalentTier} onChange={handleInputChange} className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md focus:ring-purple-500 focus:border-purple-500">
                    {TALENT_TIERS.map(tier => (
                        <option key={tier.name} value={tier.name}>{tier.name}</option>
                    ))}
                </select>
            </FormRow>

            <FormRow label="Cảnh Giới & Cấp Độ">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label className="block text-xs font-medium text-gray-400 mb-1">Cảnh giới ban đầu</label>
                        <select name="initialRealm" value={gameSettings.initialRealm} onChange={handleInputChange} className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md focus:ring-purple-500 focus:border-purple-500">
                            {(worldKnowledge.cultivationSystems.find(s => s.systemName === gameSettings.initialCultivationSystem)?.realms || []).map(realm => (
                                <option key={realm} value={realm}>{realm}</option>
                            ))}
                        </select>
                    </div>
                    <div>
                        <label className="block text-xs font-medium text-gray-400 mb-1">Cấp độ ban đầu</label>
                        <input
                            type="number"
                            name="initialLevel"
                            value={gameSettings.initialLevel}
                            onChange={handleInputChange}
                            // Tính toán min/max level dựa trên cảnh giới đang chọn
                            min={((worldKnowledge.cultivationSystems.find(s => s.systemName === gameSettings.initialCultivationSystem)?.realms || []).indexOf(gameSettings.initialRealm) * 10) + 1}
                            max={((worldKnowledge.cultivationSystems.find(s => s.systemName === gameSettings.initialCultivationSystem)?.realms || []).indexOf(gameSettings.initialRealm) * 10) + 10}
                            className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md"
                        />
                    </div>
                </div>
            </FormRow>
            {/* *** KẾT THÚC CODE MỚI CHO VẤN ĐỀ 2 *** */}
            <FormRow label="Tính cách">
                <select name="characterPersonality" value={gameSettings.characterPersonality} onChange={handleInputChange} className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md focus:ring-purple-500 focus:border-purple-500">
                    {PLAYER_PERSONALITIES.map(p => <option key={p} value={p}>{p}</option>)}
                </select>
            </FormRow>
            <FormRow label="Tiểu sử/Đặc điểm">
                <textarea name="characterBackstory" value={gameSettings.characterBackstory} onChange={handleInputChange} rows="3" placeholder="Mô tả sơ lược về nhân vật..." className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md focus:ring-purple-500 focus:border-purple-500" />
                <div className="flex justify-end mt-1">
                    <AiButton onClick={() => handleGenerate('characterBackstory')} isGenerating={isGenerating.characterBackstory}>Tạo AI</AiButton>
                </div>
            </FormRow>
            <FormRow label="Mục tiêu/Động lực">
                <div className="flex items-center">
                    <input type="checkbox" name="useCharacterGoal" checked={gameSettings.useCharacterGoal} onChange={handleInputChange} className="h-4 w-4 mr-2" />
                    <textarea name="characterGoal" value={gameSettings.characterGoal} onChange={handleInputChange} rows="2" placeholder="Mục tiêu chính của nhân vật là gì?" disabled={!gameSettings.useCharacterGoal} className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md disabled:bg-gray-700" />
                </div>
            </FormRow>
            <FormRow label="Thiên phú/Kỹ năng/Vật phẩm khởi đầu">
                <div className="flex overflow-x-auto gap-4 pb-4 scrollbar-thin scrollbar-thumb-purple-500 scrollbar-track-gray-700">
                    {gameSettings.initialTraits.map((trait, index) => (
                        <div key={trait.id} className="min-w-[320px] flex-shrink-0 p-4 bg-gray-700/50 rounded-lg border border-gray-600">
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <div className="col-span-full md:col-span-1">
                                    <label className="block text-sm font-medium text-gray-300 mb-1">Tên đặc điểm</label>
                                    <input
                                        type="text"
                                        value={trait.name}
                                        onChange={(e) => handleInitialTraitChange(trait.id, 'name', e.target.value)}
                                        className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md"
                                        placeholder="VD: Hỏa Cầu Thuật / Cẩm Nang Luyện Đan..."
                                    />
                                </div>
                                <div className="col-span-full md:col-span-1">
                                    <label className="block text-sm font-medium text-gray-300 mb-1">Mô tả ngắn</label>
                                    <textarea
                                        value={trait.description === '[Chưa có]' ? '' : trait.description}
                                        onChange={(e) => handleInitialTraitChange(trait.id, 'description', e.target.value)}
                                        rows="2"
                                        className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md"
                                        placeholder="Mô tả ngắn gọn. Nếu để trống AI sẽ tự quyết định."
                                    />
                                </div>
                                <div className="col-span-full md:col-span-1">
                                    <label className="block text-sm font-medium text-gray-300 mb-1">Thể loại</label>
                                    <select
                                        value={trait.category}
                                        onChange={(e) => handleInitialTraitChange(trait.id, 'category', e.target.value)}
                                        className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md"
                                    >
                                        <option value="Kỹ năng">Kỹ năng</option>
                                        <option value="Vật phẩm">Vật phẩm</option>
                                    </select>
                                </div>

                                {trait.category === 'Kỹ năng' && (
                                    <div className="col-span-full">
                                        <label className="block text-sm font-medium text-gray-300 mb-1 flex items-center">
                                            Cộng Chỉ Số (cho Thiên phú/Bị động)
                                            <Tooltip content={
                                                <div>
                                                    <h4 className="font-bold mb-1">Hướng Dẫn Nhập Chỉ Số Bonus</h4>
                                                    <p className="mb-2">Chỉ có tác dụng với các kỹ năng loại Bị động, Thiên phú, Nội tại khi khởi tạo game.</p>
                                                    <p><strong>Cú Pháp:</strong> `tên_chỉ_số:giá_trị`</p>
                                                    <p><strong>Nhiều chỉ số:</strong> Ngăn cách bằng dấu phẩy. VD: `atk:10,maxHp:50`</p>
                                                    <p><strong>Phần trăm (%):</strong> Thêm dấu `%`. VD: `atk:%20` (Tăng 20% ATK cơ bản)</p>
                                                    <p className="mt-2"><strong>Các Chỉ Số Hợp Lệ:</strong></p>
                                                    <ul className="list-disc list-inside text-xs">
                                                        <li>`hp`, `maxHp`: Sinh lực</li>
                                                        <li>`mana`, `maxMana`: Năng lượng</li>
                                                        <li>`atk`: Công kích</li>
                                                        <li>`exp`: Kinh nghiệm (cộng một lần)</li>
                                                    </ul>
                                                     <p className="mt-2 italic">Lưu ý: Đây là bonus vĩnh viễn, không phải hiệu ứng tạm thời.</p>
                                                </div>
                                            } />
                                        </label>
                                        <input
                                            type="text"
                                            value={trait.statsBonus || ''}
                                            onChange={(e) => handleInitialTraitChange(trait.id, 'statsBonus', e.target.value)}
                                            className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md"
                                            placeholder="VD: atk:10, maxHp:50, maxMana:%10"
                                        />
                                    </div>
                                )}

                                <div className="col-span-full md:col-span-1 flex justify-end items-end pb-1 md:pb-0">
                                    <button type="button" onClick={() => removeInitialTrait(trait.id)} className="p-2 bg-red-800 hover:bg-red-700 rounded-md">
                                        <TrashIcon className="w-5 h-5 text-red-300" />
                                    </button>
                                </div>
                            </div>
                        </div>
                    ))}
                    <button type="button" onClick={addInitialTrait} className="w-full mt-4 py-2 px-4 bg-gray-600 hover:bg-gray-500 text-white font-semibold rounded-lg flex items-center justify-center text-sm">
                        <PlusIcon /> Thêm Đặc điểm
                    </button>
                </div>
                <p className="text-xs text-gray-500 mt-2 italic">
                    Định nghĩa các đặc điểm ban đầu. AI sẽ dựa vào đây để phát triển nhân vật và câu chuyện.
                </p>
            </FormRow>
        </div>
    );

const renderEntitiesTab = () => (
    <div className="space-y-4">
        <h3 className="text-xl font-bold text-gray-200 mb-4">3. Thiết Lập Thực Thể Ban Đầu</h3>
        {gameSettings.initialWorldElements.map((element, index) => {
            // *** BẮT ĐẦU SỬA ĐỔI ***
            // Lấy ra hệ tu luyện đang được chọn cho NPC này để hiển thị đúng danh sách cảnh giới
            const selectedSystem = worldKnowledge.cultivationSystems.find(s => s.systemName === element.cultivationSystem);
            const availableRealms = selectedSystem ? selectedSystem.realms : [];
            // *** KẾT THÚC SỬA ĐỔI ***

            return (
                <div key={element.id} className="p-4 bg-gray-700/50 rounded-lg border border-gray-600 space-y-3">
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                            <label className="block text-sm font-medium text-gray-300 mb-1">Tên Thực Thể</label>
                            <input type="text" name="name" value={element.name} onChange={(e) => handleInitialElementChange(index, e)} placeholder="VD: Lão Ma Đầu..." className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md" />
                        </div>
                        <div>
                            <label className="block text-sm font-medium text-gray-300 mb-1">Loại Thực Thể</label>
                            <select name="type" value={element.type} onChange={(e) => handleInitialElementChange(index, e)} className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md">
                                <option value="NPC">Nhân Vật (NPC)</option>
                                <option value="LOCATION">Địa Điểm</option>
                                <option value="ITEM">Vật Phẩm (Lore)</option>
                            </select>
                        </div>
                    </div>

                    {/* *** BẮT ĐẦU SỬA ĐỔI: Khối code mới chỉ hiển thị khi loại là NPC *** */}
                    {element.type === 'NPC' && (
                        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 pt-3 border-t border-gray-600">
                            <div>
                                <label className="block text-sm font-medium text-gray-300 mb-1">Hệ Tu Luyện</label>
                                <select name="cultivationSystem" value={element.cultivationSystem} onChange={(e) => handleInitialElementChange(index, e)} className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md text-xs">
                                    {worldKnowledge.cultivationSystems.map(sys => <option key={sys.id} value={sys.systemName}>{sys.systemName}</option>)}
                                </select>
                            </div>
                            <div>
                                <label className="block text-sm font-medium text-gray-300 mb-1">Bậc Thiên Phú</label>
                                <select name="talentTier" value={element.talentTier} onChange={(e) => handleInitialElementChange(index, e)} className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md text-xs">
                                    {TALENT_TIERS.map(tier => <option key={tier.name} value={tier.name}>{tier.name}</option>)}
                                </select>
                            </div>
                            <div>
                                <label className="block text-sm font-medium text-gray-300 mb-1">Cảnh Giới</label>
                                <select name="realm" value={element.realm} onChange={(e) => handleInitialElementChange(index, e)} className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md text-xs">
                                    {availableRealms.map(r => <option key={r} value={r}>{r}</option>)}
                                </select>
                            </div>
                            <div>
                                <label className="block text-sm font-medium text-gray-300 mb-1">Cấp Độ</label>
                                <input 
                                    type="number" 
                                    name="level" 
                                    value={element.level} 
                                    // Tính toán min/max level dựa trên cảnh giới đang chọn
                                    min={(availableRealms.indexOf(element.realm) * 10) + 1}
                                    max={(availableRealms.indexOf(element.realm) * 10) + 10}
                                    onChange={(e) => handleInitialElementChange(index, e)} 
                                    className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md" 
                                />
                            </div>
                        </div>
                    )}
                    {/* *** KẾT THÚC SỬA ĐỔI *** */}
{/* === BẮT ĐẦU KHU VỰC QUẢN LÝ KỸ NĂNG NPC BAN ĐẦU === */}
                    {element.type === 'NPC' && (
                        <div className="pt-3 border-t border-dashed border-gray-600">
                            <label className="block text-sm font-medium text-gray-300 mb-1">Kỹ Năng Khởi Đầu</label>
                             {/* Khu vực hiển thị các kỹ năng NPC đã có */}
                            <div className="flex flex-wrap gap-2 p-2 bg-gray-800/50 rounded-md min-h-[40px] mb-2 border border-gray-600">
                                {(element.skills || []).map(skill => {
                                    const fullSkillInfo = (worldKnowledge.skills || []).find(s => s.id === skill.id);
                                    return (
                                        <div key={skill.id} className="flex items-center gap-2 bg-yellow-600 text-white text-xs font-semibold px-2.5 py-1 rounded-full">
                                            <span>{fullSkillInfo ? fullSkillInfo.Name : 'Kỹ năng lỗi'}</span>
                                            <button
                                                type="button"
                                                onClick={() => {
                                                    const updatedSkills = (element.skills || []).filter(s => s.id !== skill.id);
                                                    // Tạo một "event" giả để gửi dữ liệu mới tới handleInitialElementChange
                                                    const syntheticEvent = { target: { name: 'skills', value: updatedSkills } };
                                                    handleInitialElementChange(index, syntheticEvent);
                                                }}
                                                className="bg-yellow-800 hover:bg-red-600 w-4 h-4 rounded-full flex items-center justify-center text-white"
                                                title="Gỡ bỏ kỹ năng"
                                            >
                                                &times;
                                            </button>
                                        </div>
                                    );
                                })}
                                {(!element.skills || element.skills.length === 0) && (
                                    <p className="text-xs text-gray-500 italic">Chưa có kỹ năng nào.</p>
                                )}
                            </div>
                            {/* Dropdown để thêm kỹ năng mới */}
                            <select
                                value=""
                                onChange={e => {
                                    const selectedSkillId = e.target.value;
                                    const skillToAdd = (worldKnowledge.skills || []).find(s => s.id === selectedSkillId);
                                    if (skillToAdd) {
                                        const updatedSkills = [...(element.skills || []), { id: skillToAdd.id, Name: skillToAdd.Name }];
                                        const syntheticEvent = { target: { name: 'skills', value: updatedSkills } };
                                        handleInitialElementChange(index, syntheticEvent);
                                    }
                                }}
                                className="w-full p-2 bg-gray-800 rounded border border-gray-500 text-xs"
                            >
                                <option value="">-- Chọn để thêm kỹ năng --</option>
                                {(worldKnowledge.skills || [])
                                    .filter(s => !(element.skills || []).some(npcSkill => npcSkill.id === s.id))
                                    .map(s => (
                                        <option key={s.id} value={s.id}>{s.Name}</option>
                                    ))
                                }
                            </select>
                        </div>
                    )}
                    {/* === KẾT THÚC KHU VỰC QUẢN LÝ KỸ NĂNG NPC BAN ĐẦU === */}    
                    <div>
                        <label className="block text-sm font-medium text-gray-300 mb-1">Mô Tả</label>
                        <textarea name="description" value={element.description} onChange={(e) => handleInitialElementChange(index, e)} rows="2" placeholder="Mô tả chi tiết về thực thể này..." className="w-full p-2 bg-gray-800 border border-gray-600 rounded-md" />
                        <div className="flex justify-between items-center mt-2">
                            <button onClick={() => removeInitialWorldElement(element.id)} className="flex items-center text-xs text-red-400 hover:text-red-300">
                                <TrashIcon /> Xóa
                            </button>
                            <AiButton onClick={() => handleGenerate(`elementDesc_${index}`)} isGenerating={isGenerating[`elementDesc_${index}`]}>Tạo AI</AiButton>
                        </div>
                    </div>
                </div>
            )
        })}

            <button onClick={addInitialWorldElement} className="w-full mt-2 py-2 px-4 bg-gray-600 hover:bg-gray-500 text-white font-semibold rounded-lg flex items-center justify-center text-sm">
                <PlusIcon /> Thêm Thực Thể
            </button>
        </div>
    );

    return (
        <div className="min-h-screen bg-gray-900 text-white p-4 sm:p-6 md:p-8 flex justify-center font-sans">
            <div className="w-full max-w-4xl">
                <div className="flex justify-between items-center mb-6">
                    <div className="flex items-center gap-2 p-1 bg-gray-800 rounded-lg">
                        <TabButton label={TABS.WORLD} isActive={activeTab === TABS.WORLD} onClick={() => setActiveTab(TABS.WORLD)} />
                        <TabButton label={TABS.CHARACTER} isActive={activeTab === TABS.CHARACTER} onClick={() => setActiveTab(TABS.CHARACTER)} />
                        <TabButton label={TABS.ENTITIES} isActive={activeTab === TABS.ENTITIES} onClick={() => setActiveTab(TABS.ENTITIES)} />
                    </div>
                    <button onClick={goHome} className="text-gray-400 hover:text-white"> &times; Đóng </button>
                </div>

                <div className="bg-gray-800/60 border border-gray-700 rounded-xl shadow-lg p-6 sm:p-8">
                    {activeTab === TABS.WORLD && renderWorldTab()}
                    {activeTab === TABS.CHARACTER && renderCharacterTab()}
                    {activeTab === TABS.ENTITIES && renderEntitiesTab()}
                </div>
                <div className="mt-8 flex justify-end">
                    <button onClick={initializeGame} disabled={isLoading} className="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-8 rounded-lg shadow-lg transition-transform transform hover:scale-105 disabled:bg-gray-500">
                        {isLoading ? 'Đang Khởi Tạo...' : 'Bắt Đầu'}
                    </button>
                </div>
            </div>
        </div>
    );
};
// *** KẾT THÚC SỬA ĐỔI ***
// *** BẮT ĐẦU SỬA ĐỔI: Sửa lỗi và làm lại UI Cảnh giới ***
const CharacterInfoModal = ({ knowledge, show, onClose, characterPersonality, characterName, worldKnowledge }) => {
    // [DEBUG] Khởi tạo state để quản lý tab đang hoạt động
    const [activeTab, setActiveTab] = useState('nhan-vat-chinh');
    console.log(`[CharacterInfoModal] Component rendered. Active tab is: ${activeTab}`);

    if (!show) return null;
    // [DEBUG] State quản lý các mục NPC chi tiết
    const [isCharactersExpanded, setIsCharactersExpanded] = useState(true); // Mặc định mở
    const [isMonstersExpanded, setIsMonstersExpanded] = useState(false);
    const [isPopulaceExpanded, setIsPopulaceExpanded] = useState(false);
    const [isKilledMonstersExpanded, setIsKilledMonstersExpanded] = useState(false);
    
    const [isOutlineExpanded, setIsOutlineExpanded] = useState(false);

    const [expandedSystem, setExpandedSystem] = useState(null); // State để theo dõi hệ thống đang được xem
    
    const companionDetails = (knowledge.companions || []).map(companionId => {
        // Tra cứu thông tin đầy đủ của đồng hành từ danh sách NPCs
        return knowledge.npcs.find(npc => npc.id === companionId);
    }).filter(Boolean); // Lọc bỏ những kết quả không tìm thấy (để tránh lỗi
    const getStatusIcon = (statusType) => {
        switch (statusType?.toLowerCase()) {
            case 'buff': return <ShieldCheckIcon className="text-green-400 w-4 h-4 inline-block mr-1" />;
            case 'debuff': return <HeartCrackIcon className="text-red-400 w-4 h-4 inline-block mr-1" />;
            case 'injury': return <ExclamationTriangleIcon className="text-yellow-500 w-4 h-4 inline-block mr-1" />;
            default: return <InformationCircleIcon className="text-blue-400 w-4 h-4 inline-block mr-1" />;
        }
    };

    const getQuestStatusColor = (status) => {
        if (status === 'completed') return 'text-green-400';
        if (status === 'failed') return 'text-red-400';
        return 'text-yellow-400'; // active
    };

    const renderSection = (title, items, icon = null, itemColor = "text-green-300", renderItem, emptyText = "Chưa có thông tin.", isCollapsible = false, isExpanded = false, onToggle = () => {}) => {

        // Icon mũi tên để chỉ trạng thái đóng/mở
        const ArrowIcon = () => (
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className={`w-5 h-5 text-gray-400 transform transition-transform duration-200 ${isExpanded ? 'rotate-90' : ''}`}>
                <path fillRule="evenodd" d="M7.21 14.77a.75.75 0 01.02-1.06L11.168 10 7.23 6.29a.75.75 0 111.04-1.08l4.5 4.25a.75.75 0 010 1.08l-4.5 4.25a.75.75 0 01-1.06-.02z" clipRule="evenodd" />
            </svg>
        );

        const headerContent = (
            <div className={`text-lg font-semibold ${itemColor} flex items-center`}>
                {isCollapsible && <ArrowIcon />}
                {icon && <span className="mr-1.5 ml-1">{icon}</span>}
                {title}
            </div>
        );

        return (
            <div className="mb-4">
                {isCollapsible ? (
                    <button onClick={onToggle} className="w-full text-left mb-2">
                        {headerContent}
                    </button>
                ) : (
                    <h4 className="mb-2">{headerContent}</h4>
                )}

                {/* Nội dung chỉ hiển thị khi được mở rộng (nếu có thể đóng/mở) */}
                {(!isCollapsible || isExpanded) && (
                    <div className="pl-4 animate-fade-in-up">
                        {(!items || items.length === 0) ? (
                            <p className="text-gray-400 italic text-sm pl-2">{emptyText}</p>
                        ) : (
                            <ul className="list-disc list-inside space-y-1 pl-2 text-sm">
                                {items.map((item, index) => renderItem(item, index, itemColor))}
                            </ul>
                        )}
                    </div>
                )}
            </div>
        );
    };

    // Hàm render Hệ Thống Tu Luyện mới với các nút tương tác
const renderCultivationSystems = () => {
    const playerPaths = knowledge.playerStats?.cultivationPaths || [];

    return (
        <div className="mb-4">
            <h4 className={`text-lg font-semibold text-amber-400 mb-2 flex items-center`}><BoltIcon className="w-5 h-5 mr-1.5 text-amber-400" />Hệ Thống Cảnh Giới</h4>
            <div className="flex flex-wrap gap-2 p-2 bg-gray-900/50 rounded-lg">
                {worldKnowledge.cultivationSystems.map(system => {
                    const isUnlocked = playerPaths.includes(system.systemName);
                    const isExpanded = expandedSystem?.id === system.id;
                    return (
                        <button
                            key={system.id}
                            disabled={!isUnlocked}
                            onClick={() => setExpandedSystem(isExpanded ? null : system)}
                            className={`px-3 py-1.5 text-xs font-semibold rounded-md transition-all duration-200 border
                                ${isUnlocked
                                    ? (isExpanded ? 'bg-sky-500 text-white border-sky-400 ring-2 ring-sky-300' : 'bg-gray-700 text-gray-200 border-gray-600 hover:bg-gray-600 hover:border-sky-500')
                                    : 'bg-gray-800 text-gray-500 border-gray-700 cursor-not-allowed opacity-60'
                                }`}
                        >
                            {system.systemName}
                        </button>
                    );
                })}
            </div>

            {/* Hiển thị chi tiết cảnh giới của hệ thống được chọn */}
            {expandedSystem && (
                <div className="mt-3 p-3 bg-gray-700/70 rounded-lg animate-fade-in">
                    <h5 className="font-semibold text-sky-300 mb-2">{expandedSystem.systemName}</h5>
                    <ul className="list-decimal list-inside space-y-1 text-sm text-gray-300 pl-3">
                        {expandedSystem.realms.map((realm, index) => <li key={index}>{realm}</li>)}
                    </ul>
                </div>
            )}
        </div>
    );
};

    // [DEBUG] Hàm render nội dung cho Tab Nhân Vật Chính
    const renderNhanVatChinhTab = () => {
        console.log('[CharacterInfoModal] Rendering "Nhân vật chính" tab content.');
        const companionDetails = (knowledge.companions || []).map(companionId => {
            return knowledge.npcs.find(npc => npc.id === companionId);
        }).filter(Boolean);

        return (
            <div className="space-y-4">
                <div className="mb-4">
                    <h4 className="text-lg font-semibold text-amber-400 mb-1 flex items-center"><UserCircleIcon /> Nhân Vật Chính</h4>
                    <p className="text-gray-300 text-sm pl-2">Tên: {characterName || "N/A"}</p>
                    <p className="text-gray-300 text-sm pl-2">Tính cách: {characterPersonality || "Chưa xác định"}</p>
                </div>
                 {renderCultivationSystems()}
                {renderSection("Trạng Thái Hiện Tại", knowledge.playerStatus, <InformationCircleIcon className="text-indigo-400" />, "text-indigo-400", (item, index, color) => (
                    <li key={`status-${index}`} className="text-gray-300 p-1.5 bg-gray-700/50 rounded-md">
                        <strong className={color}>{getStatusIcon(item.type)} {item.name || "Trạng thái không tên"}</strong>: {item.description || "Không có mô tả."}
                        <div className="text-xs text-gray-400 ml-3">
                            {item.type && <span>Loại: {item.type}. </span>}
                            {item.duration && <span>Thời gian: {item.duration}. </span>}
                            {item.effects && <span>Ảnh hưởng: {item.effects}. </span>}
                            {item.cureConditions && <span>Điều kiện hóa giải: {item.cureConditions}. </span>}
                            {item.source && <span>Nguồn: {item.source}.</span>}
                        </div>
                    </li>
                ), "Không có trạng thái nào đang hoạt động.")}
                {renderSection("Nhật Ký Nhiệm Vụ", knowledge.quests, <ClipboardDocumentCheckIcon className="text-yellow-400" />, "text-yellow-400", (quest, index) => (
                    <li key={`quest-${index}`} className={`text-gray-200 p-2 bg-gray-700/60 rounded-md border-l-4 ${quest.status === 'completed' ? 'border-green-500' : quest.status === 'failed' ? 'border-red-500' : 'border-yellow-500'}`}>
                        <div className="flex justify-between items-start">
                            <strong className={`font-semibold ${getQuestStatusColor(quest.status)}`}>{quest.title || "Nhiệm vụ không tên"}</strong>
                            <span className={`text-xs px-1.5 py-0.5 rounded-full ${quest.status === 'completed' ? 'bg-green-600 text-green-100' : quest.status === 'failed' ? 'bg-red-600 text-red-100' : 'bg-yellow-600 text-yellow-100'}`}>
                                {quest.status === 'active' ? 'Đang làm' : quest.status === 'completed' ? 'Hoàn thành' : 'Thất bại'}
                            </span>
                        </div>
                        <p className="text-xs text-gray-300 mt-1">{quest.description || "Không có mô tả."}</p>
                        {quest.objectives && quest.objectives.length > 0 && (
                            <ul className="list-disc list-inside text-xs text-gray-400 mt-1 pl-3">
                                {quest.objectives.map((obj, oIdx) => (
                                    <li key={oIdx} className={obj.completed ? 'line-through text-gray-500' : ''}>{obj.text}</li>
                                ))}
                            </ul>
                        )}
                        {quest.giver && <p className="text-xs text-gray-400 mt-1">Người giao: {quest.giver}</p>}
                        {quest.reward && <p className="text-xs text-gray-400 mt-1">Phần thưởng: {quest.reward}</p>}
                    </li>
                ), "Chưa nhận nhiệm vụ nào.")}
                {renderSection("Balo Đồ", knowledge.inventory, <BackpackIcon className="text-orange-400" />, "text-orange-400", (item, index, color) => (
                    <li key={`inventory-${index}`} className="text-gray-300">
                        <strong className={color}>{item.Name || "Vật phẩm không tên"}</strong>: {item.Description || "Không có mô tả."}
                        <span className="text-xs text-gray-400 ml-1">
                            ({item.Type || "Chưa rõ loại"})
                            {item.Equippable ? " (Có thể trang bị)" : ""}
                            {item.Usable ? " (Có thể sử dụng)" : ""}
                            {item.Consumable ? " (Tiêu hao)" : ""}
                            {typeof item.Uses === 'number' ? ` (Còn ${item.Uses} lần)` : ""}
                        </span>
                    </li>
                ))}
                {renderSection("Kỹ Năng", knowledge.playerSkills, <BoltIcon className="w-5 h-5 mr-1 text-yellow-400" />, "text-yellow-400", (item, index, color) => (
                    <li key={`skill-${index}`} className="text-gray-300">
                        <strong className={color}>{item.Name || "Kỹ năng không tên"}</strong>
                        <span className="text-xs text-gray-400 ml-1">
                            (Mana: {item.manaCost || 0}, Hồi chiêu: {item.currentCooldown || 0}/{item.cooldown || 0}, Loại: {item.Type || 'N/A'})
                        </span>
                        <p className="text-xs italic text-gray-400 pl-2">Mô tả: {item.Description || "Không có."}</p>
                        <p className="text-xs italic text-cyan-400 pl-2">Hiệu ứng: {item.effect || "Không có."}</p>
                    </li>
                ))}
                {renderSection("Đồng Hành", companionDetails, <UserGroupIcon className="text-lime-400" />, "text-lime-400", (item, index, color) => (
                    <li key={`companion-${index}`} className="text-gray-300 bg-gray-700/50 p-2 rounded-md">
                        <strong className={color}>{item.Name || "Không rõ tên"}</strong>
                        <p className="text-xs italic text-gray-400">{item.Description || "Chưa có mô tả."}</p>
                         <div className="grid grid-cols-2 gap-x-3 text-xs mt-1">
                            <span className="text-red-300">HP: {item.HP !== undefined ? formatLargeNumber(item.HP) : 'N/A'}</span>
                            <span className="text-orange-300">ATK: {item.ATK !== undefined ? formatLargeNumber(item.ATK) : 'N/A'}</span>
                            <span className="text-amber-300 col-span-2">Cảnh giới: {item.realm || 'N/A'} (Cấp {item.level || 'N/A'})</span>
                        </div>
                        {item.statuses && item.statuses.length > 0 && (
                            <div className="text-xs text-yellow-400 ml-3 mt-0.5">
                                Trạng thái: {item.statuses.map(s => `${s.name}`).join(', ')}
                            </div>
                        )}
                    </li>
                ))}
            </div>
        );
    };

    // [DEBUG] Hàm render nội dung cho Tab Mối Quan Hệ
    const renderMoiQuanHeTab = () => {
        console.log('[CharacterInfoModal] Rendering "Mối quan hệ" tab with new 4-section layout.');
        
        // [DEBUG] Lọc dữ liệu cho từng section
        const characters = knowledge.npcs.filter(npc => npc.type === 'Character');
        const monsters = knowledge.npcs.filter(npc => npc.type === 'Monster' && npc.Stance !== 'Đã bị đánh bại');
        const Populace = knowledge.npcs.filter(npc => npc.type === 'Populace');
        const killedMonsters = knowledge.npcs.filter(npc => npc.type === 'Monster' && npc.Stance === 'Đã bị đánh bại');
        console.log(`[CharacterInfoModal DEBUG] Filtered counts: Characters=${characters.length}, Monsters=${monsters.length}, Populace=${Populace.length}, Killed=${killedMonsters.length}`);

        // Hàm render chung cho các loại NPC để tránh lặp code
        const renderNpcItem = (item, index, color) => (
            <li key={`npc-item-${item.id || index}`} className="text-gray-300 bg-gray-700/50 p-2 rounded-md">
                <strong className={color}>{item.Name || "Không rõ tên"}</strong>
                {item.Personality && <span className="text-gray-400 text-xs"> (Tính cách: {item.Personality})</span>}
                <p className="text-xs italic text-gray-400">{item.Description || "Chưa có mô tả."}</p>
                <div className="grid grid-cols-2 gap-x-3 text-xs mt-1">
                    <span className="text-red-300">HP: {item.HP !== undefined ? formatLargeNumber(item.HP) : 'N/A'}</span>
                    <span className="text-orange-300">ATK: {item.ATK !== undefined ? formatLargeNumber(item.ATK) : 'N/A'}</span>
                    <span className="text-amber-300 col-span-2">Cảnh giới: {item.realm || 'N/A'} (Cấp {item.level || 'N/A'})</span>
                    <span className="text-sky-300 col-span-2">Thái độ: {item.Stance || 'Chưa rõ'}</span>
                </div>
                {item.skills && item.skills.length > 0 && (
                    <div className="mt-2 pt-2 border-t border-dashed border-gray-600">
                        {console.log(`[DEBUG UI] Rendering ${item.skills.length} skills for NPC: ${item.Name}`)}
                        <p className="text-xs font-semibold text-yellow-300 mb-1 flex items-center">
                            <BoltIcon className="w-3.5 h-3.5 mr-1"/> Kỹ năng:
                        </p>
                        <ul className="list-disc list-inside text-xs text-gray-300 space-y-1 pl-3">
                            {item.skills.map((skill, skillIndex) => (
                                <li key={skillIndex}>
                                    <strong className="font-medium">{skill.Name}</strong>: {skill.Description || "Không có mô tả."}
                                </li>
                            ))}
                        </ul>
                    </div>
                )}
                {item.statuses && item.statuses.length > 0 && (
                    <div className="text-xs text-gray-400 ml-3 mt-0.5">
                        Trạng thái NPC: {item.statuses.map(s => `${s.name} (${s.type})`).join(', ')}
                    </div>
                )}
                {item.interactionLog && item.interactionLog.length > 0 && (
                    <div className="mt-2 pt-2 border-t border-gray-600">
                        <p className="text-xs font-semibold text-gray-400 mb-1">Nhật Ký Tương Tác:</p>
                        <ul className="list-disc list-inside text-xs text-gray-400 space-y-1">
                            {item.interactionLog.map((log, logIndex) => <li key={logIndex}>{log}</li>)}
                        </ul>
                    </div>
                )}
            </li>
        );

        return (
            <div className="space-y-4">
                 {renderSection("Mối Quan Hệ", knowledge.relationships, <HeartIcon className="text-pink-400" />, "text-pink-400", (item, index, color) => (
                    <li key={`relation-${index}`} className="text-gray-300">
                        <strong className={color}>{item.NPC || "NPC không tên"}</strong>: {item.Standing || "Chưa rõ"}
                        {item.Reason && <span className="text-xs text-gray-400 italic ml-1">- {item.Reason}</span>}
                    </li>
                ))}

                {/* Section 1: Character */}
                {renderSection(
                    "Nhân vật Cốt truyện 🎭",
                    characters,
                    <UserCircleIcon />, "text-sky-400",
                    renderNpcItem, "Chưa gặp nhân vật cốt truyện nào.",
                    true, isCharactersExpanded, () => setIsCharactersExpanded(!isCharactersExpanded)
                )}

                {/* Section 2: Monster */}
                {renderSection(
                    "Quái vật 👹",
                    monsters,
                    <BullseyeIcon />, "text-red-400",
                    renderNpcItem, "Không có quái vật nào trong khu vực.",
                    true, isMonstersExpanded, () => setIsMonstersExpanded(!isMonstersExpanded)
                )}

                {/* Section 3: Populace */}
                {renderSection(
                    "Dân thường 👨‍👩‍👧‍👦",
                    Populace,
                    <BuildingStorefrontIcon />, "text-green-400",
                    renderNpcItem, "Chưa gặp dân thường nào.",
                    true, isPopulaceExpanded, () => setIsPopulaceExpanded(!isPopulaceExpanded)
                )}
                
                {/* Section 4: Killed Monsters */}
                {renderSection(
                    "Quái đã giết ☠️",
                    killedMonsters,
                    <TrashIcon className="w-5 h-5 mr-1.5 text-gray-400" />, "text-gray-400",
                    (item, index, color) => (
                         <li key={`killed-Monster-${item.id || index}`} className="text-gray-300 bg-gray-900/40 p-2 rounded-md opacity-70">
                            <strong className={color}>{item.Name || "Không rõ tên"}</strong>
                            <p className="text-xs italic text-gray-500 line-through">{item.Description || "Chưa có mô tả."}</p>
                            <div className="grid grid-cols-2 gap-x-3 text-xs mt-1 text-gray-500">
                                <span>HP: 0</span>
                                <span>ATK: {item.ATK !== undefined ? formatLargeNumber(item.ATK) : 'N/A'}</span>
                                <span className="col-span-2">Cảnh giới: {item.realm || 'N/A'} (Cấp {item.level || 'N/A'})</span>
                                <span className="col-span-2">Trạng thái: Đã bị đánh bại</span>
                            </div>
                        </li>
                    ),
                    "Chưa tiêu diệt quái vật nào.",
                    true, isKilledMonstersExpanded, () => setIsKilledMonstersExpanded(!isKilledMonstersExpanded)
                )}
            </div>
        );
    };

    // [DEBUG] Hàm render nội dung cho Tab Vật phẩm Thế giới
    const renderVatPhamTheGioiTab = () => {
        console.log('[CharacterInfoModal] Rendering "Vật phẩm thế giới" tab content.');
        return (
            <div className="space-y-4">
                {renderSection("Vật Phẩm Thế Giới (Lore)", knowledge.items, <SparklesIcon className="w-5 h-5 text-yellow-400" />, "text-yellow-400", (item, index, color) => (
                    <li key={`loreitem-${index}`} className="text-gray-300">
                        <strong className={color}>{item.Name || "Không rõ tên"}:</strong> {item.Description || "Chưa có mô tả."}
                    </li>
                ))}
            </div>
        );
    };

    // [DEBUG] Hàm render nội dung cho Tab Đại cương
    const renderDaiCuongTab = () => {
        console.log('[CharacterInfoModal] Rendering "Đại cương câu chuyện" tab content.');
        return (
            <div className="space-y-4">
                 {renderSection(
                    "Đại Cương Câu Chuyện (AI Tóm Tắt)",
                    knowledge.storyOutline ? [knowledge.storyOutline] : [],
                    <ClipboardDocumentCheckIcon className="w-5 h-5 mr-1.5 text-gray-300" />,
                    "text-gray-300",
                    (outlineText, index) => (
                        <div key={index} className="text-sm text-gray-300 bg-gray-900/50 p-3 rounded-lg whitespace-pre-line">
                            {outlineText}
                        </div>
                    ),
                    "Chưa có tóm tắt nào.",
                    true,
                    isOutlineExpanded,
                    () => setIsOutlineExpanded(!isOutlineExpanded)
                )}
            </div>
        );
    };

    return (
        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
            <div className="bg-gray-800 p-6 rounded-xl shadow-2xl w-full max-w-xl max-h-[85vh] flex flex-col border border-purple-600">
                <h3 className="text-2xl font-bold text-purple-400 mb-4 flex items-center"><CharacterSheetIcon /> Thông Tin Nhân Vật & Thế Giới</h3>
                <div className="flex border-b border-gray-700 mb-4">
                    <TabButton
                        label="Nhân vật chính"
                        isActive={activeTab === 'nhan-vat-chinh'}
                        onClick={() => {
                            console.log('[CharacterInfoModal] Tab clicked: Chuyển sang "Nhân vật chính"');
                            setActiveTab('nhan-vat-chinh');
                        }}
                    />
                    <TabButton
                        label="Mối quan hệ"
                        isActive={activeTab === 'moi-quan-he'}
                        onClick={() => {
                            console.log('[CharacterInfoModal] Tab clicked: Chuyển sang "Mối quan hệ"');
                            setActiveTab('moi-quan-he');
                        }}
                    />
                    <TabButton
                        label="Vật phẩm thế giới"
                        isActive={activeTab === 'vat-pham-the-gioi'}
                        onClick={() => {
                            console.log('[CharacterInfoModal] Tab clicked: Chuyển sang "Vật phẩm thế giới"');
                            setActiveTab('vat-pham-the-gioi');
                        }}
                    />
                    <TabButton
                        label="Đại cương câu chuyện"
                        isActive={activeTab === 'dai-cuong'}
                        onClick={() => {
                            console.log('[CharacterInfoModal] Tab clicked: Chuyển sang "Đại cương câu chuyện"');
                            setActiveTab('dai-cuong');
                        }}
                    />
                </div>
                <div className="overflow-y-auto flex-grow pr-2 scrollbar-thin scrollbar-thumb-purple-500 scrollbar-track-gray-700">
                    {activeTab === 'nhan-vat-chinh' && renderNhanVatChinhTab()}
                    {activeTab === 'moi-quan-he' && renderMoiQuanHeTab()}
                    {activeTab === 'vat-pham-the-gioi' && renderVatPhamTheGioiTab()}
                    {activeTab === 'dai-cuong' && renderDaiCuongTab()}
                </div>
                <button
                    onClick={onClose}
                    className="mt-6 w-full bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2 px-4 rounded-lg"
                >
                    Đóng
                </button>
            </div>
        </div>
    );
};

const QuickLoreModal = ({ loreItem, show, onClose }) => {
    if (!show || !loreItem) return null;
    let icon = <InformationCircleIcon className="w-5 h-5 mr-2 text-cyan-400 mt-1"/>;
    const category = loreItem.category?.toLowerCase();

    if (category === 'npcs') icon = <UserCircleIcon />;
    else if (category === 'items' || category === 'inventory') icon = <SparklesIcon className="w-5 h-5 mr-2 text-yellow-400 mt-1"/>;
    else if (category === 'companions') icon = <UserGroupIcon className="w-5 h-5 mr-2 text-lime-400 mt-1"/>;
    else if (category === 'playerskills') icon = <BoltIcon className="w-5 h-5 mr-2 text-yellow-400 mt-1"/>;
    else if (category === 'relationships') icon = <HeartIcon className="w-5 h-5 mr-2 text-pink-400 mt-1"/>;
    else if (category === 'quests') icon = <ClipboardDocumentCheckIcon className="w-5 h-5 mr-2 text-yellow-400 mt-1"/>;
    else if (category === 'playerstatus') {
        switch (loreItem.type?.toLowerCase()) {
            case 'buff': icon = <ShieldCheckIcon className="text-green-400 w-5 h-5 mr-2 mt-1"/>; break;
            case 'debuff': icon = <HeartCrackIcon className="text-red-400 w-5 h-5 mr-2 mt-1"/>; break;
            case 'injury': icon = <ExclamationTriangleIcon className="text-yellow-500 w-5 h-5 mr-2 mt-1"/>; break;
            default: icon = <InformationCircleIcon className="text-blue-400 w-5 h-5 mr-2 mt-1"/>; break;
        }
    }


    return (
        <div className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 z-[80]" onClick={onClose}>
            <div className="bg-gray-700 p-5 rounded-lg shadow-xl w-full max-w-sm border border-cyan-700" onClick={(e) => e.stopPropagation()}>
                <div className="flex items-start mb-2">
                    {icon}
                    <h4 className="text-lg font-semibold text-cyan-300">{loreItem.Name || loreItem.NPC || loreItem.name || loreItem.title || "Không rõ tên"}</h4>
                </div>
                <p className="text-sm text-gray-200 bg-gray-600 p-3 rounded max-h-40 overflow-y-auto whitespace-pre-line scrollbar-thin scrollbar-thumb-gray-500 scrollbar-track-gray-600">
                    {loreItem.Description || loreItem.Standing || loreItem.description || "Không có mô tả chi tiết."}
                </p>
                {loreItem.Personality && <p className="text-xs text-gray-300 mt-1"><strong>Tính cách:</strong> {loreItem.Personality}</p>}
                {loreItem.Stats && <p className="text-xs text-gray-300 mt-1"><strong>Chỉ số:</strong> {loreItem.Stats}</p>}
                {loreItem.Type && !loreItem.type && <p className="text-xs text-gray-300 mt-1"><strong>Loại (Lore):</strong> {loreItem.Type}</p>}
                {loreItem.type && <p className="text-xs text-gray-300 mt-1"><strong>Loại (Trạng thái):</strong> {loreItem.type}</p>}
                {loreItem.duration && <p className="text-xs text-gray-300 mt-1"><strong>Thời gian:</strong> {loreItem.duration}</p>}
                {loreItem.effects && <p className="text-xs text-gray-300 mt-1"><strong>Ảnh hưởng:</strong> {loreItem.effects}</p>}
                {loreItem.cureConditions && <p className="text-xs text-gray-300 mt-1"><strong>Điều kiện hóa giải:</strong> {loreItem.cureConditions}</p>}
                {loreItem.source && <p className="text-xs text-gray-300 mt-1"><strong>Nguồn:</strong> {loreItem.source}</p>}
                {loreItem.Reason && <p className="text-xs text-gray-300 mt-1"><strong>Lý do (Quan hệ):</strong> {loreItem.Reason}</p>}
                {loreItem.Equippable !== undefined && <p className="text-xs text-gray-300 mt-1"><strong>Có thể trang bị:</strong> {loreItem.Equippable ? "Có" : "Không"}</p>}
                {loreItem.Usable !== undefined && <p className="text-xs text-gray-300 mt-1"><strong>Có thể sử dụng:</strong> {loreItem.Usable ? "Có" : "Không"}</p>}
                {loreItem.Consumable !== undefined && <p className="text-xs text-gray-300 mt-1"><strong>Tiêu hao khi dùng:</strong> {loreItem.Consumable ? "Có" : "Không"}</p>}
                {typeof loreItem.Uses === 'number' && <p className="text-xs text-gray-300 mt-1"><strong>Số lần dùng còn lại:</strong> {loreItem.Uses}</p>}
                
                {/* Hiển thị chỉ số cho NPC và Đồng hành */}
                {(category === 'npcs' || category === 'companions') && (
                    <>
                        {loreItem.HP !== undefined && <p className="text-xs text-red-300 mt-1"><strong>HP:</strong> {loreItem.HP}</p>}
                        {loreItem.ATK !== undefined && <p className="text-xs text-orange-300 mt-1"><strong>ATK:</strong> {loreItem.ATK}</p>}
                        {loreItem.Stance && <p className="text-xs text-yellow-300 mt-1"><strong>Thái độ:</strong> {loreItem.Stance}</p>}
                    </>
                )}

                {/* Hiển thị tác dụng cho Vật phẩm */}
                {(category === 'items' || category === 'inventory') && (
                    <>
                        {loreItem.EffectDescription && <p className="text-xs text-cyan-300 mt-2"><strong>Tác dụng:</strong> {loreItem.EffectDescription}</p>}
                        {loreItem.StatsBonus && <p className="text-xs text-green-400 mt-1"><strong>Cộng chỉ số:</strong> {loreItem.StatsBonus.replace(/,/g, ', ')}</p>}
                        {loreItem.SideEffect && <p className="text-xs text-red-400 mt-1"><strong>Tác dụng phụ:</strong> {loreItem.SideEffect}</p>}
                    </>
                )}
                {/* Quest specific details */}
                {category === 'quests' && (
                    <>
                        {loreItem.status && <p className="text-xs text-gray-300 mt-1"><strong>Trạng thái NV:</strong> {loreItem.status === 'active' ? 'Đang làm' : loreItem.status === 'completed' ? 'Hoàn thành' : 'Thất bại'}</p>}
                        {loreItem.objectives && loreItem.objectives.length > 0 && (
                            <div className="mt-1">
                                <p className="text-xs text-gray-300 font-semibold">Mục tiêu:</p>
                                <ul className="list-disc list-inside text-xs text-gray-400 pl-3">
                                    {loreItem.objectives.map((obj, idx) => (
                                        <li key={idx} className={obj.completed ? 'line-through text-gray-500' : ''}>{obj.text}</li>
                                    ))}
                                </ul>
                            </div>
                        )}
                        {loreItem.giver && <p className="text-xs text-gray-300 mt-1"><strong>Người giao:</strong> {loreItem.giver}</p>}
                        {loreItem.reward && <p className="text-xs text-gray-300 mt-1"><strong>Phần thưởng:</strong> {loreItem.reward}</p>}
                    </>
                )}
                 <button
                    onClick={onClose}
                    className="mt-4 w-full bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2 px-3 rounded-md text-sm"
                >
                    Đóng
                </button>
            </div>
        </div>
    );
};

const SuggestedActionsModal = ({ show, suggestions, onSelect, onClose, isLoading }) => {
    if (!show) return null;
    return (
        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-[90] animate-fade-in">
            <div className="bg-gradient-to-br from-purple-900 to-indigo-800 p-8 rounded-2xl shadow-2xl w-full max-w-xl border border-purple-700/50"> {/* Đã thay đổi max-w-md thành max-w-xl */}
                <h3 className="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-300 to-pink-400 mb-6 text-center flex items-center justify-center">
                    <LightBulbIcon className="w-8 h-8 mr-3 text-purple-300"/> Gợi Ý Hành Động
                </h3>
                {isLoading ? (
                    <div className="flex justify-center items-center h-32"> {/* Tăng chiều cao loading */}
                        <div className="w-10 h-10 border-4 border-t-transparent border-purple-400 rounded-full animate-spin"></div>
                        <p className="ml-4 text-gray-300 text-lg">AI đang suy nghĩ những hành động khả thi...</p>
                    </div>
                ) : suggestions.length > 0 ? (
                    <ul className="space-y-3 max-h-80 overflow-y-auto scrollbar-thin scrollbar-thumb-purple-500 scrollbar-track-gray-700"> {/* Tăng max-h */}
                        {suggestions.map((suggestion, index) => (
                            <li key={index}>
                                <button
                                    onClick={() => { onSelect(suggestion); onClose(); }}
                                    className="w-full text-left p-4 bg-purple-700 hover:bg-purple-600/80 rounded-lg text-gray-100 font-medium transition-all shadow-md hover:shadow-lg transform hover:-translate-y-0.5"
                                >
                                    {suggestion}
                                </button>
                            </li>
                        ))}
                    </ul>
                ) : (
                    <p className="text-gray-400 text-center py-6 text-lg">Không có gợi ý nào được tạo ra lúc này. Hãy thử lại hoặc tự sáng tạo!</p>
                )}
                <button
                    onClick={onClose}
                    className="mt-8 w-full bg-gradient-to-r from-pink-600 to-red-600 hover:from-pink-700 hover:to-red-700 text-white font-bold py-3.5 px-6 rounded-lg shadow-xl hover:shadow-2xl transition-all transform hover:scale-105 flex items-center justify-center"
                >
                    Đóng
                </button>
            </div>
        </div>
    );
};

// *** BẮT ĐẦU SỬA ĐỔI: Sửa lỗi hiển thị chỉ số nhân vật ***
const GameplayScreen = ({
    goHome, gameSettings, restartGame, storyHistory, isLoading, currentStory,
    choices, handleChoice, formatStoryText, customActionInput, setCustomActionInput,
    handleCustomAction, setShowCharacterInfoModal,
    isProcessingAction, handleGenerateSuggestedActions, isGeneratingSuggestedActions,
    isCallingKobold, handleSaveGame, setShowCraftingModal, currentTurn, setShowCharacterEquipModal,
    setShowSuggestedActionsModal, setShowQuickReferenceModal, knowledgeBase, setShowWorldEditor,
    theme, toggleTheme
}) => (
    <div className={`min-h-screen flex flex-col p-2 md:p-4 font-['Arial',_sans-serif] transition-colors duration-300 ${theme === 'dark' ? 'bg-gray-800 text-gray-100' : 'bg-white text-gray-900'}`}>
        <header className={`p-4 rounded-lg shadow-lg mb-4 text-xs sm:text-sm transition-colors duration-300 ${theme === 'dark' ? 'bg-gray-800/50' : 'bg-gray-100'}`}>
            <div className={`grid grid-cols-5 border-t border-l ${theme === 'dark' ? 'border-gray-700' : 'border-gray-300'}`}>
                {/* Hàng 1: Về Home, HP, Chủ đề, Mana, Bắt đầu lại */}
                <div className={`col-span-1 p-2 border-b border-r flex items-center ${theme === 'dark' ? 'border-gray-700' : 'border-gray-300'}`}>
                    <button onClick={goHome} className={`font-semibold py-1.5 px-2.5 rounded-lg shadow-md transition-colors flex items-center text-xs whitespace-nowrap ${theme === 'dark' ? 'bg-gray-600 hover:bg-gray-700 text-white' : 'bg-gray-200 hover:bg-gray-300 text-black'}`}>
                        <ArrowLeftStartOnRectangleIcon className="w-3.5 h-3.5 mr-1" /> Về Home
                    </button>
                </div>
                <div className={`col-span-1 p-2 border-b border-r flex items-center ${theme === 'dark' ? 'border-gray-700' : 'border-gray-300'}`}>
                    <div className={`font-semibold whitespace-nowrap ${theme === 'dark' ? 'text-red-400' : 'text-red-600'}`}>HP: <span className={theme === 'dark' ? 'text-red-300' : 'text-red-500'}>{formatLargeNumber(knowledgeBase.playerStats.hp)}/{formatLargeNumber(knowledgeBase.playerStats.maxHp)}</span></div>
                </div>
                <div className={`col-span-1 p-2 border-b border-r flex items-center justify-center ${theme === 'dark' ? 'border-gray-700' : 'border-gray-300'}`}>
                    <div className={`font-semibold whitespace-nowrap ${theme === 'dark' ? 'text-white' : 'text-black'}`}>Chủ đề:
                        <span className={theme === 'dark' ? 'text-teal-300' : 'text-teal-600'}>
                            {(gameSettings.theme && gameSettings.theme.length > 20)
                                ? `${gameSettings.theme.substring(0, 20)}...`
                                : (gameSettings.theme || "Chưa rõ")}
                        </span>
                    </div>
                </div>
                <div className={`col-span-1 p-2 border-b border-r flex items-center justify-end ${theme === 'dark' ? 'border-gray-700' : 'border-gray-300'}`}>
                    <div className={`font-semibold whitespace-nowrap ${theme === 'dark' ? 'text-blue-400' : 'text-blue-600'}`}>Mana: <span className={theme === 'dark' ? 'text-blue-300' : 'text-blue-500'}>{formatLargeNumber(knowledgeBase.playerStats.mana)}/{formatLargeNumber(knowledgeBase.playerStats.maxMana)}</span></div>
                </div>
                <div className={`col-span-1 p-2 border-b border-r flex items-center justify-end ${theme === 'dark' ? 'border-gray-700' : 'border-gray-300'}`}>
                    <button onClick={() => setShowWorldEditor(true)} className="bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2 px-2.5 rounded-lg shadow-md transition-colors flex items-center text-xs mr-2 disabled:bg-gray-500" title="Thiên Đạo - Chỉnh Sửa Thế Giới">
                        <GlobeAltIcon className="w-4 h-4 mr-1" /> Thiên Đạo
                    </button>
                    <button onClick={restartGame} disabled={isLoading || isProcessingAction} className="bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-2.5 rounded-lg shadow-md transition-colors flex items-center text-xs disabled:bg-gray-500">
                        <ArrowPathIcon className="w-4 h-4 mr-1" /> Bắt Đầu Lại
                    </button>
                </div>

                {/* Hàng 2: Tu luyện, ATK, Tên, Tu vi, Thông tin */}
                <div className={`col-span-1 p-2 border-b border-r flex items-center ${theme === 'dark' ? 'border-gray-700' : 'border-gray-300'}`}>
                    <div className={`whitespace-nowrap ${theme === 'dark' ? 'text-amber-300' : 'text-amber-600'}`}>
                        Tu Luyện: {knowledgeBase.playerStats.cultivationPaths?.join(', ') || 'Chưa có'}
                    </div>
                </div>
                <div className={`col-span-1 p-2 border-b border-r flex items-center ${theme === 'dark' ? 'border-gray-700' : 'border-gray-300'}`}>
                    <div className={`font-semibold whitespace-nowrap ${theme === 'dark' ? 'text-orange-400' : 'text-orange-600'}`}>ATK: <span className={theme === 'dark' ? 'text-orange-300' : 'text-orange-500'}>{formatLargeNumber(knowledgeBase.playerStats.atk)}</span></div>
                </div>
                <div className={`col-span-1 p-2 border-b border-r flex items-center justify-center ${theme === 'dark' ? 'border-gray-700' : 'border-gray-300'}`}>
                    <div className={`flex items-center gap-x-3 font-semibold whitespace-nowrap ${theme === 'dark' ? 'text-white' : 'text-black'}`}>
                        <span>Tên: <span className={theme === 'dark' ? 'text-teal-300' : 'text-teal-600'}>{knowledgeBase.playerStats.characterName || "N/A"}</span></span>
                        <span className={theme === 'dark' ? 'text-gray-500' : 'text-gray-400'}>|</span>
                        <span>Lượt: <span className={theme === 'dark' ? 'text-yellow-300' : 'text-yellow-600'}>{currentTurn}</span></span>
                    </div>
                </div>
                <div className={`col-span-1 p-2 border-b border-r flex items-center justify-end ${theme === 'dark' ? 'border-gray-700' : 'border-gray-300'}`}>
                    <div className={`font-semibold whitespace-nowrap ${theme === 'dark' ? 'text-yellow-400' : 'text-yellow-600'}`}>Tu vi: <span className={theme === 'dark' ? 'text-yellow-300' : 'text-yellow-500'}>{formatLargeNumber(knowledgeBase.playerStats.exp)}/{formatLargeNumber(knowledgeBase.playerStats.maxExp)}</span></div>
                </div>
                <div className={`col-span-1 p-2 border-b border-r flex items-center justify-end ${theme === 'dark' ? 'border-gray-700' : 'border-gray-300'}`}>
                    <button onClick={() => setShowCharacterEquipModal(true)} disabled={isLoading || isProcessingAction} className="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-2.5 rounded-lg shadow-md transition-colors flex items-center text-xs disabled:bg-gray-500">
                        <ArmorIcon /> Trang Bị
                    </button>
                    <button onClick={() => setShowCharacterInfoModal(true)} disabled={isLoading || isProcessingAction} className="bg-teal-600 hover:bg-teal-700 text-white font-semibold py-2 px-2.5 rounded-lg shadow-md transition-colors flex items-center text-xs disabled:bg-gray-500">
                        <CharacterSheetIcon /> Thông Tin
                    </button>
                </div>

                {/* Hàng 3: Cảnh giới, Tính cách, Tiền */}
                <div className={`col-span-2 p-2 border-b border-r flex items-center ${theme === 'dark' ? 'border-gray-700' : 'border-gray-300'}`}>
                    <p className={`whitespace-nowrap ${theme === 'dark' ? 'text-amber-300' : 'text-amber-600'}`}>Cảnh giới: {knowledgeBase.playerStats.realm} (Cấp {knowledgeBase.playerStats.level})</p>
                </div>
                <div className={`col-span-1 p-2 border-b border-r flex items-center justify-center ${theme === 'dark' ? 'border-gray-700' : 'border-gray-300'}`}>
                    <div className={`whitespace-nowrap ${theme === 'dark' ? 'text-sky-300' : 'text-sky-600'}`}>Tính cách: <span className="ml-1 leading-tight">{knowledgeBase.playerStats.characterPersonality}</span></div>
                </div>
                <div className={`col-span-2 p-2 border-b border-r flex items-center justify-end ${theme === 'dark' ? 'border-gray-700' : 'border-gray-300'}`}>
                    <div className={`font-semibold whitespace-nowrap ${theme === 'dark' ? 'text-lime-400' : 'text-lime-600'}`}>
                        Tiền: <span className={theme === 'dark' ? 'text-lime-300' : 'text-lime-500'}>{formatLargeNumber(knowledgeBase.playerStats.currency)} {gameSettings.currencyName}</span>
                    </div>
                </div>
            </div>
        </header>

        <div className="grid grid-cols-1 md:grid-cols-3 gap-3 mb-3">
            {/* Panel 1: Current Status */}
            <div className={`p-3 rounded-xl shadow-lg h-full flex flex-col min-h-[100px] transition-colors duration-300 ${theme === 'dark' ? 'bg-gray-800/40 border border-indigo-700/50' : 'bg-indigo-50 border border-indigo-200'}`}>
                <h4 className={`text-md font-semibold mb-1.5 flex items-center ${theme === 'dark' ? 'text-indigo-400' : 'text-indigo-700'}`}>
                    <InformationCircleIcon className="w-5 h-5 mr-1.5"/> Trạng Thái Hiện Tại
                </h4>
                {(knowledgeBase.playerStatus && knowledgeBase.playerStatus.length > 0) ? (
                    <div className="flex flex-wrap gap-2 text-xs">
                        {knowledgeBase.playerStatus.map((status, index) => {
                            let icon;
                            let textColor = theme === 'dark' ? "text-gray-300" : "text-gray-800";
                            let bgColor = theme === 'dark' ? "bg-gray-700/70" : "bg-gray-200/70";
                            switch (status.type?.toLowerCase()) {
                                case 'buff': 
                                    icon = <ShieldCheckIcon className={theme === 'dark' ? "text-green-400" : "text-green-600"}/>; 
                                    textColor = theme === 'dark' ? "text-green-300" : "text-green-700"; 
                                    bgColor = theme === 'dark' ? "bg-green-900/30" : "bg-green-100";
                                    break;
                                case 'debuff': 
                                    icon = <HeartCrackIcon className={theme === 'dark' ? "text-red-400" : "text-red-600"}/>; 
                                    textColor = theme === 'dark' ? "text-red-300" : "text-red-700"; 
                                    bgColor = theme === 'dark' ? "bg-red-900/30" : "bg-red-100";
                                    break;
                                case 'injury': 
                                    icon = <ExclamationTriangleIcon className={theme === 'dark' ? "text-yellow-500" : "text-yellow-600"}/>; 
                                    textColor = theme === 'dark' ? "text-yellow-300" : "text-yellow-700"; 
                                    bgColor = theme === 'dark' ? "bg-yellow-900/30" : "bg-yellow-100";
                                    break;
                                default: 
                                    icon = <InformationCircleIcon className={theme === 'dark' ? "text-blue-400" : "text-blue-600"}/>; 
                                    textColor = theme === 'dark' ? "text-blue-300" : "text-blue-700";
                                    bgColor = theme === 'dark' ? "bg-blue-900/30" : "bg-blue-100";
                                    break;
                            }
                            return (
                                <div key={index} className={`flex items-center p-1.5 rounded-md shadow ${textColor} ${bgColor}`} title={`${status.description} (Ảnh hưởng: ${status.effects || 'Không rõ'}) (Nguồn: ${status.source || 'Không rõ'}) (Thời gian: ${status.duration || 'Không rõ'})`}>
                                    {React.cloneElement(icon, { className: "w-4 h-4 mr-1" })}
                                    {status.name}
                                </div>
                            );
                        })}
                    </div>
                ) : (
                    <p className={`text-xs italic mt-1 ${theme === 'dark' ? 'text-gray-400' : 'text-gray-600'}`}>Không có trạng thái nào.</p>
                )}
            </div>

            {/* Panel 2: Companions */}
            <div className={`p-3 rounded-xl shadow-lg h-full flex flex-col min-h-[100px] transition-colors duration-300 ${theme === 'dark' ? 'bg-gray-800/40 border border-lime-700/50' : 'bg-lime-50 border border-lime-200'}`}>
                <h4 className={`text-md font-semibold mb-2 flex items-center ${theme === 'dark' ? 'text-lime-400' : 'text-lime-700'}`}><UserGroupIcon className="w-5 h-5 mr-1.5"/> Đồng Hành</h4>
                {(knowledgeBase.companions && knowledgeBase.companions.length > 0) ? (
                    <ul className={`space-y-1.5 text-sm overflow-y-auto max-h-24 scrollbar-thin ${theme === 'dark' ? 'scrollbar-thumb-lime-500 scrollbar-track-gray-700' : 'scrollbar-thumb-lime-400 scrollbar-track-lime-100'}`}>
                        {knowledgeBase.companions.map((companionId, index) => {
                            const companionData = knowledgeBase.npcs.find(npc => npc.id === companionId);
                            if (!companionData) return null;
                            return (
                                <li key={index} className={`p-2 rounded-md ${theme === 'dark' ? 'bg-gray-700/70 text-gray-300' : 'bg-lime-100 text-gray-800'}`}>
                                    <strong className={theme === 'dark' ? 'text-lime-300' : 'text-lime-700'}>{companionData.Name}</strong>
                                    <p className={`text-xs truncate ${theme === 'dark' ? 'text-amber-300' : 'text-amber-600'}`} title={`Cảnh giới: ${companionData.realm} (Cấp ${companionData.level})`}>
                                        {companionData.realm} (Cấp {companionData.level})
                                    </p>
                                </li>
                            );
                        })}
                    </ul>
                ) : (
                    <p className={`text-xs italic mt-1 ${theme === 'dark' ? 'text-gray-400' : 'text-gray-600'}`}>Chưa có đồng hành nào.</p>
                )}
            </div>

            {/* Panel 3: Active Quests */}
            <div className={`p-3 rounded-xl shadow-lg h-full flex flex-col min-h-[100px] transition-colors duration-300 ${theme === 'dark' ? 'bg-gray-800/40 border border-yellow-600/50' : 'bg-yellow-50 border border-yellow-200'}`}>
                <h4 className={`text-md font-semibold mb-1.5 flex items-center ${theme === 'dark' ? 'text-yellow-400' : 'text-yellow-700'}`}>
                    <ClipboardDocumentCheckIcon className="w-5 h-5 mr-1.5"/> Nhiệm Vụ Đang Làm
                </h4>
                {(knowledgeBase.quests && knowledgeBase.quests.filter(q => q.status === 'active').length > 0) ? (
                    <div className="flex flex-col gap-2 text-xs">
                        {knowledgeBase.quests.filter(q => q.status === 'active').map((quest, index) => (
                            <div key={index} className={`flex items-center p-1.5 rounded-md shadow cursor-pointer ${theme === 'dark' ? 'bg-yellow-700/30 hover:bg-yellow-700/50 text-yellow-200' : 'bg-yellow-100 hover:bg-yellow-200 text-yellow-800'}`} 
                                title={`${quest.description}\nMục tiêu: ${quest.objectives && quest.objectives.length > 0 ? quest.objectives.map(obj => `${obj.text} (${obj.completed ? 'Xong' : 'Chưa'})`).join(', ') : 'Không có'}`}
                                onClick={() => setShowCharacterInfoModal(true)}
                            >
                            <ClipboardDocumentCheckIcon className={`w-4 h-4 mr-1.5 ${theme === 'dark' ? 'text-yellow-300' : 'text-yellow-600'}`}/> <span className="truncate">{quest.title}</span>
                            </div>
                        ))}
                    </div>
                ) : (
                     <p className={`text-xs italic mt-1 ${theme === 'dark' ? 'text-gray-400' : 'text-gray-600'}`}>Không có nhiệm vụ nào đang hoạt động.</p>
                )}
            </div>
        </div>


        <div className={`flex-grow p-3 md:p-5 rounded-xl shadow-2xl overflow-y-auto mb-3 scrollbar-thin transition-colors duration-300 ${theme === 'dark' ? 'bg-gray-800 scrollbar-thumb-purple-600 scrollbar-track-gray-700' : 'bg-gray-50 scrollbar-thumb-purple-400 scrollbar-track-gray-200'}`} style={{ maxHeight: '60vh', minHeight: '300px' }} id="story-content-area"> 
            <h2 className={`text-lg font-semibold mb-2 ${theme === 'dark' ? 'text-green-400' : 'text-green-700'}`}>Diễn biến câu chuyện:</h2>
            {storyHistory.map((item, index) => (
                <div key={index} className={`story-item mb-3 p-3 rounded-lg shadow-sm transition-colors duration-300
                    ${item.type === 'story' ? (theme === 'dark' ? 'bg-gray-700/80' : 'bg-gray-200') : 
                      item.type === 'user_choice' ? (theme === 'dark' ? 'bg-blue-900/70 text-blue-200 ring-1 ring-blue-700' : 'bg-blue-100 text-blue-800 ring-1 ring-blue-300') : 
                      item.type === 'user_custom_action' ? (theme === 'dark' ? 'bg-indigo-900/70 text-indigo-200 ring-1 ring-indigo-700' : 'bg-indigo-100 text-indigo-800 ring-1 ring-indigo-300') :
                      item.type === 'kobold_story' ? (theme === 'dark' ? 'bg-red-900/60 text-red-200 ring-1 ring-red-700' : 'bg-red-100 text-red-800 ring-1 ring-red-300') :
                      (theme === 'dark' ? 'bg-yellow-800/70 text-yellow-200 ring-1 ring-yellow-700' : 'bg-yellow-100 text-yellow-800 ring-1 ring-yellow-300')}`}>
                    {item.type === 'user_choice' && <p className={`font-semibold ${theme === 'dark' ? 'text-blue-300' : 'text-blue-700'}`}>Ngươi đã chọn:</p>}
                    {item.type === 'user_custom_action' && <p className={`font-semibold ${theme === 'dark' ? 'text-indigo-300' : 'text-indigo-700'}`}>Hành động của ngươi:</p>}
                    {item.type === 'system' && <p className={`font-semibold ${theme === 'dark' ? 'text-yellow-300' : 'text-yellow-700'}`}>Thông báo hệ thống:</p>}
                    <div className={`prose prose-sm max-w-none ${theme === 'dark' ? 'prose-invert text-gray-200' : 'text-gray-800'}`}>{formatStoryText(item.content)}</div>
                </div>
            ))}
            {(isLoading || isProcessingAction) && currentStory === '' && (
                <div className="text-center py-10">
                    <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-purple-400 mx-auto"></div>
                    <p className="mt-3 text-purple-300">AI đang viết tiếp câu chuyện...</p>
                </div>
            )}
            {isCallingKobold && (
                <div className="text-center py-10">
                    <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-red-400 mx-auto"></div>
                    <p className="mt-3 text-red-300">Đang triệu hồi thực thể khác (KoboldAI)...</p>
                </div>
            )}
        </div>

        {!(isLoading || isProcessingAction) && (
            <div className={`p-3 md:p-5 rounded-xl shadow-xl mt-auto transition-colors duration-300 ${theme === 'dark' ? 'bg-gray-800' : 'bg-gray-100'}`}>
                {choices.length > 0 && (
                    <>
                        <h3 className={`text-lg font-semibold mb-3 ${theme === 'dark' ? 'text-green-400' : 'text-green-700'}`}>Lựa chọn của ngươi:</h3>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-3 mb-4">
                            {choices.map((choice, index) => (
                                <button
                                    key={index}
                                    onClick={() => handleChoice(choice)}
                                    className="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-medium py-3 px-4 rounded-lg shadow-md hover:shadow-lg transition-all text-left focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-opacity-75"
                                >
                                    {index + 1}. {choice}
                                </button>
                            ))}
                        </div>
                    </>
                )}
                {gameSettings.allowCustomActionInput && ( 
                    <div>
                        <label htmlFor="customActionInput" className={`block text-md font-medium mb-1 ${theme === 'dark' ? 'text-gray-300' : 'text-gray-700'}`}>Hoặc nhập hành động tùy ý:</label>
                        <div className="flex gap-2">
                            <button onClick={handleSaveGame} className="bg-teal-600 hover:bg-teal-700 text-white font-semibold py-2 px-2.5 rounded-lg shadow-md transition-colors flex items-center text-xs disabled:bg-gray-500">
                            <CharacterSheetIcon /> Lưu vào Tệp
                        </button>
                            <input
                                type="text"
                                id="customActionInput"
                                value={customActionInput}
                                onChange={(e) => setCustomActionInput(e.target.value)}
                                placeholder="Ví dụ: Nhìn xung quanh, Hỏi về chiếc chìa khóa..."
                                className={`flex-grow p-3 border rounded-lg focus:ring-purple-500 focus:border-purple-500 transition-colors duration-300 ${theme === 'dark' ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300 text-black'}`}
                                onKeyPress={(e) => e.key === 'Enter' && handleCustomAction(customActionInput)}
                            />
                             <button
                                onClick={() => handleCustomAction(customActionInput)}
                                disabled={isLoading || isProcessingAction}
                                className="bg-purple-600 hover:bg-purple-700 text-white font-semibold py-3 px-5 rounded-lg shadow-md hover:shadow-lg transition-colors disabled:bg-gray-500"
                            >
                                Gửi
                            </button>
                        </div>
                    </div>
                )}
                 <div className="mt-3 flex flex-col sm:flex-row gap-2 justify-end items-stretch sm:items-center">
                    <button
                        onClick={handleGenerateSuggestedActions}
                        disabled={isGeneratingSuggestedActions || isLoading || isProcessingAction}
                        className="w-full sm:w-auto p-3 bg-teal-600 hover:bg-teal-700 text-white rounded-lg shadow-md disabled:bg-gray-500 flex items-center justify-center text-sm"
                        title="AI Gợi Ý Hành Động"
                    >
                        {isGeneratingSuggestedActions ? <div className="w-5 h-5 border-2 border-t-transparent border-white rounded-full animate-spin mr-2"></div> : <LightBulbIcon className="w-5 h-5 mr-2"/>}
                        AI Gợi Ý
                    </button>
                    <button
                        onClick={toggleTheme}
                        className={`w-full sm:w-auto p-3 rounded-lg shadow-md flex items-center justify-center text-sm transition-colors duration-300 ${theme === 'dark' ? 'bg-gray-600 hover:bg-gray-500 text-white' : 'bg-gray-200 hover:bg-gray-300 text-black'}`}
                        title="Đổi Giao Diện Sáng/Tối"
                    >
                        <PaintBrushIcon className="w-4 h-4 mr-2" />
                        Đổi Giao Diện
                    </button>
                    <button
                        onClick={() => setShowQuickReferenceModal(true)}
                        disabled={isLoading || isProcessingAction}
                        className="w-full sm:w-auto p-3 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg shadow-md disabled:bg-gray-500 flex items-center justify-center text-sm"
                        title="Tra Cứu Nhanh Kỹ Năng, Vật Phẩm, NPC..."
                    >
                        <BookOpenIcon className="w-5 h-5 mr-2"/> Tra Cứu Nhanh
                    </button>
                    <button
                        onClick={() => setShowCraftingModal(true)}
                        disabled={isLoading || isProcessingAction}
                        className="w-full sm:w-auto p-3 bg-orange-600 hover:bg-orange-700 text-white rounded-lg shadow-md disabled:bg-gray-500 flex items-center justify-center text-sm"
                        title="Luyện Đan / Luyện Khí"
                    >
                        <WrenchScrewdriverIcon className="w-5 h-5 mr-2" /> Luyện
                    </button>
                </div>
            </div>
        )}
         {(isLoading || isProcessingAction) && choices.length === 0 && currentStory !== '' && ( 
            <div className="text-center py-5">
                <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-purple-400 mx-auto"></div>
                <p className="mt-2 text-purple-300">Đang tạo lựa chọn...</p>
            </div>
        )}
    </div>
);

const LoadGameModal = ({ savedGames, loadGame, setShowLoadGameModal, setConfirmationModal, userId, setModalMessage }) => (
    <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
      <div className="bg-gray-800 p-6 rounded-xl shadow-2xl w-full max-w-2xl max-h-[85vh] flex flex-col border border-blue-600">
        <h2 className="text-2xl font-semibold text-purple-400 mb-4">Tải Game Đã Lưu</h2>
        {savedGames.length === 0 ? (
          <p className="text-gray-400 text-center py-6">Ngươi chưa có cuộc phiêu lưu nào được lưu lại.</p>
        ) : (
          <div className="overflow-y-auto space-y-3 pr-2 scrollbar-thin scrollbar-thumb-blue-500 scrollbar-track-gray-700">
            {savedGames.map(game => (
              <div key={game.id} className="bg-gray-700 p-4 rounded-lg hover:bg-gray-600/80 transition-colors shadow-md hover:shadow-lg">
                <h3 className="text-lg font-semibold text-green-400 truncate" title={game.settings?.theme}>{game.settings?.theme || "Game Chưa Có Tên"}</h3>
                <p className="text-sm text-gray-300">Nhân vật: {game.settings?.characterName || "N/A"} (Tính cách: {game.settings?.characterPersonality || "Chưa rõ"})</p>
                {game.settings?.useCharacterGoal && game.settings?.characterGoal && (
                    <p className="text-xs text-red-300 truncate" title={`Mục tiêu: ${game.settings.characterGoal}`}>
                        Mục tiêu: {game.settings.characterGoal.substring(0,70)}{game.settings.characterGoal.length > 70 ? "..." : ""}
                    </p>
                )}
                <p className="text-xs text-gray-400">
                  {/* *** DÒNG ĐÃ SỬA LỖI Ở ĐÂY *** */}
                  Lần cập nhật cuối: {game.updatedAt?.toDate ? new Date(game.updatedAt.toDate()).toLocaleString('vi-VN') : "Đang xử lý..."}
                </p>
                 <p className="text-xs text-gray-400">Độ khó: {game.settings?.difficulty || "Không rõ"} {game.settings?.difficultyDescription ? `(${game.settings.difficultyDescription.substring(0,30)}...)` : ""}</p>
                <div className="mt-3 flex space-x-2">
                    <button
                    onClick={() => loadGame(game)}
                    className="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-3 rounded-md text-sm shadow hover:shadow-md transition-all"
                    >
                    Tải Game Này
                    </button>
                    <button
                    onClick={() => {
                        setConfirmationModal({
                            show: true,
                            title: 'Xác Nhận Xóa Game',
                            content: `Bạn có chắc chắn muốn xóa game "${game.settings?.theme || game.id}" không? Hành động này không thể hoàn tác.`,
                            onConfirm: async () => {
                                try {
                                    await deleteDoc(doc(db, `artifacts/${appId}/users/${userId}/games`, game.id));
                                    console.log("Game deleted:", game.id);
                                    setModalMessage({ show: true, title: 'Đã Xóa', content: `Game "${game.settings?.theme || game.id}" đã được xóa.`, type: 'success' });
                                } catch (error) {
                                    console.error("Error deleting game:", error);
                                    setModalMessage({ show: true, title: 'Lỗi Xóa Game', content: `Không thể xóa game: ${error.message}`, type: 'error' });
                                }
                            },
                            confirmText: "Xóa Game",
                            cancelText: "Hủy Bỏ"
                        });
                    }}
                    className="bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-3 rounded-md text-sm shadow hover:shadow-md transition-all"
                    >
                    Xóa
                    </button>
                </div>
              </div>
            ))}
          </div>
        )}
        <button
          onClick={() => setShowLoadGameModal(false)}
          className="mt-6 w-full bg-gray-600 hover:bg-gray-500 text-white font-semibold py-2 px-4 rounded-lg shadow-md transition-colors"
        >
          Đóng
        </button>
      </div>
    </div>
  );

const MessageModal = ({ show, title, content, type, onClose }) => {
    if (!show) return null;
    let titleColor = 'text-blue-400';
    let IconComponent = InformationCircleIcon;
    if (type === 'error') {
        titleColor = 'text-red-400';
        IconComponent = () => <ExclamationTriangleIcon className="w-6 h-6 mr-2 text-red-400"/>;
    } else if (type === 'success') {
        titleColor = 'text-green-400';
        IconComponent = CheckIcon;
    }

    return (
      <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-[120]"> 
        <div className="bg-gray-800 p-6 rounded-xl shadow-2xl w-full max-w-md border border-gray-700">
          <div className="flex items-center mb-4">
            <IconComponent />
            <h3 className={`text-xl font-semibold ${titleColor}`}>{title}</h3>
          </div>
          <p className="text-gray-300 mb-6 whitespace-pre-line">{content}</p>
          <button
            onClick={onClose}
            className="w-full bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2.5 px-4 rounded-lg shadow hover:shadow-md transition-all"
          >
            Đã hiểu
          </button>
        </div>
      </div>
    );
};

const ConfirmationModal = ({ show, title, content, onConfirm, onCancel, confirmText = "Xác nhận", cancelText = "Hủy", setConfirmationModal: localSetConfirmationModal }) => {
    if (!show) return null;
    return (
      <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-[100]"> 
        <div className="bg-gray-800 p-6 rounded-xl shadow-2xl w-full max-w-md border border-yellow-700">
          <div className="flex items-center mb-4">
            <ExclamationTriangleIcon /> 
            <h3 className="text-xl font-semibold text-yellow-400">{title}</h3>
          </div>
          <p className="text-gray-300 mb-6 whitespace-pre-line">{content}</p>
          <div className="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-3">
            <button
              onClick={() => { onConfirm(); localSetConfirmationModal(prev => ({ ...prev, show: false })); }}
              className={`flex-1 text-white font-semibold py-2.5 px-4 rounded-lg shadow hover:shadow-md transition-all ${confirmText.toLowerCase().includes("xóa") || confirmText.toLowerCase().includes("delete") ? 'bg-red-600 hover:bg-red-700' : 'bg-green-600 hover:bg-green-700'}`}
            >
              {confirmText}
            </button>
            <button
              onClick={() => { if (onCancel) onCancel(); localSetConfirmationModal(prev => ({ ...prev, show: false })); }}
              className="flex-1 bg-gray-600 hover:bg-gray-500 text-white font-semibold py-2.5 px-4 rounded-lg shadow hover:shadow-md transition-all"
            >
              {cancelText}
            </button>
          </div>
        </div>
      </div>
    );
  };
{/* === BẮT ĐẦU ĐOẠN CODE CẦN THÊM === */}
const Notification = ({ notification, onRemove }) => {
    const baseClasses = "flex items-center w-full max-w-xs p-4 mb-4 text-gray-200 bg-gray-800 rounded-lg shadow-lg border-l-4 transition-all duration-300 transform animate-fade-in";
    const typeClasses = {
        success: 'border-green-500',
        error: 'border-red-500',
        info: 'border-blue-500',
        warning: 'border-yellow-500',
    };
    const Icon = {
        success: () => <CheckIcon className="w-5 h-5 text-green-400"/>,
        error: () => <ExclamationTriangleIcon className="w-5 h-5 text-red-400"/>,
        info: () => <InformationCircleIcon className="w-5 h-5 text-blue-400"/>,
        warning: () => <ExclamationTriangleIcon className="w-5 h-5 text-yellow-400"/>,
    }[notification.type];

    return (
        <div className={`${baseClasses} ${typeClasses[notification.type]}`} role="alert">
            <div className="inline-flex items-center justify-center flex-shrink-0 w-8 h-8 rounded-lg">
                <Icon />
            </div>
            <div className="ml-3 text-sm font-normal">{notification.message}</div>
            <button type="button" onClick={() => onRemove(notification.id)} className="ml-auto -mx-1.5 -my-1.5 bg-gray-800 text-gray-400 hover:text-white rounded-lg focus:ring-2 focus:ring-gray-300 p-1.5 hover:bg-gray-700 inline-flex items-center justify-center h-8 w-8">
                &times;
            </button>
        </div>
    );
};
{/* === KẾT THÚC ĐOẠN CODE CẦN THÊM === */}
const SuggestionsModal = ({ show, title, suggestions, onSelect, onClose, isLoading }) => {
    if (!show) return null;
    return (
        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-[70]">
            <div className="bg-gray-800 p-6 rounded-xl shadow-2xl w-full max-w-md border border-pink-700">
                <h3 className="text-xl font-semibold text-pink-400 mb-4 flex items-center">
                    <LightBulbIcon /> {title}
                </h3>
                {isLoading ? (
                    <div className="flex justify-center items-center h-24">
                        <div className="w-8 h-8 border-4 border-t-transparent border-pink-400 rounded-full animate-spin"></div>
                        <p className="ml-3 text-gray-300">Đang tải gợi ý từ Đại Năng...</p>
                    </div>
                ) : suggestions.length > 0 ? (
                    <ul className="space-y-2 max-h-60 overflow-y-auto scrollbar-thin scrollbar-thumb-pink-500 scrollbar-track-gray-700">
                        {suggestions.map((suggestion, index) => (
                            <li key={index}>
                                <button
                                    onClick={() => { onSelect(suggestion); onClose(); }}
                                    className="w-full text-left p-3 bg-gray-700 hover:bg-gray-600/80 rounded-md text-gray-200 transition-colors shadow hover:shadow-md"
                                >
                                    {suggestion}
                                </button>
                            </li>
                        ))}
                    </ul>
                ) : (
                    <p className="text-gray-400 text-center py-4">Không có gợi ý nào được tạo ra. Hãy thử lại hoặc tự sáng tạo!</p>
                )}
                <button
                    onClick={onClose}
                    className="mt-6 w-full bg-gray-600 hover:bg-gray-500 text-white font-semibold py-2 px-4 rounded-lg"
                >
                    Đóng
                </button>
            </div>
        </div>
    );
}
// --- COMPONENT MỚI CHO CỬA SỔ LUYỆN ĐỒ ---
const CraftingModal = ({ 
    show,
     onClose, inventory, handleCraftItemDrop, handleCraftItemReturn,
      handleStartCrafting, isProcessingAction, alchemyMaterials, 
      setAlchemyMaterials, smithingMaterials, setSmithingMaterials }) => {
    const [craftingTab, setCraftingTab] = useState('alchemy'); // 'alchemy' or 'smithing'
    
    
    const handleDragStart = (e, item) => {
        e.dataTransfer.setData("application/json", JSON.stringify(item));
    };

    // Thay đổi hàm handleDrop hiện có
    const handleDrop = (e, area) => {
        e.preventDefault();
        const item = JSON.parse(e.dataTransfer.getData("application/json"));
        // KHÔNG CẬP NHẬT TRẠNG THÁI CỤC BỘ NỮA, HÃY GỌI PROPS
        // if (area === 'alchemy') {
        //     setAlchemyMaterials(prev => [...prev, item]);
        // } else {
        //     setSmithingMaterials(prev => [...prev, item]);
        // }
        handleCraftItemDrop(item, area); // Gọi hàm từ App, truyền item và loại lò
    };

    const handleDragOver = (e) => {
        e.preventDefault();
    };
    
    // Thay đổi hàm handleReturn hiện có
const handleReturn = (item, area) => {
    // KHÔNG CẬP NHẬT TRẠNG THÁI CỤC BỘ NỮA, HÃY GỌI PROPS
    // if (area === 'alchemy') {
    //     setAlchemyMaterials(prev => prev.filter(i => i.id !== item.id));
    // } else {
    //     setSmithingMaterials(prev => prev.filter(i => i.id !== item.id));
    // }
    handleCraftItemReturn(item, area); // Gọi hàm từ App, truyền item và loại lò
};

    // Hàm render danh sách vật phẩm trong balo
    const renderInventory = () => (
        <div className="bg-gray-800/50 p-3 rounded-lg border border-gray-600 h-full">
            <h4 className="text-lg font-semibold text-gray-300 mb-2">Balo Đồ (Vật liệu)</h4>
            <div className="overflow-y-auto h-[350px] space-y-2 pr-2 scrollbar-thin scrollbar-thumb-purple-500 scrollbar-track-gray-700">
                {inventory.length > 0 ? inventory.map(item => (
                    <div
                        key={item.id}
                        draggable
                        onDragStart={(e) => handleDragStart(e, item)}
                        className="p-2 bg-gray-700 rounded-md cursor-grab active:cursor-grabbing border border-transparent hover:border-purple-500 transition-all"
                    >
                        <p className="font-semibold text-purple-300">{item.Name}</p>
                        <p className="text-xs text-gray-400 truncate" title={item.Description}>{item.Description}</p>
                    </div>
                )) : (
                    <p className="text-gray-500 italic text-center mt-4">Balo không có vật liệu nào.</p>
                )}
            </div>
        </div>
    );

    // Hàm render khu vực lò luyện/rèn
    const renderCraftingArea = (type, materials) => {
        const title = type === 'alchemy' ? 'Lò Luyện Đan' : 'Lò Rèn';
        const icon = type === 'alchemy' ? <FireIcon className="w-24 h-24 text-gray-600 group-hover:text-orange-500 transition-colors" /> : <WrenchScrewdriverIcon className="w-24 h-24 text-gray-600 group-hover:text-sky-500 transition-colors" />;

        return (
            <div className="bg-gray-800/50 p-3 rounded-lg border border-gray-600 h-full flex flex-col">
                <h4 className="text-lg font-semibold text-gray-300 mb-2">{title}</h4>
                <div 
                    onDrop={(e) => handleDrop(e, type)} 
                    onDragOver={handleDragOver}
                    className="flex-grow bg-gray-900/70 rounded-lg border-2 border-dashed border-gray-600 flex flex-col items-center justify-center p-4 group transition-all"
                >
                    {materials.length === 0 ? (
                        <>
                            {icon}
                            <p className="text-gray-500 mt-2">Kéo vật liệu từ balo vào đây</p>
                        </>
                    ) : (
                        <div className="w-full h-full overflow-y-auto space-y-2 pr-2 scrollbar-thin scrollbar-thumb-gray-500 scrollbar-track-gray-800">
                            {materials.map(item => ( // Đảm bảo dùng 'materials' ở đây
                                <div key={item.id} title="Nhấn để trả lại Balo" onClick={() => handleReturn(item, type)} className="p-2 bg-gray-600 rounded-md cursor-pointer border border-transparent hover:border-red-500">
                                    <p className="font-semibold text-green-300">{item.Name}</p>
                                </div>
                            ))}
                        </div>
                    )}
                </div>
            </div>
        );
    };

    if (!show) return null;

    return (
        <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center p-4 z-50 animate-fade-in-up">
            <div className="bg-gradient-to-br from-gray-900 via-gray-800 to-gray-900 p-6 rounded-2xl shadow-2xl w-full max-w-4xl border border-purple-700/60">
                <div className="flex justify-between items-center mb-4">
                    <div className="flex items-center gap-2">
                        <button onClick={() => setCraftingTab('alchemy')} className={`px-4 py-2 text-sm font-medium rounded-md transition-colors duration-200 flex items-center gap-2 ${craftingTab === 'alchemy' ? 'bg-orange-600 text-white shadow-lg' : 'text-gray-300 hover:bg-gray-700'}`}>
                            <FireIcon /> Luyện Đan
                        </button>
                        <button onClick={() => setCraftingTab('smithing')} className={`px-4 py-2 text-sm font-medium rounded-md transition-colors duration-200 flex items-center gap-2 ${craftingTab === 'smithing' ? 'bg-sky-600 text-white shadow-lg' : 'text-gray-300 hover:bg-gray-700'}`}>
                            <WrenchScrewdriverIcon /> Luyện Khí
                        </button>
                    </div>
                     <button onClick={onClose} className="text-gray-400 hover:text-white">&times; Đóng</button>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 h-[400px]">
                    {renderInventory()}
                    {craftingTab === 'alchemy' && renderCraftingArea('alchemy', alchemyMaterials)}
                    {craftingTab === 'smithing' && renderCraftingArea('smithing', smithingMaterials)}
                </div>
                 <div className="mt-6 flex justify-end">
                    <button
                        onClick={() => {
                            const materials = craftingTab === 'alchemy' ? alchemyMaterials : smithingMaterials;
                            if (materials.length > 0) {
                                handleStartCrafting(craftingTab, materials);
                            }
                        }}
                        disabled={isProcessingAction || (craftingTab === 'alchemy' ? alchemyMaterials.length === 0 : smithingMaterials.length === 0)}
                        className="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-8 rounded-lg shadow-lg transition-transform transform hover:scale-105 disabled:bg-gray-500 disabled:cursor-not-allowed disabled:scale-100"
                    >
                        {isProcessingAction ? 'Đang Xử Lý...' : `Bắt Đầu ${craftingTab === 'alchemy' ? 'Luyện Đan' : 'Luyện Khí'}`}
                    </button>
                 </div>
            </div>
        </div>
    );
};
// --- COMPONENT MỚI CHO GIAO DIỆN TRANG BỊ NHÂN VẬT ---
// --- COMPONENT MỚI CHO GIAO DIỆN TRANG BỊ NHÂN VẬT ---
const CharacterEquipModal = ({ show, onClose, inventory, equippedItems, playerSkills, handleEquipItem, handleUnequipItem, equippedGongfa }) => { // THÊM equippedGongfa VÀO ĐÂY
    if (!show) return null;

    // Helper function for drag over event
    const handleDragOver = (e) => {
        e.preventDefault(); // Allow drop
    };

    // Helper function for drop event on equip slots
    const handleDropOnEquipSlot = (e, slotType) => {
        e.preventDefault();
        const itemString = e.dataTransfer.getData("application/json");
        const item = JSON.parse(itemString);

        // Basic validation (more detailed validation in handleEquipItem)
        if (item && item.Equippable) {
            handleEquipItem(item, slotType);
        } else {
            // Có thể hiển thị thông báo lỗi nếu item không thể trang bị
            console.log("Vật phẩm này không thể trang bị được.");
        }
    };

    // Helper function for drag start from inventory
    const handleDragStartFromInventory = (e, item) => {
        e.dataTransfer.setData("application/json", JSON.stringify(item));
    };

    // Helper component for an equip slot
    const EquipSlot = ({ type, item, icon: Icon, onDrop, onDragOver, onClick }) => (
        <div
            className="relative w-20 h-20 bg-gray-700 rounded-lg flex flex-col items-center justify-center border-2 border-gray-600 hover:border-blue-500 transition-colors"
            onDrop={onDrop}
            onDragOver={onDragOver}
            onClick={onClick}
            title={item ? `<span class="math-inline">\{item\.Name\}\\n</span>{item.Description}` : `Ô ${type}`}
        >
            {item ? (
                <>
                    <p className="text-sm font-semibold text-white truncate w-full px-1 text-center">{item.Name}</p>
                    <p className="text-xs text-gray-400">{item.Type}</p>
                    <span className="absolute bottom-1 right-1 text-xs text-green-300">
                       {item.StatsBonus ? item.StatsBonus.split(',')[0] : ''} {/* Hiển thị bonus đầu tiên */}
                    </span>
                </>
            ) : (
                <Icon className="w-10 h-10 text-gray-500" />
            )}
            <p className="text-xs text-gray-400 mt-1">{type.charAt(0).toUpperCase() + type.slice(1)}</p>
        </div>
    );

    return (
        <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center p-4 z-50 animate-fade-in-up">
            <div className="relative bg-gradient-to-br from-gray-900 via-gray-800 to-gray-900 p-6 rounded-2xl shadow-2xl w-full max-w-5xl border border-blue-700/60 flex flex-col md:flex-row gap-6 max-h-[90vh] overflow-y-auto">
                {/* Nút Đóng Chung cho toàn bộ Modal */}
                <button onClick={onClose} className="absolute top-3 right-3 text-gray-400 hover:text-white text-3xl font-semibold z-10">&times;</button>

                {/* Header cũ, giờ chỉ còn tiêu đề chính cho màn hình nhỏ, bỏ nút đóng ở đây */}
                <div className="flex justify-center items-center mb-4 md:hidden"> {/* Bỏ justify-between */}
                    <h2 className="text-2xl font-bold text-blue-400 flex items-center">
                        <ArmorIcon className="w-6 h-6 mr-2 text-blue-400"/> Giao Diện Trang Bị Nhân Vật
                    </h2>
                    {/* <button onClick={onClose} className="text-gray-400 hover:text-white text-lg font-semibold">&times; Đóng</button> <-- XÓA NÚT NÀY */}
                </div>

                {/* Left Panel: Character and Equip Slots */}
                <div className="flex-1 bg-gray-800/60 p-4 rounded-xl border border-gray-700 flex flex-col items-center">
                    <h3 className="text-xl font-bold text-blue-300 mb-4 flex items-center"><ArmorIcon className="w-5 h-5 mr-2"/> Trang Bị</h3>

                    {/* Character Image Placeholder */}
                    <div className="w-32 h-32 bg-gray-700 rounded-full flex items-center justify-center mb-6 border-4 border-blue-500 shadow-lg">
                        <UserCircleIcon className="w-24 h-24 text-gray-500" />
                    </div>

                    {/* Equip Slots Grid */}
                    <div className="grid grid-cols-3 gap-3 mb-6">
                        <div className="col-span-3 flex justify-center">
                            <EquipSlot
                                type="head"
                                item={equippedItems.head}
                                icon={HelmetIcon}
                                onDrop={(e) => handleDropOnEquipSlot(e, 'head')}
                                onDragOver={handleDragOver}
                                onClick={() => equippedItems.head && handleUnequipItem(equippedItems.head, 'head')}
                            />
                        </div>
                        <EquipSlot
                            type="hands"
                            item={equippedItems.hands}
                            icon={GloveIcon}
                            onDrop={(e) => handleDropOnEquipSlot(e, 'hands')}
                            onDragOver={handleDragOver}
                            onClick={() => equippedItems.hands && handleUnequipItem(equippedItems.hands, 'hands')}
                        />
                        <EquipSlot
                            type="body"
                            item={equippedItems.body}
                            icon={ChestPlateIcon}
                            onDrop={(e) => handleDropOnEquipSlot(e, 'body')}
                            onDragOver={handleDragOver}
                            onClick={() => equippedItems.body && handleUnequipItem(equippedItems.body, 'body')}
                        />
                        <EquipSlot
                            type="feet"
                            item={equippedItems.feet}
                            icon={BootsIcon}
                            onDrop={(e) => handleDropOnEquipSlot(e, 'feet')}
                            onDragOver={handleDragOver}
                            onClick={() => equippedItems.feet && handleUnequipItem(equippedItems.feet, 'feet')}
                        />
                        <div className="col-span-3 flex justify-center">
                            <EquipSlot
                                type="weapon"
                                item={equippedItems.weapon}
                                icon={SwordIcon}
                                onDrop={(e) => handleDropOnEquipSlot(e, 'weapon')}
                                onDragOver={handleDragOver}
                                onClick={() => equippedItems.weapon && handleUnequipItem(equippedItems.weapon, 'weapon')}
                            />
                        </div>
                        <div className="col-span-3 flex justify-around w-full">
                            <EquipSlot
                                type="accessory1"
                                item={equippedItems.accessory1}
                                icon={RingIcon}
                                onDrop={(e) => handleDropOnEquipSlot(e, 'accessory1')}
                                onDragOver={handleDragOver}
                                onClick={() => equippedItems.accessory1 && handleUnequipItem(equippedItems.accessory1, 'accessory1')}
                            />
                            <EquipSlot
                                type="accessory2"
                                item={equippedItems.accessory2}
                                icon={RingIcon}
                                onDrop={(e) => handleDropOnEquipSlot(e, 'accessory2')}
                                onDragOver={handleDragOver}
                                onClick={() => equippedItems.accessory2 && handleUnequipItem(equippedItems.accessory2, 'accessory2')}
                            />
                        </div>
                    </div>

                    {/* Gongfa/Skills Equip Slots */}
                    <h3 className="text-xl font-bold text-yellow-300 mb-3 flex items-center"><BookOpenIcon className="w-5 h-5 mr-2"/> Công Pháp</h3>
                    <div className="flex justify-center gap-3 mb-6 w-full max-w-xs"> {/* Dùng flexbox thay vì grid để căn giữa 2 slot */}
                        <EquipSlot
                            type="main-gongfa"
                            item={equippedGongfa.main}
                            icon={BookOpenIcon}
                            onDrop={(e) => handleDropOnEquipSlot(e, 'main')}
                            onDragOver={handleDragOver}
                            onClick={() => equippedGongfa.main && handleUnequipItem(equippedGongfa.main, 'main')}
                        />
                        <EquipSlot
                            type="sub-gongfa-1"
                            item={equippedGongfa.sub1}
                            icon={BookOpenIcon}
                            onDrop={(e) => handleDropOnEquipSlot(e, 'sub1')}
                            onDragOver={handleDragOver}
                            onClick={() => equippedGongfa.sub1 && handleUnequipItem(equippedGongfa.sub1, 'sub1')}
                        />
                        {/* Thêm các slot sub-gongfa khác nếu cần (ví dụ: sub-gongfa-2) */}
                    </div>
                </div>

                {/* Right Panel: Inventory */}
                <div className="flex-1 bg-gray-800/60 p-4 rounded-xl border border-gray-700 flex flex-col">
                    <h3 className="text-xl font-bold text-purple-300 mb-4 flex items-center"><BackpackIcon className="w-5 h-5 mr-2"/> Balo Đồ</h3>
                    <div className="flex-grow overflow-y-auto pr-2 space-y-2 scrollbar-thin scrollbar-thumb-purple-500 scrollbar-track-gray-700">
                        {inventory.length > 0 ? inventory.map(item => (
                            <div
                                key={item.id}
                                draggable={item.Equippable} // Chỉ cho phép kéo nếu vật phẩm có thể trang bị
                                onDragStart={(e) => handleDragStartFromInventory(e, item)}
                                className={`p-2 rounded-md border transition-all ${item.Equippable ? 'bg-gray-700 cursor-grab hover:border-blue-500 active:cursor-grabbing' : 'bg-gray-700/50 cursor-not-allowed border-gray-600'}`}
                                title={item.Equippable ? `Kéo để trang bị: ${item.Name}` : `${item.Name} (Không thể trang bị)`}
                            >
                                <p className="font-semibold text-purple-300">{item.Name}</p>
                                <p className="text-xs text-gray-400">{item.Description}</p>
                                {item.StatsBonus && <p className="text-xs text-green-300">Bonus: {item.StatsBonus}</p>}
                            </div>
                        )) : (
                            <p className="text-gray-500 italic text-center mt-4">Balo không có vật phẩm nào có thể trang bị.</p>
                        )}
                    </div>
                </div>

                {/* Footer / Close Button */}
                
            </div>
        </div>
    );
};
// --- COMPONENT MỚI CHO CỬA SỔ THAM CHIẾU NHANH ---
const QuickReferenceModal = ({ show, onClose, knowledge, onSelectForChat }) => {
    if (!show) return null;

    const [activeTab, setActiveTab] = useState('skills'); // 'skills', 'items', 'npcs'
    const [searchTerm, setSearchTerm] = useState('');

    const filteredSkills = knowledge.playerSkills.filter(skill =>
        skill.Name?.toLowerCase().includes(searchTerm.toLowerCase()) ||
        skill.Description?.toLowerCase().includes(searchTerm.toLowerCase())
    );

    const filteredInventory = knowledge.inventory.filter(item =>
        item.Name?.toLowerCase().includes(searchTerm.toLowerCase()) ||
        item.Description?.toLowerCase().includes(searchTerm.toLowerCase())
    );

    const allEquippedItems = Object.values(knowledge.equippedItems).filter(Boolean);
    const allEquippedGongfa = Object.values(knowledge.equippedGongfa).filter(Boolean);
    const combinedItems = [...filteredInventory, ...allEquippedItems]; // Có thể cần lọc trùng lặp nếu item trong balo và trang bị là cùng 1 ID, nhưng thường thì không
    const uniqueCombinedItems = Array.from(new Map(combinedItems.map(item => [item.id, item])).values());


    const filteredNpcs = knowledge.npcs.filter(npc =>
        npc.Name?.toLowerCase().includes(searchTerm.toLowerCase()) ||
        npc.Description?.toLowerCase().includes(searchTerm.toLowerCase()) ||
        npc.Personality?.toLowerCase().includes(searchTerm.toLowerCase())
    );

    const renderSkillsTab = () => (
        <div className="space-y-3">
            {filteredSkills.length > 0 ? filteredSkills.map(skill => (
                <div 
                    key={skill.id} 
                    className="bg-gray-700/60 p-3 rounded-lg border border-gray-600 cursor-pointer hover:bg-gray-600 transition-colors"
                    onClick={() => { onSelectForChat(skill.Name); onClose(); }} // Gọi hàm callback và đóng modal
                >
                    <p className="font-semibold text-yellow-300">{skill.Name} ({skill.Type})</p>
                    <p className="text-sm text-gray-300">{skill.Description}</p>
                    <p className="text-xs text-gray-400">Mana: {skill.manaCost}, Hồi chiêu: {skill.cooldown} lượt, Hiệu ứng: {skill.effect}</p>
                </div>
            )) : (
                <p className="text-gray-400 italic text-center">Không tìm thấy kỹ năng nào.</p>
            )}
        </div>
    );

    const renderItemsTab = () => (
        <div className="space-y-3">
            <h4 className="text-md font-semibold text-purple-300 mb-2">Vật Phẩm Đang Trang Bị:</h4>
            {allEquippedItems.length > 0 || allEquippedGongfa.length > 0 ? (
                <>
                    {allEquippedItems.length > 0 && allEquippedItems.map(item => (
                        <div 
                            key={item.id} 
                            className="bg-gray-700/60 p-3 rounded-lg border border-blue-500 cursor-pointer hover:bg-gray-600 transition-colors"
                            onClick={() => { onSelectForChat(item.Name); onClose(); }} // Gọi hàm callback và đóng modal
                        >
                            <p className="font-semibold text-blue-300">{item.Name} (Đang Trang Bị: {item.Slot})</p>
                            <p className="text-sm text-gray-300">{item.Description}</p>
                            {item.StatsBonus && <p className="text-xs text-green-300">Bonus: {item.StatsBonus}</p>}
                        </div>
                    ))}
                    {allEquippedGongfa.length > 0 && allEquippedGongfa.map(skill => (
                        <div key={skill.id} className="bg-gray-700/60 p-3 rounded-lg border border-yellow-500">
                            <p className="font-semibold text-yellow-300">{skill.Name} (Công Pháp: {skill.EquipSlot === 'main' ? 'Chính' : 'Phụ'})</p>
                            <p className="text-sm text-gray-300">{skill.Description}</p>
                            <p className="text-xs text-gray-400">Hiệu ứng: {skill.effect}</p>
                        </div>
                    ))}
                </>
            ) : (
                <p className="text-gray-400 italic text-center">Chưa có vật phẩm/công pháp nào được trang bị.</p>
            )}
            <h4 className="text-md font-semibold text-purple-300 mb-2 mt-4">Vật Phẩm Trong Balo:</h4>
            {filteredInventory.length > 0 ? filteredInventory.map(item => (
                <div 
                    key={item.id} 
                    className="bg-gray-700/60 p-3 rounded-lg border border-gray-600 cursor-pointer hover:bg-gray-600 transition-colors"
                    onClick={() => { onSelectForChat(item.Name); onClose(); }} // Gọi hàm callback và đóng modal
                >
                    <p className="font-semibold text-purple-300">{item.Name} ({item.Type})</p>
                    <p className="text-sm text-gray-300">{item.Description}</p>
                    {item.StatsBonus && <p className="text-xs text-green-300">Bonus: {item.StatsBonus}</p>}
                    {item.Usable && <p className="text-xs text-cyan-300">Có thể dùng.</p>}
                    {item.Consumable && typeof item.Uses === 'number' && <p className="text-xs text-red-300">Còn {item.Uses} lần dùng.</p>}
                </div>
            )) : (
                <p className="text-gray-400 italic text-center">Balo trống hoặc không tìm thấy vật phẩm.</p>
            )}
        </div>
    );

    const renderNpcsTab = () => (
        <div className="space-y-3">
            {filteredNpcs.length > 0 ? filteredNpcs.map(npc => (
                <div 
                    key={npc.id} 
                    className="bg-gray-700/60 p-3 rounded-lg border border-gray-600 cursor-pointer hover:bg-gray-600 transition-colors"
                    onClick={() => { onSelectForChat(npc.Name); onClose(); }} // Gọi hàm callback và đóng modal
                >
                    <p className="font-semibold text-sky-300">{npc.Name} ({npc.Personality})</p>
                    <p className="text-sm text-gray-300">{npc.Description}</p>
                    <p className="text-xs text-gray-400">HP: {npc.HP}, ATK: {npc.ATK}, Thái độ: {npc.Stance}</p>
                    {npc.statuses && npc.statuses.length > 0 && (
                        <p className="text-xs text-red-300">Trạng thái: {npc.statuses.map(s => s.name).join(', ')}</p>
                    )}
                </div>
            )) : (
                <p className="text-gray-400 italic text-center">Không tìm thấy NPC nào.</p>
            )}
        </div>
    );

    return (
        <div className="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center p-4 z-50 animate-fade-in-up">
            <div className="bg-gradient-to-br from-gray-900 via-gray-800 to-gray-900 p-6 rounded-2xl shadow-2xl w-full max-w-2xl border border-indigo-700/60 flex flex-col max-h-[90vh] overflow-hidden"> {/* overflow-hidden để scrollbar không bị trùng */}
                {/* Header */}
                <div className="flex justify-between items-center mb-4">
                    <h2 className="text-2xl font-bold text-indigo-400 flex items-center">
                        <BookOpenIcon className="w-6 h-6 mr-2 text-indigo-400"/> Tra Cứu Nhanh
                    </h2>
                    <button onClick={onClose} className="text-gray-400 hover:text-white text-lg font-semibold">&times; Đóng</button>
                </div>

                {/* Tab Navigation */}
                <div className="flex border-b border-gray-700 mb-4">
                    <TabButton label="Kỹ Năng" isActive={activeTab === 'skills'} onClick={() => { setActiveTab('skills'); setSearchTerm(''); }} />
                    <TabButton label="Vật Phẩm" isActive={activeTab === 'items'} onClick={() => { setActiveTab('items'); setSearchTerm(''); }} />
                    <TabButton label="NPCs" isActive={activeTab === 'npcs'} onClick={() => { setActiveTab('npcs'); setSearchTerm(''); }} />
                </div>

                {/* Search Bar */}
                <div className="mb-4">
                    <input
                        type="text"
                        placeholder={`Tìm kiếm trong ${activeTab === 'skills' ? 'Kỹ Năng' : activeTab === 'items' ? 'Vật Phẩm' : 'NPCs'}...`}
                        className="w-full p-2 bg-gray-700 border border-gray-600 rounded-md text-white focus:ring-indigo-500 focus:border-indigo-500"
                        value={searchTerm}
                        onChange={(e) => setSearchTerm(e.target.value)}
                    />
                </div>

                {/* Content Area */}
                <div className="flex-grow overflow-y-auto pr-2 scrollbar-thin scrollbar-thumb-indigo-500 scrollbar-track-gray-700">
                    {activeTab === 'skills' && renderSkillsTab()}
                    {activeTab === 'items' && renderItemsTab()}
                    {activeTab === 'npcs' && renderNpcsTab()}
                </div>

                {/* Footer / Close Button */}
                <button
                    onClick={onClose}
                    className="mt-6 w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 px-8 rounded-lg shadow-lg transition-transform transform hover:scale-105"
                >
                    Xong
                </button>
            </div>
        </div>
    );
};
const Tooltip = ({ content }) => {
    const [show, setShow] = useState(false);
    return (
        <div className="relative flex items-center ml-2">
            <button
                type="button"
                onMouseEnter={() => setShow(true)}
                onMouseLeave={() => setShow(false)}
                onClick={(e) => { e.preventDefault(); setShow(!show); }} // Thêm onClick để hoạt động trên mobile
                className="cursor-pointer text-gray-400 hover:text-white"
            >
                <InformationCircleIcon className="w-5 h-5" />
            </button>
            {show && (
                <div className="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 w-72 p-3 bg-gray-900 border border-purple-500 text-white text-xs rounded-lg shadow-lg z-50">
                    {content}
                     <div className="absolute top-full left-1/2 -translate-x-1/2 w-0 h-0 border-x-8 border-x-transparent border-t-8 border-t-gray-900"></div> {/* Mũi tên chỉ xuống */}
                </div>
            )}
        </div>
    );
};
// *** BẮT ĐẦU CODE MỚI: Hằng số & Logic Tính toán Chỉ số (PHIÊN BẢN NÂNG CẤP) ***

// Định nghĩa các bậc Thiên Phú và hệ số sức mạnh tương ứng.
// Định nghĩa các bậc Thiên Phú và hệ số sức mạnh tương ứng.
const TALENT_TIERS = [
    { name: 'Phàm Thể', multiplier: 1.0 },
    { name: 'Tạp Linh Căn', multiplier: 1.1 },
    { name: 'Ngụy Linh Căn', multiplier: 1.2 },
    { name: 'Chân Linh Căn', multiplier: 1.3 },
    { name: 'Thiên Linh Căn', multiplier: 1.5 },
    { name: 'Dị Linh Căn', multiplier: 1.6 },
    { name: 'Bẩm Sinh Đạo Thai', multiplier: 3.8 },
    { name: 'Hoang Cổ Thánh Thể', multiplier: 6.2 },
    { name: 'Tiên Thiên Đạo Thể', multiplier: 13.5 },
    { name: 'Thiên Đạo Thể', multiplier: 45.0 }
];

// Các hằng số cơ bản để cân bằng game (CÔNG THỨC MỚI)
const STAT_CONSTANTS = {
    BASE_HP: 50,
    BASE_ATK: 5,
    LEVEL_GROWTH_RATE: 1.08,
    REALM_POWER_SCALE: 4.5,
    LEVELS_PER_REALM: 10 // THÊM MỚI: Mỗi cảnh giới có 10 cấp độ
};

/**
 * Tính toán chỉ số HP và ATK cơ bản của một thực thể (NPC hoặc Player).
 * Công thức này sử dụng tăng trưởng theo cấp số mũ và có giới hạn sức mạnh theo cảnh giới.
 * @param {object} entity - Đối tượng NPC hoặc Player, cần có: level, realm, cultivationSystem, talentTier.
 * @param {object} worldKnowledge - Toàn bộ kho tri thức thế giới để tra cứu cảnh giới.
 * @returns {{hp: number, atk: number}} - Chỉ số HP và ATK cơ bản đã tính toán.
 */
const calculateBaseStats = (entity, worldKnowledge) => {
    // Đảm bảo có giá trị mặc định để tránh lỗi
    const { level = 1, realm = "Phàm Nhân", cultivationSystem, talentTier = "Phàm Thể" } = entity;

    // 1. Lấy hệ số Thiên Phú
    const talent = TALENT_TIERS.find(t => t.name === talentTier) || { multiplier: 1.0 };
    const talentMultiplier = talent.multiplier;

    // 2. Lấy chỉ số cảnh giới (realmIndex) và tính cấp độ tối đa của cảnh giới đó
    let realmIndex = 0;
    const system = worldKnowledge.cultivationSystems.find(s => s.systemName === cultivationSystem);
    if (system && system.realms) {
        const foundIndex = system.realms.indexOf(realm);
        if (foundIndex !== -1) {
            realmIndex = foundIndex;
        }
    }
    
    // Cấp độ tối đa của cảnh giới này (ví dụ: Kim Đan index 3 -> max level 40)
    const maxLevelForCurrentRealm = (realmIndex + 1) * STAT_CONSTANTS.LEVELS_PER_REALM;
    
    // 3. Áp dụng giới hạn: Chỉ số chỉ được tính toán dựa trên level thực tế NẾU nó không vượt quá giới hạn.
    // Nếu level thực tế vượt quá giới hạn (ví dụ: người chơi bị kẹt ở Kim Đan nhưng đã lên level 45),
    // thì chỉ số vẫn chỉ được tính ở mức level 40.
    const effectiveLevel = Math.min(level, maxLevelForCurrentRealm);

    // 4. Áp dụng công thức tính toán theo cấp số mũ
    const levelPowerMultiplier = Math.pow(STAT_CONSTANTS.LEVEL_GROWTH_RATE, effectiveLevel - 1);
    const realmPowerMultiplier = Math.pow(STAT_CONSTANTS.REALM_POWER_SCALE, realmIndex);

    const finalHp = Math.floor(
        STAT_CONSTANTS.BASE_HP * levelPowerMultiplier * realmPowerMultiplier * talentMultiplier
    );
    const finalAtk = Math.floor(
        STAT_CONSTANTS.BASE_ATK * levelPowerMultiplier * realmPowerMultiplier * talentMultiplier
    );

    return { hp: Math.max(1, finalHp), atk: Math.max(1, finalAtk) };
};
/**
 * Tính toán lượng EXP tối đa cho một NPC dựa trên cấp độ và cảnh giới.
 * @param {object} npc - Đối tượng NPC, cần có level, realm, và cultivationSystem.
 * @param {object} worldKnowledge - Toàn bộ kho tri thức thế giới để tra cứu cảnh giới.
 * @returns {number} - Lượng EXP tối đa cần để lên cấp.
 */
const calculateNpcMaxExp = (npc, worldKnowledge) => {
    const level = npc.level || 1;
    const npcName = npc.Name || "NPC không tên";

    console.log(`[NPC_MaxExp_Calc] Bắt đầu tính maxExp cho: "${npcName}", Level: ${level}, Realm: "${npc.realm}"`);

    // Tìm realmIndex của NPC dựa trên hệ tu luyện của nó
    const system = worldKnowledge.cultivationSystems.find(s => s.systemName === npc.cultivationSystem);
    const realmIndex = system ? Math.max(0, system.realms.indexOf(npc.realm)) : 0;
    const realmFactor = 1 + (realmIndex * 0.4);

    console.log(`[NPC_MaxExp_Calc] "${npcName}" - Hệ Tu Luyện: ${npc.cultivationSystem || "Không rõ"}, Cảnh giới Index: ${realmIndex}, Hệ số Cảnh giới: ${realmFactor}`);

    // Giả định NPC luôn ở độ khó "Thường" và chỉ có 1 con đường tu luyện để tính toán đơn giản và nhất quán
    const difficultyMultiplier = 1.2; // Tương ứng độ khó 'Thường'
    const pathMultiplier = 1;

    const finalMaxExp = Math.floor((100 + Math.pow(level, 1.8) * 5) * difficultyMultiplier * realmFactor * pathMultiplier);

    console.log(`[NPC_MaxExp_Calc] Kết quả tính maxExp cho "${npcName}": ${finalMaxExp}`);

    return finalMaxExp;
};
/**
 * Định dạng một số lớn thành chuỗi có dấu phân cách hàng nghìn theo chuẩn Việt Nam.
 * Ví dụ: 1000000 -> "1.000.000"
 * @param {number} number - Số cần định dạng.
 * @returns {string} - Chuỗi đã được định dạng hoặc 'N/A' nếu đầu vào không hợp lệ.
 */
const formatLargeNumber = (number) => {
  // Debug: Ghi lại số đầu vào để kiểm tra
  // console.log(`[formatLargeNumber] Received: ${number}, type: ${typeof number}`);

  // Xử lý các trường hợp đầu vào không hợp lệ
  if (number === null || number === undefined || isNaN(number)) {
    // Debug: Báo cáo đầu vào không hợp lệ
    // console.log(`[formatLargeNumber] Invalid input, returning 'N/A'.`);
    return 'N/A';
  }

  // Sử dụng hàm có sẵn của JavaScript để định dạng số theo chuẩn Việt Nam (dùng dấu chấm)
  const formatted = number.toLocaleString('vi-VN');
  // Debug: Ghi lại kết quả sau khi định dạng
  // console.log(`[formatLargeNumber] Formatted to: "${formatted}"`);
  return formatted;
};
//
//
//
//
// bắt đầu bắt đầu
//
//
//bắt đầu fixx

    // *** ENHANCED AI INTEGRATION: IMPROVED OPTIMIZED PROMPT GENERATION ***
    const createOptimizedPrompt = (storyHistory, playerAction, worldKnowledge, gameSettings, knowledgeBase) => {
        console.log('🔍 [DEBUG] createOptimizedPrompt - BẮT ĐẦU LỌC THÔNG TIN');
        console.log('📊 [DEBUG] worldKnowledge có sẵn:', {
            races: worldKnowledge.races?.length || 0,
            locations: worldKnowledge.locations?.length || 0,
            items: worldKnowledge.items?.length || 0,
            skills: worldKnowledge.skills?.length || 0,
            concepts: worldKnowledge.concepts?.length || 0,
            events: worldKnowledge.events?.length || 0,
            npcs: worldKnowledge.npcs?.length || 0
        });
        
        // Enhanced parameter validation
        if (!storyHistory || !Array.isArray(storyHistory)) {
            console.warn('createOptimizedPrompt: storyHistory is invalid');
            return '';
        }
        if (!playerAction || typeof playerAction !== 'string') {
            console.warn('createOptimizedPrompt: playerAction is invalid');
            return '';
        }
        if (!worldKnowledge || typeof worldKnowledge !== 'object') {
            console.warn('createOptimizedPrompt: worldKnowledge is invalid');
            return '';
        }
        
        // Improved context analysis
        const recentStory = storyHistory.slice(-5).map(h => h.content || '').join(' ').toLowerCase();
        const playerActionLower = playerAction.toLowerCase();
        const combinedContext = `${recentStory} ${playerActionLower}`;
        
        console.log('🎯 [DEBUG] Bối cảnh để lọc:', combinedContext.substring(0, 200) + '...');
        
        // Special debug for specific terms
        if (combinedContext.includes('hoang cổ thánh thể')) {
        }
        if (combinedContext.includes('hoang') && combinedContext.includes('cổ') && combinedContext.includes('thánh') && combinedContext.includes('thể')) {
        }
        
        let relevantContent = '### KIẾN THỨC THẾ GIỚI LIÊN QUAN (ĐÃ LỌC THÔNG MINH)\n';
        
        // Helper function to get relevance score and filter
        const getRelevanceScore = (entity) => {
            if (!entity || !entity.name) return 0;
            const entityName = entity.name.toLowerCase();
            const entityDesc = (entity.description || '').toLowerCase();
            
            // Priority 1: Exact full name match (score 100)
            if (combinedContext.includes(entityName)) {
                console.log('🎯 [DEBUG] Tìm thấy khớp hoàn toàn:', entity.name);
                return 100;
            }
            
            // Priority 2: Description match (score 90)
            if (entityDesc && combinedContext.includes(entityDesc)) {
                console.log('🎯 [DEBUG] Tìm thấy khớp mô tả:', entity.name);
                return 90;
            }
            
            // Priority 3: Partial name match (score 50-80)
            const entityWords = entityName.split(' ').filter(word => word.length > 2);
            const contextWords = combinedContext.split(' ');
            if (entityWords.length >= 2) {
                const matchedWords = entityWords.filter(word => 
                    contextWords.some(contextWord => contextWord.includes(word) || word.includes(contextWord))
                );
                if (matchedWords.length >= Math.min(2, Math.ceil(entityWords.length * 0.6))) {
                    const score = 50 + (matchedWords.length / entityWords.length) * 30;
                    console.log('🎯 [DEBUG] Tìm thấy khớp từng phần:', entity.name, 'Words matched:', matchedWords, 'Score:', score);
                    return score;
                }
            }
            
            // Priority 4: Single word match (score 30)
            if (entityWords.length === 1 && entityWords[0].length > 4) {
                if (combinedContext.includes(entityWords[0])) {
                    return 30;
                }
            }
            
            return 0;
        };
        
        // Helper function to get relevant entities sorted by score
        const getRelevantEntities = (entities, maxCount = 5) => {
            if (!entities || !Array.isArray(entities)) return [];
            
            return entities
                .map(entity => ({ entity, score: getRelevanceScore(entity) }))
                .filter(item => item.score > 0)
                .sort((a, b) => b.score - a.score) // Sort by score descending
                .slice(0, maxCount)
                .map(item => item.entity);
        };
        
        // Add relevant locations
        if (worldKnowledge.locations && Array.isArray(worldKnowledge.locations)) {
            const relevantLocations = getRelevantEntities(worldKnowledge.locations, 5);
            console.log('🏰 [DEBUG] Locations - Tổng số:', worldKnowledge.locations.length, 'Liên quan:', relevantLocations.length);
            if (relevantLocations.length > 0) {
                console.log('📍 [DEBUG] Locations được chọn:', relevantLocations.map(l => l.name));
                relevantContent += '**Địa điểm liên quan:**\n';
                relevantLocations.forEach(location => {
                    relevantContent += `- ${location.name}: ${location.description}\n`;
                });
                relevantContent += '\n';
            }
        }
        
        // Add relevant NPCs
        if (worldKnowledge.npcs && Array.isArray(worldKnowledge.npcs)) {
            const relevantNpcs = getRelevantEntities(worldKnowledge.npcs, 5);
            console.log('👥 [DEBUG] NPCs - Tổng số:', worldKnowledge.npcs.length, 'Liên quan:', relevantNpcs.length);
            if (relevantNpcs.length > 0) {
                console.log('🧙 [DEBUG] NPCs được chọn:', relevantNpcs.map(n => n.name));
                relevantContent += '**NPCs liên quan:**\n';
                relevantNpcs.forEach(npc => {
                    relevantContent += `- ${npc.name}: ${npc.description}\n`;
                });
                relevantContent += '\n';
            }
        }
        
        // Add relevant items
        if (worldKnowledge.items && Array.isArray(worldKnowledge.items)) {
            const relevantItems = getRelevantEntities(worldKnowledge.items, 5);
            console.log('📦 [DEBUG] Items - Tổng số:', worldKnowledge.items.length, 'Liên quan:', relevantItems.length);
            if (relevantItems.length > 0) {
                console.log('⚔️ [DEBUG] Items được chọn:', relevantItems.map(i => i.name));
                relevantContent += '**Vật phẩm liên quan:**\n';
                relevantItems.forEach(item => {
                    relevantContent += `- ${item.name}: ${item.description}\n`;
                });
                relevantContent += '\n';
            }
        }
        
        // Add relevant skills
        if (worldKnowledge.skills && Array.isArray(worldKnowledge.skills)) {
            const relevantSkills = getRelevantEntities(worldKnowledge.skills, 3);
            console.log('🥋 [DEBUG] Skills - Tổng số:', worldKnowledge.skills.length, 'Liên quan:', relevantSkills.length);
            if (relevantSkills.length > 0) {
                console.log('⚡ [DEBUG] Skills được chọn:', relevantSkills.map(s => s.name));
                relevantContent += '**Kỹ năng liên quan:**\n';
                relevantSkills.forEach(skill => {
                    relevantContent += `- ${skill.name}: ${skill.description}\n`;
                });
                relevantContent += '\n';
            }
        }
        
        // Add relevant concepts
        if (worldKnowledge.concepts && Array.isArray(worldKnowledge.concepts)) {
            console.log('💡 [DEBUG] Tất cả Concepts có sẵn:', worldKnowledge.concepts.map(c => c.name));
            const relevantConcepts = getRelevantEntities(worldKnowledge.concepts, 3);
            console.log('💡 [DEBUG] Concepts - Tổng số:', worldKnowledge.concepts.length, 'Liên quan:', relevantConcepts.length);
            if (relevantConcepts.length > 0) {
                console.log('🔮 [DEBUG] Concepts được chọn:', relevantConcepts.map(c => c.name));
                relevantContent += '**Khái niệm liên quan:**\n';
                relevantConcepts.forEach(concept => {
                    relevantContent += `- ${concept.name}: ${concept.description}\n`;
                });
                relevantContent += '\n';
            }
        }
        
        // Add relevant events
        if (worldKnowledge.events && Array.isArray(worldKnowledge.events)) {
            const relevantEvents = getRelevantEntities(worldKnowledge.events, 3);
            console.log('📅 [DEBUG] Events - Tổng số:', worldKnowledge.events.length, 'Liên quan:', relevantEvents.length);
            if (relevantEvents.length > 0) {
                console.log('🎭 [DEBUG] Events được chọn:', relevantEvents.map(e => e.name));
                relevantContent += '**Sự kiện liên quan:**\n';
                relevantEvents.forEach(event => {
                    relevantContent += `- ${event.name}: ${event.description}\n`;
                });
                relevantContent += '\n';
            }
        }
        
        // Add relevant races
        if (worldKnowledge.races && Array.isArray(worldKnowledge.races)) {
            const relevantRaces = getRelevantEntities(worldKnowledge.races, 3);
            console.log('🧬 [DEBUG] Races - Tổng số:', worldKnowledge.races.length, 'Liên quan:', relevantRaces.length);
            if (relevantRaces.length > 0) {
                console.log('👤 [DEBUG] Races được chọn:', relevantRaces.map(r => r.name));
                relevantContent += '**Chủng tộc liên quan:**\n';
                relevantRaces.forEach(race => {
                    relevantContent += `- ${race.name}: ${race.description}\n`;
                });
                relevantContent += '\n';
            }
        }
        
        // If no relevant content found, add a fallback message
        if (relevantContent === '### KIẾN THỨC THẾ GIỚI LIÊN QUAN (ĐÃ LỌC THÔNG MINH)\n') {
            relevantContent += '**Không có thông tin đặc biệt liên quan - AI có thể tự do sáng tạo theo bối cảnh.**\n';
            console.log('⚠️ [DEBUG] Không tìm thấy thông tin liên quan nào!');
        }
        
        console.log('📝 [DEBUG] Kết quả cuối cùng - Độ dài nội dung:', relevantContent.length, 'ký tự');
        console.log('==================================================');
        
        return relevantContent;
    };
    
    // *** END TEMPORARY FIX ***
    


// App Component
const App = () => {
  // Hàm hỗ trợ: Phân tích chuỗi StatsBonus thành đối tượng
    // Ví dụ: "atk:5,hp:20" -> { atk: 5, hp: 20 }
    // Nâng cấp để nhận diện giá trị phần trăm
    const parseStatsBonus = (statsBonusString) => {
        console.log('[parseStatsBonus] INPUT:', JSON.stringify(statsBonusString));

        const bonuses = {};
        if (!statsBonusString || typeof statsBonusString !== 'string') {
            console.log('[parseStatsBonus] OUTPUT: {} (Input không hợp lệ)');
            return bonuses;
        }

        const cleanedString = statsBonusString.trim().replace(/^[`"']|[`"']$/g, '');
        console.log('[parseStatsBonus] CLEANED:', cleanedString);

        if (!cleanedString || cleanedString.toLowerCase() === '[không có]') {
            console.log('[parseStatsBonus] OUTPUT: {} (Chuỗi rỗng hoặc là [Không có])');
            return bonuses;
        }

        cleanedString.split(',').forEach(part => {
            const [key, valueStr] = part.split(':').map(s => s.trim());
            if (key && valueStr) {
                // === THAY ĐỔI LOGIC DUY NHẤT NẰM Ở ĐÂY ===
                // Kiểm tra xem chuỗi có BẮT ĐẦU bằng '%' hay không.
                const isPercent = valueStr.startsWith('%');
                
                // Nếu là phần trăm, loại bỏ ký tự '%' trước khi phân tích.
                // Nếu không, giữ nguyên chuỗi.
                const valueToParse = isPercent ? valueStr.substring(1) : valueStr;
                
                const numericValue = parseFloat(valueToParse);

                if (!isNaN(numericValue)) {
                    bonuses[key.toLowerCase()] = {
                        value: numericValue,
                        isPercent: isPercent,
                    };
                }
                // ==========================================
            }
        });

        console.log('[parseStatsBonus] PARSED BONUSES:', JSON.stringify(bonuses));
        return bonuses;
    };
    // Nâng cấp để áp dụng cả giá trị cố định và phần trăm
    const applyStatsBonus = (baseStats, bonuses) => {
        console.log('[applyStatsBonus] INPUT baseStats:', JSON.stringify(baseStats));
        console.log('[applyStatsBonus] INPUT bonuses:', JSON.stringify(bonuses));

        const newStats = { ...baseStats };
        const totalFlatBonuses = {};
        const totalPercentBonuses = {};

        // --- BƯỚC 1: Tách và tính tổng các loại bonus ---
        for (const key in bonuses) {
            const bonus = bonuses[key];
            const statKey = key.toLowerCase(); // Chuẩn hóa key về chữ thường

            if (bonus.isPercent) {
                totalPercentBonuses[statKey] = (totalPercentBonuses[statKey] || 0) + bonus.value;
            } else {
                totalFlatBonuses[statKey] = (totalFlatBonuses[statKey] || 0) + bonus.value;
            }
        }
        
        console.log('[applyStatsBonus] Total Flat Bonuses:', JSON.stringify(totalFlatBonuses));
        console.log('[applyStatsBonus] Total Percent Bonuses:', JSON.stringify(totalPercentBonuses));

        // --- BƯỚC 2: Áp dụng bonus vào chỉ số ---
        const allKeys = new Set([...Object.keys(baseStats), ...Object.keys(totalFlatBonuses), ...Object.keys(totalPercentBonuses)]);

        allKeys.forEach(key => {
            // Ánh xạ key chữ thường sang key đúng trong object stats
            let statKey = key;
            if (key === 'maxhp') statKey = 'maxHp';
            if (key === 'maxmana') statKey = 'maxMana';

            const baseValue = baseStats[statKey] || 0;
            const flatBonus = totalFlatBonuses[key] || 0;
            const percentBonus = totalPercentBonuses[key] || 0;

            // Nếu chỉ số này có bonus, tính toán lại
            if (flatBonus !== 0 || percentBonus !== 0) {
                 // Công thức: Final = (Base + Flat) * (1 + Percent/100)
                const finalValue = Math.floor((baseValue + flatBonus) * (1 + percentBonus / 100));
                newStats[statKey] = finalValue;
            }
        });

        // Cập nhật lại HP và Mana hiện tại để không vượt quá max
        if (newStats.hp > newStats.maxHp) newStats.hp = newStats.maxHp;
        if (newStats.mana > newStats.maxMana) newStats.mana = newStats.maxMana;

        console.log('[applyStatsBonus] OUTPUT newStats:', JSON.stringify(newStats));
        return newStats;
    };
// *** BẮT ĐẦU ĐOẠN CODE CẦN THÊM ***
const calculateAndSetAggregatedBonuses = (currentStorage) => {
    console.log('[BonusSystem] Bắt đầu tính toán lại tổng bonus từ kho lưu trữ:', currentStorage);
    const totals = {};

    for (const skillNameKey in currentStorage) {
        // Lấy chuỗi bonus từ cấu trúc mới
        const bonusString = currentStorage[skillNameKey].bonus;
        
        if (bonusString) {
            const parsed = parseStatsBonus(bonusString);
            for (const key in parsed) {
                if (!totals[key]) {
                    totals[key] = { value: 0, isPercent: parsed[key].isPercent };
                }
                totals[key].value += parsed[key].value;
            }
        }
    }

    console.log('[BonusSystem] Kết quả tổng bonus đã tính toán:', totals);
    setAggregatedBonuses(totals);
    };

// *** BẮT ĐẦU ĐOẠN CODE THAY THẾ ***
// *** BẮT ĐẦU ĐOẠN CODE THAY THẾ ***
const updateBonusSkillStorage = (actionType, payload) => {
    console.log(`[BonusSystem] Nhận hành động: ${actionType.toUpperCase()}. Payload:`, payload);

    setBonusSkillStorage(prevStorage => {
        const newStorage = { ...prevStorage };
        let storageChanged = false;

        if (actionType === 'LEARN') {
            const { newSkill } = payload;
            if (!newSkill || !newSkill.Name) return newStorage; // Bỏ qua nếu không có tên

            const skillNameKey = newSkill.Name.trim().toLowerCase();
            const existingEntry = newStorage[skillNameKey];
            const newBonus = newSkill.StatsBonus || "";

            // Chỉ thêm hoặc cập nhật nếu có bonus mới, hoặc nếu đây là lần đầu kỹ năng xuất hiện
            if (newBonus) {
                if (!existingEntry || existingEntry.bonus !== newBonus) {
                    newStorage[skillNameKey] = { id: newSkill.id, bonus: newBonus };
                    console.log(`[BonusSystem] Đã THÊM/CẬP NHẬT bonus cho kỹ năng "${newSkill.Name}".`);
                    storageChanged = true;
                }
            } else if (!existingEntry) {
                // Nếu là kỹ năng mới và không có bonus, vẫn lưu để biết nó tồn tại
                newStorage[skillNameKey] = { id: newSkill.id, bonus: "" };
                console.log(`[BonusSystem] Đã GHI NHẬN kỹ năng "${newSkill.Name}" không có bonus.`);
                storageChanged = true;
            }

        } else if (actionType === 'UPGRADE') {
            const { oldSkillName, newSkill } = payload;
            const oldSkillNameKey = oldSkillName.trim().toLowerCase();
            
            if (newStorage[oldSkillNameKey]) {
                delete newStorage[oldSkillNameKey];
                console.log(`[BonusSystem] Đã XÓA bonus của kỹ năng cũ "${oldSkillName}" để nâng cấp.`);
                storageChanged = true;
            }
            
            if (newSkill && newSkill.Name && newSkill.StatsBonus) {
                const newSkillNameKey = newSkill.Name.trim().toLowerCase();
                newStorage[newSkillNameKey] = { id: newSkill.id, bonus: newSkill.StatsBonus };
                console.log(`[BonusSystem] Đã THÊM bonus của kỹ năng nâng cấp "${newSkill.Name}".`);
                storageChanged = true;
            }

        } else if (actionType === 'FORGET') {
            const { skillName } = payload;
            const skillNameKey = skillName.trim().toLowerCase();
            if (newStorage[skillNameKey]) {
                delete newStorage[skillNameKey];
                console.log(`[BonusSystem] Đã XÓA vĩnh viễn bonus của kỹ năng "${skillName}" khỏi kho.`);
                storageChanged = true;
            }
        }
        
        if (storageChanged) {
            console.log('[BonusSystem] Kho lưu trữ bonus sau khi cập nhật:', newStorage);
            calculateAndSetAggregatedBonuses(newStorage);
        }

        return newStorage;
    });
};

// *** KẾT THÚC ĐOẠN CODE CẦN THÊM ***
    // Hàm hỗ trợ: Gỡ bỏ bonus khỏi chỉ số
    const removeStatsBonus = (baseStats, bonuses) => {
        const newStats = { ...baseStats };
        for (const key in bonuses) {
            if (newStats.hasOwnProperty(key) && typeof newStats[key] === 'number') {
                newStats[key] -= bonuses[key];
            } else if (key === 'hp' && typeof newStats.maxhp === 'number') { // Đặc biệt cho HP hiện tại
                newStats.hp = Math.min(newStats.maxhp, newStats.hp - bonuses[key]); // Đảm bảo không vượt quá maxHP nếu trừ bớt máu
            } else if (key === 'mana' && typeof newStats.maxmana === 'number') { // Đặc biệt cho Mana hiện tại
                newStats.mana = Math.min(newStats.maxmana, newStats.mana - bonuses[key]); // Đảm bảo không vượt quá maxMana nếu trừ bớt mana
            }
        }
        return newStats;
    };
        
    const generateSkillDetails = async (skill) => {
        // Hiển thị thông báo cho người dùng biết AI đang xử lý
        showNotification(`AI đang tạo chi tiết cho kỹ năng: "${skill.name}"...`);

        const prompt = `
            Bạn là một chuyên gia thiết kế game nhập vai. Dựa trên thông tin cơ bản về một kỹ năng, hãy tạo ra các thuộc tính chi tiết cho nó.
            Thông tin cơ bản:
            - Tên kỹ năng: ${skill.name}
            - Loại kỹ năng: ${skill.type}
            - Mô tả: ${skill.description}

            Yêu cầu:
            1. "turn": Số lượt hiệu lực của kỹ năng. Nếu là kỹ năng gây sát thương tức thì, giá trị là 0.
            2. "cost": Năng lượng tiêu hao. Hãy sáng tạo (VD: "10 Mana", "5% HP tối đa", "1 Nộ khí").
            3. "effect": Mô tả chi tiết, rõ ràng về tác dụng của kỹ năng trong game.

            Chỉ trả về một đối tượng JSON duy nhất theo cấu trúc sau, không thêm bất kỳ giải thích hay ký tự nào khác.
        `;
        
        const schema = {
            type: "OBJECT",
            properties: {
                turn: { type: "NUMBER", description: "Số lượt hiệu lực của kỹ năng." },
                cost: { type: "STRING", description: "Năng lượng tiêu hao." },
                effect: { type: "STRING", description: "Mô tả chi tiết tác dụng." },
            },
            required: ["turn", "cost", "effect"],
        };

        try {
            const resultJson = await callGeminiAPI(prompt, true, schema); // Giả sử hàm callGeminiAPI của bạn hỗ trợ schema
            return {
                ...skill, // Giữ lại tên, loại, mô tả cũ
                ...resultJson // Thêm các thuộc tính mới do AI tạo ra
            };
        } catch (error) {
            console.error(`Lỗi khi tạo chi tiết cho kỹ năng "${skill.name}":`, error);
            showErrorModal(`Không thể tạo chi tiết cho kỹ năng "${skill.name}". Vui lòng thử lại.`);
            return null; // Trả về null nếu có lỗi
        }
    };
  const [activeTab, setActiveTab] = useState(TABS.WORLD);
  const [isGenerating, setIsGenerating] = useState({});
  const [currentScreen, setCurrentScreen] = useState('initial');
  // Thêm dòng code này vào cùng chỗ với các useState khác trong App
  const [promptCorrections, setPromptCorrections] = useState([]); 
  //koboko ai 
  const [koboldApiKey, setKoboldApiKey] = useState('');
  const [useKoboldIntegration, setUseKoboldIntegration] = useState(false); // Tắt theo mặc định
  const [isCallingKobold, setIsCallingKobold] = useState(false); // State để theo dõi loading
  const [koboldKeySaved, setKoboldKeySaved] = useState(false);
  //
  const [craftedAlchemyMaterials, setCraftedAlchemyMaterials] = useState([]);
  const [craftedSmithingMaterials, setCraftedSmithingMaterials] = useState([]);
  const [apiKey, setApiKey] = useState(''); 
  const [apiMode, setApiMode] = useState('defaultGemini'); 
  const [apiKeyStatus, setApiKeyStatus] = useState({ 
    status: 'Đang dùng Gemini AI Mặc Định', 
    message: 'Không cần API Key. Nội dung sẽ được tạo bởi AI của nền tảng.', 
    color: 'text-sky-400' 
  });

  // *** BẮT ĐẦU CODE MỚI VÀ SỬA ĐỔI (Yêu cầu 1) ***
  // Thêm state mới cho World Knowledge và Editor Modal
  const [showWorldEditor, setShowWorldEditor] = useState(false);
  const [worldKnowledge, setWorldKnowledge] = useState({
      items: [],
      skills: [],
      // Thêm dữ liệu mặc định cho hệ thống tu luyện theo Yêu cầu 2
      cultivationSystems: [
          { id: crypto.randomUUID(), systemName: "Tu Tiên", realms: ["Phàm Nhân", "Luyện Khí", "Trúc Cơ", "Kim Đan", "Nguyên Anh", "Hóa Thần", "Luyện Hư", "Hợp Thể", "Đại Thừa", "Độ Kiếp", "Chân Tiên", "Thiên Tiên", "Kim Tiên", "Đại La Kim Tiên", "Đạo Tổ"] },
          { id: crypto.randomUUID(), systemName: "Ma Tu", realms: ["Phàm Nhân", "Luyện Thể", "Tà Thai", "Ma Thai", "Ma Anh", "Ma Hồn", "Ma Tôn", "Ma Vương", "Ma Đế", "Ma Thần", "Chân Ma", "Cổ Ma", "Ma Tổ", "Vô Tướng Ma", "Ma Đạo Thủy Nguyên"] },
          { id: crypto.randomUUID(), systemName: "Phật Tu", realms: ["Phàm Tăng", "Tụ Thiện", "Sơ Thiền", "Nhị Thiền", "Tam Thiền", "Tứ Thiền", "Kim Thân", "La Hán", "Kim Cang", "Bồ Tát", "Chuẩn Phật", "Phật Đà", "Pháp Thân Phật", "Như Lai", "Phật Tổ"] },
          { id: crypto.randomUUID(), systemName: "Yêu Tu", realms: ["Yêu Thú", "Khai Linh", "Hóa Hình", "Ngưng Cốt", "Kết Đan", "Luyện Hồn", "Yêu Vương", "Yêu Đế", "Yêu Thần", "Chân Linh", "Thái Cổ Yêu", "Yêu Tổ", "Yêu Đạo Tổ", "Vạn Thú Linh Nguyên", "Hoang Cổ Linh Hồn"] },
          { id: crypto.randomUUID(), systemName: "Thần Đạo", realms: ["Phàm Nhân", "Hiển Thần", "Thần Thai", "Thần Hồn", "Hạ Vị Thần", "Trung Vị Thần", "Thượng Vị Thần", "Chân Thần", "Thần Vương", "Thần Đế", "Thần Tổ", "Thiên Chủ", "Chân Thần Tối Thượng", "Thần Nguyên Đạo", "Vô Thượng Thiên Thần"] },
          { id: crypto.randomUUID(), systemName: "Võ Tu", realms: ["Phàm Nhân", "Luyện Thể", "Tẩy Tủy", "Khai Mạch", "Tụ Khí", "Cương Khí", "Nội Cương", "Ngoại Cương", "Chiến Hồn", "Chiến Ý", "Chiến Đạo", "Chân Võ", "Võ Thần", "Võ Tổ", "Đạo Nguyên Chi Thể"] },
          { id: crypto.randomUUID(), systemName: "Hồn Tu", realms: ["Phàm Nhân", "Thức Hồn", "Tụ Hồn", "Luyện Hồn", "Xuất Khiếu", "Dẫn Hồn", "Hóa Hồn", "Hồn Ảnh", "Chiến Hồn", "Hồn Thể", "Hồn Vương", "Hồn Đế", "Hồn Tổ", "Chân Linh Hồn Chủ", "Thức Hải Vô Ngã"] },
          { id: crypto.randomUUID(), systemName: "Khí Tu", realms: ["Phàm Nhân", "Luyện Khí", "Tụ Linh", "Ngưng Khí", "Tinh Khí Nhập Thể", "Khí Hải Thông Linh", "Hóa Nguyên", "Nguyên Khí Thần Hóa", "Khí Ý Thành Đạo", "Thiên Địa Khí Cơ", "Khí Tổ", "Vạn Pháp Khí Linh", "Hư Không Chân Đạo", "Thiên Cơ Đạo Chủ", "Khí Nguyên Vô Thể"] },
          { id: crypto.randomUUID(), systemName: "Tinh Thần Tu", realms: ["Phàm Nhân", "Ngưng Thức", "Tụ Thần", "Thức Hải", "Huyễn Cảnh", "Thần Niệm", "Mộng Linh", "Thức Vực", "Tinh Vực", "Huyễn Vực", "Tâm Mộng Đồng Sinh", "Đại Mộng Thức Đạo", "Thức Tổ", "Vô Tướng Niệm Thể", "Vọng Tâm Hư Ảnh"] },
          { id: crypto.randomUUID(), systemName: "Thực Vật Tu", realms: ["Hạt Mầm", "Phá Vỏ", "Chồi Non", "Linh Diệp", "Linh Hoa", "Kết Quả", "Linh Căn", "Thụ Tâm", "Thụ Linh", "Thụ Tiên", "Cổ Thụ", "Thái Cổ Mộc", "Linh Mộc Tổ", "Mộc Nguyên Chi Hồn", "Thiên Mộc Đạo Chủ"] },
          { id: crypto.randomUUID(), systemName: "Kiếm Tu", realms: ["Phàm Nhân", "Kiếm Căn", "Tụ Ý", "Ngưng Kiếm", "Kiếm Hồn", "Nhất Kiếm Nhập Đạo", "Tam Kiếm Quy Nguyên", "Cửu Kiếm Hóa Hư", "Vạn Kiếm Quy Tông", "Kiếm Linh Hợp Nhất", "Kiếm Thể Đồng Sinh", "Kiếm Vực Đại Đạo", "Kiếm Tổ", "Vô Hình Kiếm Chủ", "Kiếm Đạo Thủy Nguyên"] }
      ],
            // *** BẮT ĐẦU ĐOẠN THÊM MỚI ***
      races: [], 
      locations: [], 
      concepts: [],
      events: [],
      // *** KẾT THÚC ĐOẠN THÊM MỚI ***
      npcs: [], // *** THÊM MỚI ***
  });
  // *** KẾT THÚC CODE MỚI VÀ SỬA ĐỔI ***

  const [gameSettings, setGameSettings] = useState({
    theme: '',
    setting: '',
    writingStyle: 'Tiên hiệp',
    narratorPronoun: 'Để AI quyết định',
    characterName: '',
    characterPersonality: PLAYER_PERSONALITIES[0], 
    characterGender: 'Không xác định',
    characterBackstory: '',
    initialTraits: [{ // Đã đổi tên từ preferredInitialSkills sang initialTraits
        id: crypto.randomUUID(),
        name: '',
        description: '[Chưa có]', // Đặt là chuỗi đặc biệt để AI biết cần điền
        category: 'Kỹ năng', // Mặc định là 'Kỹ năng'
        type: 'Chủ động',    // Dành cho Kỹ năng
        manaCost: 0, // Giá trị số 0
        cooldown: 0, // Giá trị số 0
        effect: '[Chưa có]', // Đặt là chuỗi đặc biệt để AI biết cần điền
        // --- Các trường dành cho Vật phẩm ---
        itemType: 'Khác',
        equippable: false,
        usable: false,
        consumable: false,
        uses: 0, // Giá trị số 0
        effectDescription: '[Chưa có]', // Đặt là chuỗi đặc biệt để AI biết cần điền
        statsBonus: '[Không có]', // Đặt là chuỗi đặc biệt để AI biết cần điền
        sideEffect: '[Không có]', // Đặt là chuỗi đặc biệt để AI biết cần điền
        // ------------------------------------
    }],
    difficulty: 'Thường',
    difficultyDescription: '',
    allowNsfw: false, 
    initialWorldElements: [],
    useCharacterGoal: false, 
    characterGoal: '',   
    allowCustomActionInput: true,
    // *** BẮT ĐẦU SỬA ĐỔI: Thêm hệ tu luyện ban đầu ***
    initialCultivationSystem: 'Tu Tiên',
    // *** KẾT THÚC SỬA ĐỔI ***
    currencyName: 'Linh thạch', 
    // *** BẮT ĐẦU CODE MỚI CHO VẤN ĐỀ 2 ***
    initialTalentTier: 'Phàm Thể', // Thêm bậc thiên phú, mặc định là thấp nhất
    initialRealm: 'Phàm Nhân',       // Thêm cảnh giới, mặc định là thấp nhất
    initialLevel: 1,                 // Thêm cấp độ, mặc định là 1
    // *** KẾT THÚC CODE MỚI CHO VẤN ĐỀ 2 ***
  });
  const [currentTurn, setCurrentTurn] = useState(0); // Khởi tạo lượt ban đầu là 0
  const [showCraftingModal, setShowCraftingModal] = useState(false);
  const [showCharacterEquipModal, setShowCharacterEquipModal] = useState(false);
  const handleGenerate = async (fieldName) => {
    console.log(`Đang yêu cầu AI tạo cho: ${fieldName}`);
    setIsGenerating(prev => ({ ...prev, [fieldName]: true }));

    let promptText = '';
    let generatedText = '';

    try {
        if (fieldName === 'theme') {
            promptText = "Gợi ý MỘT chủ đề duy nhất cho một game nhập vai. Chỉ trả về tên chủ đề.";
            generatedText = await fetchGenericGeminiText(promptText);
            if (generatedText) setGameSettings(p => ({ ...p, theme: generatedText }));
        
        } else if (fieldName === 'characterName') {
            promptText = `Dựa vào chủ đề "${gameSettings.theme || 'Tiên hiệp'}", gợi ý MỘT tên nhân vật có khí chất. Chỉ trả về tên.`;
            generatedText = await fetchGenericGeminiText(promptText);
            if (generatedText) setGameSettings(p => ({ ...p, characterName: generatedText }));

        } else if (fieldName === 'setting') {
            promptText = `Dựa trên chủ đề game là "${gameSettings.theme || "Tiên hiệp"}", hãy viết một đoạn mô tả bối cảnh chi tiết (khoảng 2-3 câu) cho thế giới này. QUAN TRỌNG: Chỉ trả về nội dung mô tả, không có lời dẫn.`;
            generatedText = await fetchGenericGeminiText(promptText);
            if (generatedText) setGameSettings(p => ({ ...p, setting: generatedText }));

        } else if (fieldName === 'characterBackstory') {
            promptText = `Dựa vào tên nhân vật "${gameSettings.characterName || 'chưa có'}" và chủ đề "${gameSettings.theme || 'Tiên hiệp'}", hãy viết một sơ lược tiểu sử hoặc đặc điểm (2-3 câu) cho nhân vật này. QUAN TRỌNG: Chỉ trả về nội dung tiểu sử, không có lời dẫn.`;
            generatedText = await fetchGenericGeminiText(promptText);
            if (generatedText) setGameSettings(p => ({ ...p, characterBackstory: generatedText }));

        }else if (fieldName === 'difficultyDescription') {
            promptText = `Dựa trên chủ đề game là "${gameSettings.theme || "Chưa rõ"}", hãy viết một mô tả ngắn gọn (1-2 câu) về độ khó "Tuỳ Chỉnh AI" cho trò chơi này, theo văn phong tiểu thuyết mạng Trung Quốc. QUAN TRỌNG: Chỉ trả về nội dung mô tả, không có lời dẫn.`;
            generatedText = await fetchGenericGeminiText(promptText);
            if (generatedText) setGameSettings(p => ({ ...p, difficultyDescription: generatedText }));

        }else if (fieldName === 'preferredInitialSkill') {
            promptText = `Dựa trên chủ đề game '${gameSettings.theme || "chưa rõ"}' và sơ lược nhân vật '${gameSettings.characterBackstory || "chưa rõ"}', hãy gợi ý MỘT kỹ năng khởi đầu phù hợp (ví dụ: 'Hỏa Cầu Thuật', 'Ẩn Thân Thuật'). Chỉ trả về tên kỹ năng.`;
            generatedText = await fetchGenericGeminiText(promptText);
            if (generatedText) setGameSettings(p => ({ ...p, preferredInitialSkill: generatedText }));
        
        }else if (fieldName === 'currencyName') {
            promptText = `Dựa vào chủ đề game là "${gameSettings.theme || 'Tiên hiệp'}", hãy gợi ý MỘT tên đơn vị tiền tệ phù hợp (VD: Linh Thạch, Ma Tinh, Kim Tệ). Chỉ trả về tên.`;
            generatedText = await fetchGenericGeminiText(promptText);
            if (generatedText) setGameSettings(p => ({ ...p, currencyName: generatedText }));
        }else if (fieldName === 'initialTraitName') {
            promptText = `Dựa vào chủ đề "<span class="math-inline">\{gameSettings\.theme \|\| 'Tiên hiệp'\}" và bối cảnh "</span>{gameSettings.setting || 'chưa rõ'}", hãy gợi ý MỘT tên đặc điểm khởi đầu (có thể là thiên phú, kỹ năng, hoặc một vật phẩm đặc biệt) cho nhân vật. Chỉ trả về tên. Ví dụ: "Thiên Linh Căn", "Kiếm Tâm Thông Minh", "Cổ Ngọc Thần Bí".`;
            generatedText = await fetchGenericGeminiText(promptText);
            if (generatedText) {
                // Thêm một đặc điểm mới với tên được tạo ra
                setGameSettings(prev => ({
                    ...prev,
                    initialTraits: [...prev.initialTraits, { 
                        id: crypto.randomUUID(), 
                        name: generatedText, 
                        description: '' 
                    }]
                }));
            }
        }
        else if (fieldName.startsWith('elementDesc_')) {
            const index = parseInt(fieldName.split('_')[1], 10);
            const element = gameSettings.initialWorldElements[index];
            if (element) {
                promptText = `Trong thế giới có chủ đề "${gameSettings.theme}", hãy viết một mô tả ngắn (1-2 câu) cho một thực thể loại "${element.type}" có tên là "${element.name}". QUAN TRỌNG: Chỉ trả về nội dung mô tả, không có lời dẫn.`;
                generatedText = await fetchGenericGeminiText(promptText);
                if (generatedText) {
                    setGameSettings(prev => {
                        const newElements = [...prev.initialWorldElements];
                        newElements[index] = { ...newElements[index], description: generatedText };
                        return { ...prev, initialWorldElements: newElements };
                    });
                }
            }
        }
        // Thêm các trường hợp 'else if' khác cho các nút AI trong tương lai tại đây
    } catch (error) {
        console.error(`Lỗi khi tạo AI cho ${fieldName}:`, error);
        setModalMessage({ show: true, title: 'Lỗi AI', content: `Không thể tạo nội dung: ${error.message}`, type: 'error' });
    }

    setIsGenerating(prev => ({ ...prev, [fieldName]: false }));
  };
  const [storyHistory, setStoryHistory] = useState([]); 
  const [currentStory, setCurrentStory] = useState('');
  const [choices, setChoices] = useState([]);
  const [isLoading, setIsLoading] = useState(false); 
  const [userId, setUserId] = useState(null);
  const [isAuthReady, setIsAuthReady] = useState(false);
  const [showApiModal, setShowApiModal] = useState(false);
  const [showUpdateLogModal, setShowUpdateLogModal] = useState(false); // New state for update log
  const [inputApiKey, setInputApiKey] = useState(''); 
  const [chatHistoryForGemini, setChatHistoryForGemini] = useState([]);
  const [currentGameId, setCurrentGameId] = useState(null);
  const [savedGames, setSavedGames] = useState([]);
  const [showLoadGameModal, setShowLoadGameModal] = useState(false);
  const [modalMessage, setModalMessage] = useState({ show: false, title: '', content: '', type: 'info' });
  const [confirmationModal, setConfirmationModal] = useState({ show: false, title: '', content: '', onConfirm: null, onCancel: null, confirmText: 'Xác nhận', cancelText: 'Hủy'});
  
  const [customActionInput, setCustomActionInput] = useState('');
  const [knowledgeBase, setKnowledgeBase] = useState({ 
    npcs: [], items: [], locations: [], companions: [], 
    inventory: [], playerSkills: [], relationships: [],
    playerStatus: [], quests: [], // Added quests to knowledgeBase
    realmProgressionList: [],
     storyOutline: "", // <-- THÊM MỚI: Trường để lưu đại cương câu chuyện
    equippedItems: { // Vật phẩm trang bị
      weapon: null,
      head: null,
      body: null,
      hands: null,
      feet: null,
      accessory1: null,
      accessory2: null,
    },
    equippedGongfa: { // Công pháp trang bị
        main: null,
        sub1: null,
        sub2: null,
    },
    // === thuột tính  ===
    playerStats: {
        hp: 0,
        maxHp:0,
        mana: 0,
        maxMana: 0,
        atk: 0,
        exp: 0,
        maxExp: 0,
        level: 1,
        realm: "",
        currency: "",
        
         
    }
  });
  const [showCharacterInfoModal, setShowCharacterInfoModal] = useState(false);

  const [isFetchingSuggestions, setIsFetchingSuggestions] = useState(false);
  const [showSuggestionsModal, setShowSuggestionsModal] = useState({ show: false, fieldType: null, suggestions: [], isLoading: true, title: '' });
  const [isGeneratingContent, setIsGeneratingContent] = useState(false); 
  const [isGeneratingDifficultyDesc, setIsGeneratingDifficultyDesc] = useState(false);
  const [isGeneratingInitialElementDesc, setIsGeneratingInitialElementDesc] = useState({});
  const [isGeneratingGoal, setIsGeneratingGoal] = useState(false); 
  const [isGeneratingSuggestedActions, setIsGeneratingSuggestedActions] = useState(false);
  const [suggestedActionsList, setSuggestedActionsList] = useState([]);
  const [showSuggestedActionsModal, setShowSuggestedActionsModal] = useState(false);
  const [showQuickReferenceModal, setShowQuickReferenceModal] = useState(false);
  const [isGeneratingCharacterName, setIsGeneratingCharacterName] = useState(false);
  const [isGeneratingInitialSkill, setIsGeneratingInitialSkill] = useState(false);


  const [showQuickLoreModal, setShowQuickLoreModal] = useState(false);
  const [quickLoreContent, setQuickLoreContent] = useState(null);

  

  {/* === BẮT ĐẦU ĐOẠN CODE CẦN THÊM === */}
  const [notifications, setNotifications] = useState([]);
  // State để quản lý giao diện (sáng/tối)
const [theme, setTheme] = useState('dark');
const toggleTheme = () => {
    setTheme(prevTheme => (prevTheme === 'dark' ? 'light' : 'dark'));
    console.log(`[Theme] Switched to ${theme === 'dark' ? 'light' : 'dark'} mode.`);
};
// *** BẮT ĐẦU ĐOẠN CODE CẦN THÊM ***
  const [bonusSkillStorage, setBonusSkillStorage] = useState({});
  const [aggregatedBonuses, setAggregatedBonuses] = useState({});
// *** KẾT THÚC ĐOẠN CODE CẦN THÊM ***
  const showNotification = useCallback((message, type = 'info', duration = 5000) => {
    const id = crypto.randomUUID();
    setNotifications(prev => [...prev, { id, message, type }]);
    setTimeout(() => {
        setNotifications(prev => prev.filter(n => n.id !== id));
    }, duration);
  }, []);
{/* === KẾT THÚC ĐOẠN CODE CẦN THÊM === */}

  // ================= BẮT ĐẦU CODE CẦN THÊM =================
  const OUTLINE_UPDATE_INTERVAL = 5; // Cập nhật đại cương sau mỗi 5 lượt.
  // ================== KẾT THÚC CODE CẦN THÊM ==================

  const [isProcessingAction, setIsProcessingAction] = useState(false); 
  //
  const fileInputRef = useRef(null);
    const handleSaveGame = () => {
    if (!storyHistory || storyHistory.length === 0) {
    setModalMessage({ show: true, title: 'Không Thể Lưu', content: 'Chưa có diễn biến nào để lưu lại.', type: 'info' });
    return;
    }
   const saveData = {
          saveVersion: "2.5", // Cập nhật phiên bản
          timestamp: new Date().toISOString(),
          gameSettings,
          knowledgeBase,
          worldKnowledge, // <-- THÊM DỮ LIỆU KHO TRI THỨC VÀO FILE SAVE
          storyHistory,
          choices,
          chatHistoryForGemini,
          bonusSkillStorage, // Thêm kho lưu trữ gốc
          aggregatedBonuses, // THÊM DÒNG NÀY ĐỂ LƯU TỔNG BONUS
      };

      const jsonString = JSON.stringify(saveData, null, 2);
      const blob = new Blob([jsonString], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      a.href = url;
      a.download = `AI_PhieuLuu_Save_${timestamp}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      setModalMessage({ show: true, title: 'Thành Công', content: 'Đã lưu trò chơi vào tệp tin!', type: 'success' });
  };
  
const handleLoadGame = (event) => {
const file = event.target.files[0];
if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
          try {
              const loadedData = JSON.parse(e.target.result);
                              // *** BẮT ĐẦU LOGIC TƯƠNG THÍCH NGƯỢC CHO NPC TYPE ***
                if (loadedData.knowledgeBase && loadedData.knowledgeBase.npcs && Array.isArray(loadedData.knowledgeBase.npcs)) {
                    console.log("[DEBUG Load File] Running backward compatibility check for NPC types.");
                    loadedData.knowledgeBase.npcs.forEach(npc => {
                        if (npc.type === undefined) {
                            // Gán mặc định là 'Character' cho các NPC từ file save cũ không có type.
                            npc.type = 'Character';
                            console.warn(`[Compatibility] NPC "${npc.Name}" from old save file detected. Defaulted type to 'Character'. Please verify in World Editor.`);
                        }
                    });
                }
                // *** KẾT THÚC LOGIC TƯƠNG THÍCH NGƯỢC ***
                if (loadedData.knowledgeBase && loadedData.knowledgeBase.npcs && Array.isArray(loadedData.knowledgeBase.npcs)) {
                  console.log("[DEBUG Load File] Bắt đầu kiểm tra tương thích ngược cho kỹ năng NPC.");
                  loadedData.knowledgeBase.npcs.forEach(npc => {
                      // Nếu NPC không có thuộc tính 'skills' hoặc nó không phải là một mảng
                      if (!npc.skills || !Array.isArray(npc.skills)) {
                          console.log(`[DEBUG Load File] NPC "${npc.Name}" trong file save cũ thiếu thuộc tính 'skills'. Đang tự động thêm.`);
                          // Tự động thêm một mảng rỗng
                          npc.skills = [];
                      }
                  });
                }
              if (!loadedData.saveVersion || !loadedData.gameSettings || !loadedData.knowledgeBase || !loadedData.storyHistory) {
                  throw new Error("Tệp lưu trữ không hợp lệ hoặc đã bị hỏng. Cũng có thể là do version không khớp.");
              }

              // Khôi phục lại trạng thái từ tệp đã tải
              setGameSettings(loadedData.gameSettings);
              setKnowledgeBase(loadedData.knowledgeBase);
              if (loadedData.worldKnowledge) {
                  setWorldKnowledge(loadedData.worldKnowledge);
              }
              setStoryHistory(loadedData.storyHistory);
              setChoices(loadedData.choices || []);
              setChatHistoryForGemini(loadedData.chatHistoryForGemini || []);

              // KHÔI PHỤC LẠI TRẠNG THÁI CHO HỆ THỐNG BONUS
              setBonusSkillStorage(loadedData.bonusSkillStorage || {});
              setAggregatedBonuses(loadedData.aggregatedBonuses || {}); // THÊM DÒNG NÀY
              console.log("[Load Game] Đã khôi phục aggregatedBonuses từ tệp lưu:", loadedData.aggregatedBonuses || {});


              // Quan trọng: Reset currentGameId vì đây là save từ tệp, không phải từ Firestore
              setCurrentGameId(null);

              setCurrentScreen('gameplay');
              setModalMessage({ show: true, title: 'Thành Công', content: 'Đã tải trò chơi thành công!', type: 'success' });

          } catch (error) {
              console.error("Lỗi tải tệp lưu trữ:", error);
              setModalMessage({ show: true, title: 'Lỗi Tải Tệp', content: `Không thể đọc tệp lưu trữ: ${error.message}`, type: 'error' });
          }
      };
      reader.readAsText(file);
      // Reset giá trị của input để có thể chọn lại cùng một tệp
      event.target.value = null;
  };
  //
  const saveKoboldApiKey = async (koboldKey) => {
    if (!userId) {
      setModalMessage({ show: true, title: 'Lỗi', content: 'Người dùng chưa được xác thực để lưu API Key.', type: 'error' });
      return;
    }
    if (!koboldKey.trim()) {
        setModalMessage({ show: true, title: 'Thiếu Thông Tin', content: 'API Key của KoboldAI không được để trống.', type: 'error' });
        return;
    }
    setIsLoading(true);
    try {
      const koboldApiKeyRef = doc(db, `artifacts/${appId}/users/${userId}/apiCredentials/kobold`);
      await setDoc(koboldApiKeyRef, { key: koboldKey, lastUpdated: serverTimestamp() });
      setKoboldApiKey(koboldKey);
      // THAY THẾ CỬA SỔ THÔNG BÁO BẰNG LỆNH NÀY:
      setKoboldKeySaved(true); 
    } catch (error) {
      console.error("Error saving KoboldAI API key:", error);
      setModalMessage({ show: true, title: 'Lỗi Lưu API Key', content: `Lưu API Key KoboldAI thất bại: ${error.message}`, type: 'error' });
      setKoboldKeySaved(false); // Đảm bảo tick xanh biến mất nếu có lỗi
    }
    setIsLoading(false);
  };

  const loadKoboldApiKey = async (currentUserId) => { // THÊM LẠI tham số currentUserId
    if (!currentUserId) return null; // SỬ DỤNG tham số này để kiểm tra
    try {
        // SỬA LẠI ĐƯỜNG DẪN BỊ HỎNG
        const koboldApiKeyRef = doc(db, `artifacts/${appId}/users/${currentUserId}/apiCredentials/kobold`);
        const docSnap = await getDoc(koboldApiKeyRef);
        if (docSnap.exists()) {
            return docSnap.data().key;
        }
        return null;
    } catch (error) {
        console.error("Error loading KoboldAI API key:", error);
        return null;
    }
  };
const sanitizeDataForFirestore = (data) => {
    if (data === null || typeof data !== 'object') {
        return data;
    }

    if (Array.isArray(data)) {
        return data.map(item => sanitizeDataForFirestore(item));
    }

    const sanitizedObject = {};
    for (const key in data) {
        if (Object.prototype.hasOwnProperty.call(data, key)) {
            const value = data[key];
            // Chỉ thêm vào đối tượng mới nếu giá trị không phải là undefined
            if (value !== undefined) {
                sanitizedObject[key] = sanitizeDataForFirestore(value);
            }
        }
    }
    return sanitizedObject;
};
  //

  const openQuickLoreModal = useCallback((category, nameOrTitle) => {
    let item = null;
    const categoryKey = category.toLowerCase();
    if (knowledgeBase && knowledgeBase[categoryKey]) {
        item = knowledgeBase[categoryKey].find(i => 
            (i.Name && i.Name.trim().toLowerCase() === nameOrTitle.trim().toLowerCase()) || 
            (i.NPC && i.NPC.trim().toLowerCase() === nameOrTitle.trim().toLowerCase()) ||
            (i.name && i.name.trim().toLowerCase() === nameOrTitle.trim().toLowerCase()) ||
            (i.title && i.title.trim().toLowerCase() === nameOrTitle.trim().toLowerCase()) // For quests
        );
    }
    if (item) {
        setQuickLoreContent({...item, category: categoryKey}); 
        setShowQuickLoreModal(true);
    } else {
        console.warn(`Quick lore not found for category '${categoryKey}', name/title '${nameOrTitle}'.`);
        setModalMessage({show: true, title: "Không Tìm Thấy", content: `Không tìm thấy thông tin chi tiết cho '${nameOrTitle}'.`, type: 'info'});
    }
  }, [knowledgeBase]);

    useEffect(() => {
    // Chỉ chạy khi lượt chơi thay đổi và không phải lượt đầu tiên
    if (currentTurn > 1 && currentScreen === 'gameplay') {
        setKnowledgeBase(prev => {
            if (!prev.playerSkills || prev.playerSkills.length === 0) {
                return prev;
            }
            const updatedSkills = prev.playerSkills.map(skill => ({
                ...skill,
                currentCooldown: Math.max(0, (skill.currentCooldown || 0) - 1)
            }));
            return { ...prev, playerSkills: updatedSkills };
        });
    }
}, [currentTurn]); // Phụ thuộc vào `currentTurn`
    // *** BẮT ĐẦU SỬA LỖI: Loại bỏ khai báo biến trùng lặp ***
    useEffect(() => {
        const unsubscribe = onAuthStateChanged(auth, async (user) => {
            if (user) {
                setUserId(user.uid);

                const [userGeminiKey, userKoboldKey, loadedWorldKnowledge] = await Promise.all([
                    loadApiKey(user.uid),
                    loadKoboldApiKey(user.uid),
                    loadWorldKnowledge(user.uid)
                ]);

                if (loadedWorldKnowledge) {
                    setWorldKnowledge(loadedWorldKnowledge);
                }

                if (userGeminiKey) {
                    setApiKey(userGeminiKey);
                    setInputApiKey(userGeminiKey);
                    setApiMode('userKey');
                    setApiKeyStatus({ status: 'Đã kết nối', message: 'API Key của Gemini đã được tải.', color: 'text-green-500' });
                } else {
                    setApiMode('defaultGemini');
                    setApiKeyStatus({
                        status: 'Đang dùng Gemini AI Mặc Định',
                        message: 'Không cần API Key.',
                        color: 'text-sky-400'
                    });
                }

                if (userKoboldKey) {
                    setKoboldApiKey(userKoboldKey);
                    setKoboldKeySaved(true);
                }

        } else {
            try {
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }
            } catch (error) {
                console.error("Error during sign-in:", error);
                setApiKeyStatus({ status: 'Lỗi xác thực', message: `Không thể xác thực: ${error.message}`, color: 'text-red-500' });
            }
        }
            setIsAuthReady(true);
        });
        return () => unsubscribe();
    }, []);
    // *** KẾT THÚC SỬA LỖI ***

  useEffect(() => {
    if (isAuthReady && userId) {
      const gamesCollectionPath = `artifacts/${appId}/users/${userId}/games`;
      const q = query(collection(db, gamesCollectionPath));
      
      const unsubscribe = onSnapshot(q, (querySnapshot) => {
    // Dùng .map() để tạo ra một mảng hoàn toàn mới. Đây là chìa khóa để sửa lỗi.
    const newGames = querySnapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    }));

    // Sắp xếp mảng mới này
    newGames.sort((a, b) => {
        const timeA = a.updatedAt?.toDate ? a.updatedAt.toDate().getTime() : 0;
        const timeB = b.updatedAt?.toDate ? b.updatedAt.toDate().getTime() : 0;
        return timeB - timeA;
    });

    // Cập nhật state với một mảng mới, buộc React phải render lại
    setSavedGames(newGames);

    }, (error) => {
        console.error("Error fetching saved games:", error);
        setModalMessage({ show: true, title: 'Lỗi Tải Game', content: `Không thể tải danh sách game đã lưu: ${error.message}`, type: 'error' });
    });
      return () => unsubscribe();
    }
  }, [isAuthReady, userId]);
    // *** BẮT ĐẦU CODE MỚI: Logic lưu/tải World Knowledge ***
  const loadWorldKnowledge = async (uid) => {
    if (!uid) return null;
    try {
      const worldDocRef = doc(db, `artifacts/${appId}/users/${uid}/worldKnowledge/default`);
      const docSnap = await getDoc(worldDocRef);
      if (docSnap.exists()) {
        console.log("Tải Kho Tri Thức Thế Giới từ Firestore thành công!");
        return docSnap.data();
      }
      console.log("Không tìm thấy Kho Tri Thức nào trên Firestore, sử dụng dữ liệu mặc định.");
      return null; // Trả về null nếu không có gì để AI sử dụng dữ liệu mặc định
    } catch (error) {
      console.error("Lỗi khi tải Kho Tri Thức Thế Giới:", error);
      setModalMessage({ show: true, title: 'Lỗi Tải Thế Giới', content: `Không thể tải dữ liệu thế giới đã lưu: ${error.message}`, type: 'error' });
      return null;
    }
  };

  // *** DEBUG HELPER FUNCTIONS ***
  const debugWorldKnowledge = () => {
    console.log("=== DEBUG WORLD KNOWLEDGE ===");
    console.log("Items:", worldKnowledge.items?.length || 0);
    console.log("Skills:", worldKnowledge.skills?.length || 0);
    console.log("NPCs:", worldKnowledge.npcs?.length || 0);
    console.log("Locations:", worldKnowledge.locations?.length || 0);
    console.log("Concepts:", worldKnowledge.concepts?.length || 0);
    console.log("Events:", worldKnowledge.events?.length || 0);
    console.log("Races:", worldKnowledge.races?.length || 0);
    console.log("Cultivation Systems:", worldKnowledge.cultivationSystems?.length || 0);
    console.log("Full data:", worldKnowledge);
    console.log("============================");
  };

  // Thêm vào window để có thể gọi từ Console
  window.debugWorldKnowledge = debugWorldKnowledge;

  const saveWorldKnowledge = async () => {
    if (!userId) {
        console.warn("Không thể lưu Kho Tri Thức: Chưa có User ID.");
        return;
    }
    try {
        const worldDocRef = doc(db, `artifacts/${appId}/users/${userId}/worldKnowledge/default`);
        // Dùng setDoc với merge:false để ghi đè hoàn toàn, đảm bảo dữ liệu được đồng bộ
        await setDoc(worldDocRef, worldKnowledge, { merge: false });
        console.log("Lưu Kho Tri Thức Thế Giới vào Firestore thành công!");
        setModalMessage({ show: true, title: 'Thành Công', content: 'Đã lưu các thay đổi của thế giới lên máy chủ.', type: 'success' });
    } catch(error) {
        console.error("Lỗi khi lưu Kho Tri Thức Thế Giới:", error);
        setModalMessage({ show: true, title: 'Lỗi Lưu Thế Giới', content: `Không thể lưu dữ liệu thế giới: ${error.message}`, type: 'error' });
    }
  };
  // *** KẾT THÚC CODE MỚI ***

  const handleInputChange = useCallback((e) => {
    const { name, value, type, checked } = e.target;
    const val = type === 'checkbox' ? checked : value;

    setGameSettings(prev => {
        const newSettings = { ...prev, [name]: val };

        // *** BẮT ĐẦU LOGIC MỚI CHO VẤN ĐỀ 2 ***

        // Khi thay đổi Hệ Tu Luyện, reset Cảnh Giới về mức đầu tiên và Level về 1
        if (name === 'initialCultivationSystem') {
            const newSystem = worldKnowledge.cultivationSystems.find(s => s.systemName === val);
            if (newSystem && newSystem.realms.length > 0) {
                newSettings.initialRealm = newSystem.realms[0];
                newSettings.initialLevel = 1;
            }
        }

        // Khi thay đổi Cảnh Giới, reset Level về mức khởi đầu của cảnh giới đó
        if (name === 'initialRealm') {
            const currentSystem = worldKnowledge.cultivationSystems.find(s => s.systemName === newSettings.initialCultivationSystem);
            if (currentSystem) {
                const realmIndex = currentSystem.realms.indexOf(val);
                if (realmIndex !== -1) {
                    const startingLevel = (realmIndex * 10) + 1;
                    newSettings.initialLevel = startingLevel;
                }
            }
        }
        
        // *** KẾT THÚC LOGIC MỚI CHO VẤN ĐỀ 2 ***

        if (name === "difficulty" && val !== "Tuỳ Chỉnh AI") {
            newSettings.difficultyDescription = '';
        }
        if (name === "useCharacterGoal" && !val) {
            newSettings.characterGoal = '';
        }
        return newSettings;
    });
  }, [worldKnowledge]); // Thêm worldKnowledge vào dependency array

    // Hàm thêm một đặc điểm mới
    const addInitialTrait = () => {
        setGameSettings(prev => ({
            ...prev,
            initialTraits: [...prev.initialTraits, {
                id: crypto.randomUUID(),
                name: '',
                description: '[Chưa có]', // Quy ước để AI biết cần điền
                category: 'Kỹ năng',
                type: 'Chủ động',
                manaCost: 0,
                cooldown: 0,
                effect: '[Chưa có]', // Quy ước để AI biết cần điền
                itemType: 'Khác',
                equippable: false,
                usable: false,
                consumable: false,
                uses: 0,
                effectDescription: '[Chưa có]', // Quy ước để AI biết cần điền
                statsBonus: '', // *** THÊM MỚI ***
                sideEffect: '[Không có]', // Quy ước để AI biết cần điền
            }]
        }));
    };

    // Hàm xóa một đặc điểm theo ID
    const removeInitialTrait = (idToRemove) => {
        setGameSettings(prev => ({
            ...prev,
            initialTraits: prev.initialTraits.filter(trait => trait.id !== idToRemove)
        }));
    };

    // Hàm cập nhật thông tin (tên, mô tả) của một đặc điểm
    const handleInitialTraitChange = (idToChange, field, value) => {
        setGameSettings(prev => ({
            ...prev,
            initialTraits: prev.initialTraits.map(trait => {
                if (trait.id !== idToChange) return trait;

                let updatedValue = value;
                if (field === 'description' && value.trim() === '') {
                    updatedValue = '[Chưa có]';
                }

                // Cập nhật cả các trường mới
                if (['name', 'description', 'category', 'statsBonus'].includes(field)) {
                    return { ...trait, [field]: updatedValue };
                }
                return trait;
            })
        }));
    };

    const handleInitialSkillChange = (idToChange, field, value) => {
        setGameSettings(prev => ({
            ...prev,
            preferredInitialSkills: prev.preferredInitialSkills.map(skill => 
                skill.id === idToChange ? { ...skill, [field]: value } : skill
            )
        }));
    };
  const addInitialWorldElement = () => {
    console.log("[DEBUG] GameSetup: Adding new initial entity with default npcType 'Character'.");
    setGameSettings(prev => {
        // Lấy hệ thống tu luyện đầu tiên làm mặc định
        const defaultSystem = worldKnowledge.cultivationSystems[0] || { systemName: 'Tu Tiên', realms: ['Phàm Nhân'] };
        const defaultTalent = TALENT_TIERS[0] || { name: 'Phàm Thể' };

        return {
            ...prev,
            initialWorldElements: [
                ...prev.initialWorldElements,
                {
                    id: crypto.randomUUID(),
                    type: 'NPC', // Loại thực thể chính
                    npcType: 'Character', // Phân loại NPC chi tiết
                    name: '',
                    description: '',
                    personality: '',
                    // Thêm các trường mới với giá trị mặc định
                    cultivationSystem: defaultSystem.systemName,
                    talentTier: defaultTalent.name,
                    realm: defaultSystem.realms[0],
                    level: 1,
                    skills: [] // THÊM MỚI: skills: []
                }
            ]
        };
    });
  };
  const removeInitialWorldElement = (id) => {
    setGameSettings(prev => ({
        ...prev,
        initialWorldElements: prev.initialWorldElements.filter(el => el.id !== id)
    }));
  };

const handleInitialElementChange = useCallback((index, event) => {
// Dòng code ngay bên dưới của dòng code gốc:
    const { name, value } = event.target;
    setGameSettings(prev => {
        const updatedElements = [...prev.initialWorldElements];
        
        // KIỂM TRA NẾU "name" là "skills" thì gán thẳng giá trị mảng, không cần xử lý thêm
        if (name === 'skills') {
            console.log(`[DEBUG] Updating skills for initial element at index ${index}`, value);
            updatedElements[index] = { ...updatedElements[index], skills: value };
            return { ...prev, initialWorldElements: updatedElements };
        }

        let newElement = { ...updatedElements[index], [name]: value };

        // Logic cũ: Khi thay đổi Hệ Tu Luyện, reset Cảnh Giới
        if (name === 'cultivationSystem') {
            const newSystem = worldKnowledge.cultivationSystems.find(s => s.systemName === value);
            if (newSystem && newSystem.realms.length > 0) {
                newElement.realm = newSystem.realms[0];
                // Đồng thời reset level về 1 khi đổi cả hệ thống
                newElement.level = 1;
            }
        }

        // *** BẮT ĐẦU SỬA ĐỔI: Khi thay đổi Cảnh Giới, tự động cập nhật Level ***
        if (name === 'realm') {
            const currentSystem = worldKnowledge.cultivationSystems.find(s => s.systemName === newElement.cultivationSystem);
            if (currentSystem) {
                const realmIndex = currentSystem.realms.indexOf(value);
                if (realmIndex !== -1) {
                    // Cấp độ bắt đầu của cảnh giới = (chỉ số cảnh giới * 10) + 1
                    const startingLevel = (realmIndex * 10) + 1;
                    newElement.level = startingLevel;
                }
            }
        }
        
        // Đảm bảo level luôn là một con số
        if (name === 'level') {
            newElement.level = parseInt(value, 10) || 1;
        }
        // *** KẾT THÚC SỬA ĐỔI ***

        updatedElements[index] = newElement;
        return { ...prev, initialWorldElements: updatedElements };
    });
}, [worldKnowledge]);
  const handleGenerateInitialElementDescription = async (index) => {
    if (apiMode === 'userKey' && !apiKey) {
        setModalMessage({ show: true, title: 'Thiếu API Key', content: 'Vui lòng thiết lập API Key.', type: 'error' });
        setShowApiModal(true);
        return;
    }
    const element = gameSettings.initialWorldElements[index];
    if (!element || !element.name) {
        setModalMessage({show: true, title: "Thiếu Tên", content: "Vui lòng nhập tên thực thể trước khi tạo mô tả.", type: "info"});
        return;
    }

    setIsGeneratingInitialElementDesc(prev => ({...prev, [element.id]: true}));
    
    const { theme, setting } = gameSettings; 
    const personalityInfo = element.type === 'NPC' && element.personality ? `Tính cách NPC đã cho: ${element.personality}.` : 'Tính cách NPC: AI tự quyết định cho phù hợp.';
    const promptText = `Dựa trên các thông tin sau:
    Chủ đề game: '${theme || "Chưa rõ"}'
    Bối cảnh game: '${setting || "Chưa rõ"}'
    Tên thực thể: '${element.name}'
    Loại thực thể: '${element.type}'
    ${personalityInfo}
    Hãy ✨ viết một mô tả ngắn gọn (1-3 câu, tối đa 150 chữ) bằng tiếng Việt cho thực thể này để sử dụng trong việc kiến tạo thế giới ban đầu của trò chơi phiêu lưu văn bản. Mô tả cần phù hợp với các thông tin đã cho. Phong cách viết nên theo tiểu thuyết mạng Trung Quốc.`;
    
    const generatedText = await fetchGenericGeminiText(promptText);
    if (generatedText) {
        setGameSettings(prev => {
            const updatedElements = [...prev.initialWorldElements];
            updatedElements[index] = { ...updatedElements[index], description: generatedText };
            return { ...prev, initialWorldElements: updatedElements };
        });
    }
    setIsGeneratingInitialElementDesc(prev => ({...prev, [element.id]: false}));
  };


  const saveApiKey = async () => { 
    if (!userId) {
      setModalMessage({ show: true, title: 'Lỗi', content: 'Người dùng chưa được xác thực để lưu API Key.', type: 'error' });
      return;
    }
    if (!inputApiKey.trim()) {
        setModalMessage({ show: true, title: 'Thiếu Thông Tin', content: 'API Key không được để trống.', type: 'error' });
        return;
    }
    setIsLoading(true); 
    try {
      const apiKeyRef = doc(db, `artifacts/${appId}/users/${userId}/apiCredentials/gemini`);
      await setDoc(apiKeyRef, { key: inputApiKey, lastUpdated: serverTimestamp() });
      setApiKey(inputApiKey); 
      setApiMode('userKey'); 
      setApiKeyStatus({ status: 'Đã lưu', message: 'API Key của bạn đã được lưu thành công!', color: 'text-green-500' });
      setShowApiModal(false);
      setModalMessage({ show: true, title: 'Thành Công', content: 'API Key của bạn đã được lưu!', type: 'success' });
    } catch (error) {
      console.error("Error saving API key:", error);
      setApiKeyStatus({ status: 'Lỗi', message: `Lưu API Key thất bại: ${error.message}`, color: 'text-red-500' });
      setModalMessage({ show: true, title: 'Lỗi Lưu API Key', content: `Lưu API Key thất bại: ${error.message}`, type: 'error' });
    }
    setIsLoading(false);
  };

  const loadApiKey = async (currentUserId) => {
    if (!currentUserId) return null;
    try {
      const apiKeyRef = doc(db, `artifacts/${appId}/users/${currentUserId}/apiCredentials/gemini`);
      const docSnap = await getDoc(apiKeyRef);
      if (docSnap.exists()) {
        return docSnap.data().key;
      }
      return null;
    } catch (error) {
      console.error("Error loading API key:", error);
      setModalMessage({ show: true, title: 'Lỗi Tải API Key', content: `Không thể tải API Key đã lưu: ${error.message}`, type: 'error' });
      return null;
    }
  };

  const testApiKey = async () => { 
    if (!inputApiKey) {
      setApiKeyStatus({ status: 'Chưa nhập Key', message: 'Vui lòng nhập API Key để kiểm tra.', color: 'text-yellow-500' });
      setModalMessage({ show: true, title: 'Thiếu Thông Tin', content: 'Vui lòng nhập API Key để kiểm tra.', type: 'info' });
      return;
    }
    setIsLoading(true);
    setApiKeyStatus({ status: 'Đang kiểm tra...', message: 'Vui lòng đợi.', color: 'text-blue-500' });

    const payload = {
      contents: [{ role: "user", parts: [{ text: "Xin chào! Đây là một bài kiểm tra kết nối." }] }],
    };
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${inputApiKey}`;

    try {
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      const result = await response.json();

      if (response.ok && result.candidates && result.candidates.length > 0) {
        setApiKeyStatus({ status: 'Thành công (Key đang nhập)', message: 'API Key hợp lệ và kết nối thành công!', color: 'text-green-500' });
        setModalMessage({ show: true, title: 'Kiểm Tra Thành Công', content: 'API Key bạn vừa nhập hợp lệ!', type: 'success' });
      } else {
        const errorMessage = result.error?.message || `Mã lỗi ${response.status}. Vui lòng kiểm tra API Key và quyền truy cập.`;
        setApiKeyStatus({ status: 'Thất bại (Key đang nhập)', message: `Kiểm tra API Key thất bại: ${errorMessage}`, color: 'text-red-500' });
        setModalMessage({ show: true, title: 'Kiểm Tra Thất Bại', content: `Chi tiết: ${errorMessage}`, type: 'error' });
      }
    } catch (error) {
      console.error('Error testing API key:', error);
      setApiKeyStatus({ status: 'Lỗi Mạng (Key đang nhập)', message: `Lỗi kết nối: ${error.message}. Vui lòng kiểm tra mạng của bạn.`, color: 'text-red-500' });
      setModalMessage({ show: true, title: 'Lỗi Kết Nối', content: `Không thể kết nối đến API: ${error.message}`, type: 'error' });
    }
    setIsLoading(false);
  };
  
  const fetchGenericGeminiText = async (promptText) => {
    const effectiveApiKey = apiMode === 'defaultGemini' ? "" : apiKey;
    if (apiMode === 'userKey' && !effectiveApiKey) {
      setModalMessage({ show: true, title: 'Lỗi API Key', content: 'API Key của bạn chưa được cấu hình. Vui lòng vào Thiết Lập API.', type: 'error' });
      setShowApiModal(true);
      return null;
    }

    const payload = { contents: [{ role: "user", parts: [{ text: promptText }] }] };
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${effectiveApiKey}`;

    try {
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      const result = await response.json();
      if (result.candidates && result.candidates[0]?.content?.parts[0]?.text) {
        return result.candidates[0].content.parts[0].text.trim(); // Trim the response
      } else {
        const errorMsg = result.error?.message || "Không thể lấy dữ liệu từ AI.";
        console.error("Gemini API error response:", JSON.stringify(result, null, 2));
        setModalMessage({ show: true, title: 'Lỗi AI', content: errorMsg, type: 'error' });
        return null;
      }
    } catch (error) {
      console.error('Error fetching generic Gemini text:', error);
      setModalMessage({ show: true, title: 'Lỗi Mạng', content: `Lỗi kết nối khi gọi AI: ${error.message}`, type: 'error' });
      return null;
    }
  };
  
  
    // HÀM MỚI: Dùng AI để biến Đặc điểm thành Kỹ năng chi tiết
    const fetchSkillDetailsFromAI = async (trait) => {
        const effectiveApiKey = apiMode === 'defaultGemini' ? "" : apiKey;

        const prompt = `
            Bạn là một chuyên gia thiết kế game nhập vai (Game Master). Dựa trên thông tin về một "Đặc điểm khởi đầu" do người chơi cung cấp, hãy phân tích và biến nó thành một "Kỹ năng" hoàn chỉnh trong game.
            Thông tin đầu vào:
                - Chủ đề thế giới: "<span class="math-inline">\{gameSettings\.theme \|\| 'Chưa xác định'\}"
                - Tên đặc điểm/kỹ năng: "{trait.name}"
                - Mô tả ngắn của người chơi: "${trait.description || '(Người chơi không cung cấp mô tả, hãy dựa vào Tên đặc điểm và Chủ đề thế giới để tự sáng tạo một mô tả phù hợp.)'}"

            Yêu cầu:
            Dựa vào Tên và Mô tả, hãy quyết định các thuộc tính sau:
            1.  "Type": Phân loại kỹ năng (VD: Chủ động, Bị động, Thần thông, Tuyệt kỹ, Thiên phú, Nội tại...). Nếu nó giống một thiên phú hoặc kỹ năng bị động, hãy chọn "Thiên phú" hoặc "Bị động". Nếu nó giống một chiêu thức tấn công hãy chọn "Chủ động" hoặc "Tuyệt kỹ".
            2.  "manaCost": Lượng Mana tiêu hao. Nếu là kỹ năng bị động/thiên phú, giá trị là 0. Nếu là kỹ năng chủ động, hãy đặt một con số hợp lý (VD: 10, 25, 50).
            3.  "cooldown": Số lượt hồi chiêu. Nếu là kỹ năng bị động/thiên phú, giá trị là 0. Nếu là kỹ năng chủ động, hãy đặt một con số hợp lý (VD: 0 cho chiêu thường, 3-5 cho chiêu mạnh).
            4.  "effect": Mô tả chi tiết, rõ ràng về tác dụng của kỹ năng trong game, dựa trên mô tả gốc của người chơi nhưng cụ thể và rõ ràng hơn cho game.

            Chỉ trả về một đối tượng JSON duy nhất theo cấu trúc sau, không thêm bất kỳ giải thích hay ký tự nào khác.
        `;
    
    const schema = {
        type: "OBJECT",
        properties: {
            Type: { type: "STRING", description: "Loại kỹ năng." },
            manaCost: { type: "NUMBER", description: "Lượng Mana tiêu hao." },
            cooldown: { type: "NUMBER", description: "Số lượt hồi chiêu." },
            effect: { type: "STRING", description: "Mô tả chi tiết tác dụng." },
        },
        required: ["Type", "manaCost", "cooldown", "effect"],
    };

    const payload = {
        contents: [{ role: "user", parts: [{ text: prompt }] }],
        generationConfig: {
            response_mime_type: "application/json",
            response_schema: schema,
        }
    };
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${effectiveApiKey}`;

    try {
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
        });
        const result = await response.json();
        
        if (result.candidates && result.candidates[0]?.content?.parts[0]?.text) {
            const jsonText = result.candidates[0].content.parts[0].text;
            const details = JSON.parse(jsonText);
            // Trả về một đối tượng kỹ năng hoàn chỉnh
            return {
                id: trait.id || crypto.randomUUID(),
                Name: trait.name,
                Description: trait.description,
                ...details,
                currentCooldown: 0,
            };
        } else {
            const errorMsg = result.error?.message || `Không thể lấy chi tiết kỹ năng cho "${trait.name}".`;
            throw new Error(errorMsg);
        }
    } catch (error) {
        console.error(`Lỗi khi gọi AI cho kỹ năng "${trait.name}":`, error);
        throw error; // Ném lỗi ra ngoài để hàm initializeGame bắt được
    }
};
  const handleFetchSuggestions = async (fieldType) => {
    if (apiMode === 'userKey' && !apiKey) {
      setModalMessage({ show: true, title: 'Thiếu API Key', content: 'Vui lòng thiết lập API Key để sử dụng tính năng này.', type: 'error' });
      setShowApiModal(true);
      return;
    }
    setIsFetchingSuggestions(true);
    setShowSuggestionsModal({ show: true, fieldType, suggestions: [], isLoading: true, title: fieldType === 'theme' ? "✨ Gợi Ý Chủ Đề" : "✨ Gợi Ý Bối Cảnh" });


    let promptText = '';
    if (fieldType === 'theme') {
      promptText = "Hãy gợi ý 5 chủ đề độc đáo và hấp dẫn bằng tiếng Việt cho một trò chơi phiêu lưu bằng văn bản (text adventure game) theo phong cách tiểu thuyết mạng Trung Quốc. Mỗi chủ đề trên một dòng, không cần đánh số đầu dòng.";
    } else if (fieldType === 'setting') {
      const currentTheme = gameSettings.theme || 'phiêu lưu chung';
      promptText = `Hãy gợi ý 5 bối cảnh (thế giới/môi trường) thú vị và chi tiết bằng tiếng Việt cho một trò chơi phiêu lưu bằng văn bản có chủ đề là '${currentTheme}' theo phong cách tiểu thuyết mạng Trung Quốc. Mỗi bối cảnh trên một dòng, không cần đánh số đầu dòng.`;
    }

    const suggestionsText = await fetchGenericGeminiText(promptText);
    if (suggestionsText) {
      const suggestionsArray = suggestionsText.split('\n').map(s => s.trim()).filter(s => s);
      setShowSuggestionsModal(prev => ({ ...prev, suggestions: suggestionsArray, isLoading: false }));
    } else {
      setShowSuggestionsModal(prev => ({ ...prev, suggestions: [], isLoading: false })); 
    }
    setIsFetchingSuggestions(false);
  };
  
  const handleGenerateBackstory = async () => {
     if (apiMode === 'userKey' && !apiKey) {
      setModalMessage({ show: true, title: 'Thiếu API Key', content: 'Vui lòng thiết lập API Key để sử dụng tính năng này.', type: 'error' });
      setShowApiModal(true);
      return;
    }
    setIsGeneratingContent(true);
    const { characterName, characterGender, theme, setting, characterPersonality } = gameSettings; 
    const personalityInfo = (characterPersonality && characterPersonality !== PLAYER_PERSONALITIES[0]) ? `Tính cách: ${characterPersonality}.` : 'Tính cách sẽ do người chơi chọn sau.';
    const promptText = `Dựa vào các thông tin sau: Tên nhân vật='${characterName || 'Nhân vật chính'}', Giới tính='${characterGender}', ${personalityInfo} Chủ đề game='${theme || 'Chưa rõ'}', Bối cảnh game='${setting || 'Chưa rõ'}', hãy ✨ viết một đoạn sơ lược tiểu sử hoặc đặc điểm nổi bật (khoảng 2-3 câu, tối đa 150 chữ) bằng tiếng Việt cho nhân vật này để sử dụng trong một trò chơi phiêu lưu bằng văn bản, theo văn phong tiểu thuyết mạng Trung Quốc. Tiểu sử nên phản ánh tính cách đã chọn (nếu có).`;
    
    const backstoryText = await fetchGenericGeminiText(promptText);
    if (backstoryText) {
      setGameSettings(prev => ({ ...prev, characterBackstory: backstoryText }));
    }
    setIsGeneratingContent(false);
  };

  const handleGenerateDifficultyDescription = async () => {
    if (apiMode === 'userKey' && !apiKey) {
        setModalMessage({ show: true, title: 'Thiếu API Key', content: 'Vui lòng thiết lập API Key để sử dụng tính năng này.', type: 'error' });
        setShowApiModal(true);
        return;
    }
    setIsGeneratingDifficultyDesc(true);
    const { theme, setting } = gameSettings;
    const promptText = `Dựa trên chủ đề game là '${theme || "Chưa rõ"}' và bối cảnh '${setting || "Chưa rõ"}', hãy ✨ viết một mô tả ngắn gọn (1-2 câu, tối đa 100 chữ) bằng tiếng Việt về độ khó "Tuỳ Chỉnh AI" cho trò chơi này, theo văn phong tiểu thuyết mạng Trung Quốc. Mô tả này nên gợi ý về những thử thách hoặc đặc điểm riêng của độ khó này.`;
    
    const descText = await fetchGenericGeminiText(promptText);
    if (descText) {
        setGameSettings(prev => ({ ...prev, difficultyDescription: descText }));
    }
    setIsGeneratingDifficultyDesc(false);
  };

  const handleGenerateGoal = async () => {
    if (apiMode === 'userKey' && !apiKey) {
        setModalMessage({ show: true, title: 'Thiếu API Key', content: 'Vui lòng thiết lập API Key.', type: 'error' });
        setShowApiModal(true);
        return;
    }
    setIsGeneratingGoal(true);
    const { theme, setting, characterPersonality, characterBackstory } = gameSettings; 
    const personalityInfo = (characterPersonality && characterPersonality !== PLAYER_PERSONALITIES[0]) ? `Tính cách nhân vật: ${characterPersonality}.` : '';
    const backstoryInfo = characterBackstory ? `Tiểu sử nhân vật: ${characterBackstory}.` : '';

    const promptText = `Dựa trên các thông tin sau:
    Chủ đề game: '${theme || "Chưa rõ"}'
    Bối cảnh game: '${setting || "Chưa rõ"}'
    ${personalityInfo}
    ${backstoryInfo}
    Hãy ✨ gợi ý 3-4 mục tiêu hoặc động lực chính (khoảng 10-25 từ mỗi mục tiêu) bằng tiếng Việt cho nhân vật chính trong một trò chơi phiêu lưu văn bản. Các mục tiêu này nên phù hợp với thông tin đã cho và có thể tạo ra những diễn biến thú vị trong game. Trả về các gợi ý, mỗi gợi ý trên một dòng, không cần đánh số.`;
    
    const generatedText = await fetchGenericGeminiText(promptText);
    if (generatedText) {
        const suggestionsArray = generatedText.split('\n').map(s => s.trim()).filter(s => s);
        setShowSuggestionsModal({ 
            show: true, 
            fieldType: 'characterGoal', 
            suggestions: suggestionsArray, 
            isLoading: false,
            title: "✨ Gợi Ý Mục Tiêu/Động Lực"
        });
    } else {
        setModalMessage({show:true, title: "Không có gợi ý", content: "AI không thể tạo gợi ý mục tiêu lúc này. Hãy thử lại hoặc tự điền.", type: "info"})
    }
    setIsGeneratingGoal(false);
  };

  const handleGenerateCharacterName = async () => {
    if (apiMode === 'userKey' && !apiKey) {
        setModalMessage({ show: true, title: 'Thiếu API Key', content: 'Vui lòng thiết lập API Key.', type: 'error' });
        setShowApiModal(true);
        return;
    }
    setIsGeneratingCharacterName(true);
    const { theme, setting, characterGender } = gameSettings;
    const genderPrompt = characterGender === 'Không xác định' ? 'phi giới tính hoặc để AI tự quyết' : characterGender;
    const promptText = `Dựa trên chủ đề game là '${theme || "Chưa rõ"}', bối cảnh '${setting || "Chưa rõ"}', và giới tính nhân vật là '${genderPrompt}', hãy ✨ gợi ý MỘT tên nhân vật bằng tiếng Việt theo phong cách tiểu thuyết mạng Trung Quốc. Chỉ trả về tên nhân vật đó, không thêm bất kỳ lời giải thích nào.`;
    
    const generatedName = await fetchGenericGeminiText(promptText);
    if (generatedName) {
        setGameSettings(prev => ({ ...prev, characterName: generatedName.split('\n')[0].trim() })); // Take first line if multiple
    }
    setIsGeneratingCharacterName(false);
  };

  const handleGenerateInitialSkill = async () => {
    if (apiMode === 'userKey' && !apiKey) {
        setModalMessage({ show: true, title: 'Thiếu API Key', content: 'Vui lòng thiết lập API Key.', type: 'error' });
        setShowApiModal(true);
        return;
    }
    setIsGeneratingInitialSkill(true);
    const { theme, setting, characterName, characterPersonality, characterBackstory } = gameSettings;
    const promptText = `Dựa trên chủ đề game '${theme || "Chưa rõ"}', bối cảnh '${setting || "Chưa rõ"}', tên nhân vật '${characterName || "Nhân vật chính"}', tính cách '${characterPersonality}', và sơ lược tiểu sử '${characterBackstory || "Chưa rõ"}', hãy ✨ gợi ý MỘT kỹ năng khởi đầu phù hợp bằng tiếng Việt (ví dụ: 'Hỏa Cầu Thuật sơ cấp', 'Ẩn Thân Thuật'). Chỉ trả về tên kỹ năng đó, không thêm mô tả chi tiết hay lời giải thích.`;

    const generatedSkill = await fetchGenericGeminiText(promptText);
    if (generatedSkill) {
        setGameSettings(prev => ({ ...prev, preferredInitialSkill: generatedSkill.split('\n')[0].trim() })); // Take first line
    }
    setIsGeneratingInitialSkill(false);
  };
// *** THÊM MỚI HOÀN TOÀN ***
  // Hàm này sẽ gọi AI để tóm tắt các sự kiện gần đây và cập nhật đại cương
  const updateStoryOutline = async () => {
    // Chỉ cập nhật nếu có diễn biến câu chuyện
    if (storyHistory.length === 0) return;

    console.log(`Lượt ${currentTurn + 1}: Bắt đầu cập nhật Đại Cương...`); // Tăng currentTurn để log cho đúng lượt sắp tới
    // KHÔNG cần setIsProcessingAction ở đây nữa

    const recentHistory = storyHistory.slice(-OUTLINE_UPDATE_INTERVAL)
      .map(item => `[${item.type === 'story' ? 'Diễn biến' : 'Hành động'}] ${item.content}`)
      .join('\n');
      
    const prompt = `
      Bạn là một người ghi chép lịch sử thông thái. Dựa vào **Đại cương cũ** và **Các sự kiện gần đây**, hãy cập nhật lại Đại cương câu chuyện một cách ngắn gọn, súc tích.

      **Đại cương cũ:**
      ${knowledgeBase.storyOutline || "Chưa có đại cương."}

      **Các sự kiện gần đây:**
      ${recentHistory}

      **Yêu cầu:**
      1. Đọc và hiểu Đại cương cũ.
      2. Tóm tắt các sự kiện MỚI quan trọng nhất từ "Các sự kiện gần đây". Chỉ tập trung vào:
          * Những thay đổi lớn trong cốt truyện (plot twists).
          * Sự phát triển hoặc thay đổi lớn của nhân vật chính.
          * Các mối quan hệ quan trọng được hình thành hoặc bị phá vỡ.
          * Các bí ẩn, mục tiêu mới xuất hiện hoặc được giải quyết.
      3. Kết hợp tóm tắt mới này vào Đại cương cũ. Ngươi có thể viết lại một vài điểm cũ cho súc tích hơn nhưng không được xóa bỏ những sự kiện quan trọng.
      4. Trả về **CHỈ DUY NHẤT** nội dung của Đại cương đã được cập nhật, dưới dạng các gạch đầu dòng ngắn gọn.
    `;

    try {
      const updatedOutlineText = await fetchGenericGeminiText(prompt);
      if (updatedOutlineText) {
        // Cập nhật state trực tiếp và trả về một promise đã giải quyết
        return new Promise(resolve => {
            setKnowledgeBase(prev => {
                const newKnowledge = { ...prev, storyOutline: updatedOutlineText };
                console.log("Đại cương đã được AI cập nhật vào state.");
                resolve(true); // Báo hiệu đã xong
                return newKnowledge;
            });
        });
      }
    } catch (error) {
      console.error("Lỗi khi cập nhật đại cương:", error);
    }
    // KHÔNG cần finally và setIsProcessingAction nữa
    return Promise.resolve(true); // Luôn trả về để không chặn luồng chính
  };



  const handleGenerateSuggestedActions = async () => {
    if (apiMode === 'userKey' && !apiKey) {
        setModalMessage({ show: true, title: 'Thiếu API Key', content: 'Vui lòng thiết lập API Key.', type: 'error' });
        setShowApiModal(true);
        return;
    }
    setIsGeneratingSuggestedActions(true);
    setSuggestedActionsList([]);

    const lastStoryItem = storyHistory.filter(item => item.type === 'story').pop()?.content || "Chưa có diễn biến.";
    const inventoryString = knowledgeBase.inventory.map(item => `${item.Name} (${item.Description || 'không rõ'})`).join(', ') || "trống";
    const skillsString = knowledgeBase.playerSkills.map(skill => `${skill.Name} (${skill.Description || 'không rõ'})`).join(', ') || "chưa có";
    const statusesString = knowledgeBase.playerStatus.map(status => `${status.name} (Ảnh hưởng: ${status.effects || 'không rõ'})`).join('; ') || "không có";
    const currentPersonality = gameSettings.characterPersonality; 
    const activeQuestsString = knowledgeBase.quests.filter(q => q.status === 'active').map(q => `${q.title} (Mục tiêu: ${q.objectives?.filter(o => !o.completed).map(o=>o.text).join(', ') || 'Hoàn thành các bước tiếp theo'})`).join('; ') || "không có";
    
    const promptText = `Bối cảnh hiện tại: ${lastStoryItem}
    Nhân vật chính: ${gameSettings.characterName || 'Nhân vật chính'}, Tính cách: ${currentPersonality}.
    Mục tiêu chính: ${gameSettings.useCharacterGoal && gameSettings.characterGoal ? gameSettings.characterGoal : 'Chưa rõ hoặc không có'}.
    Nhiệm vụ đang hoạt động: ${activeQuestsString}.
    Balo đồ: ${inventoryString}.
    Kỹ năng: ${skillsString}.
    Trạng thái hiện tại: ${statusesString}.
    Dựa vào tình hình trên, hãy ✨ gợi ý 3-4 hành động tùy ý ngắn gọn, thực tế và phù hợp bằng tiếng Việt mà nhân vật có thể thực hiện. Các hành động này NÊN liên quan đến nhiệm vụ đang hoạt động (nếu có) hoặc mục tiêu chính. Mỗi gợi ý trên một dòng, không đánh số. Ví dụ: "Thử dùng [Tên Kỹ Năng] lên [Đối Tượng]", "Hỏi [Tên NPC] về [Sự Việc]", "Kiểm tra [Đồ Vật] kỹ hơn". Cân nhắc các trạng thái hiện tại khi đưa ra gợi ý. Với một số hành động có rủi ro, hãy ghi chú thêm (Tỷ lệ thành công: Cao/Trung Bình/Thấp. Rủi ro: ... Phần thưởng: ...).`;

    const suggestionsText = await fetchGenericGeminiText(promptText);
    if (suggestionsText) {
        const suggestionsArray = suggestionsText.split('\n').map(s => s.trim()).filter(s => s);
        setSuggestedActionsList(suggestionsArray);
        setShowSuggestedActionsModal(true);
    } else {
        setModalMessage({show:true, title: "Không có gợi ý", content: "AI không thể tạo gợi ý hành động lúc này.", type: "info"})
    }
    setIsGeneratingSuggestedActions(false);
  };


// *** BẮT ĐẦU ĐOẠN CODE THAY THẾ ***
const parseGeminiResponseAndUpdateState = async (text) => {
    
    let storyContent = text;
    let extractedChoices = [];
    let definedPersonality = null;
    
    const newKnowledgeUpdates = { 
        npcs: [], items: [], locations: [], companions: [], 
        inventory: [], playerSkills: [], relationships: [],
        playerStatus: [], quests: [], 
        _removePlayerStatusByName: [], 
        _updateNpcStatus: [], 
        _updateQuest: [],
        _updateQuestObjective: [],
        _skillCooldowns: [], 
        _npcDamage: [],
        _cultivationPath: null,
        _nameUpdate: null,
        _personalityUpdate: null,
        _npcLogAdd: [],
// *** BẮT ĐẦU ĐOẠN CODE CẦN THÊM ***
        _npcUpdates: [],
// *** KẾT THÚC ĐOẠN CODE CẦN THÊM ***
        _toRemove: [],
        _toUpdate: [],
    };
    const worldKnowledgeUpdates = {};

    const tagPatterns = {
        DEFINE_RACE: /\[DEFINE_RACE:\s*([^\]]+)\]/gs,
        DEFINE_LOCATION: /\[DEFINE_LOCATION:\s*([^\]]+)\]/gs,
        DEFINE_CONCEPT: /\[DEFINE_CONCEPT:\s*([^\]]+)\]/gs,
        DEFINE_EVENT: /\[DEFINE_EVENT:\s*([^\]]+)\]/gs,
        DEFINE_ITEM: /\[DEFINE_ITEM:\s*([^\]]+)\]/gs,
        DEFINE_SKILL: /\[DEFINE_SKILL:\s*([^\]]+)\]/gs,
        DEFINE_CULTIVATION_SYSTEM: /\[DEFINE_CULTIVATION_SYSTEM:\s*([^\]]+)\]/gs,
        DEFINE_NPC: /\[DEFINE_NPC:\s*([^\]]+)\]/gs,
        LORE_NPC: /\[LORE_NPC:\s*([^\]]+)\]/gs,
        LORE_ITEM: /\[LORE_ITEM:\s*([^\]]+)\]/gs,
        LORE_LOCATION: /\[LORE_LOCATION:\s*([^\]]+)\]/gs,
        COMPANION: /\[COMPANION:\s*([^\]]+)\]/gs,
                SKILL_AQUIRED: /\[SKILL_AQUIRED:\s*([^\]]+)\]/gs, // <-- THÊM DÒNG NÀY
        ITEM_AQUIRED: /\[ITEM_AQUIRED:\s*([^\]]+)\]/gs,
        ITEM_REMOVED: /\[ITEM_REMOVED:\s*([^\]]+)\]/gs,
        SKILL_LEARNED: /\[SKILL_LEARNED:\s*([^\]]+)\]/gs,
        SKILL_UPGRADED: /\[SKILL_UPGRADED:\s*([^\]]+)\]/gs,
        SKILL_REMOVED: /\[SKILL_REMOVED:\s*Name="([^"]+)"\]/gs, // <-- THÊM DÒNG NÀY
        SKILL_FORGOTTEN: /\[SKILL_FORGOTTEN:\s*Name="([^"]+)"\]/gs,
        RELATIONSHIP_CHANGED: /\[RELATIONSHIP_CHANGED:\s*([^\]]+)\]/gs,
        ITEM_CONSUMED: /\[ITEM_CONSUMED:\s*([^\]]+)\]/gs, 
        ITEM_UPDATED: /\[ITEM_UPDATED:\s*([^\]]+)\]/gs,   
        STATUS_APPLIED_SELF: /\[STATUS_APPLIED_SELF:\s*([^\]]+)\]/gs,
        STATUS_CURED_SELF: /\[STATUS_CURED_SELF:\s*Name="([^"]+)"\]/gs, 
        STATUS_EXPIRED_SELF: /\[STATUS_EXPIRED_SELF:\s*Name="([^"]+)"\]/gs, 
        STATUS_APPLIED_NPC: /\[STATUS_APPLIED_NPC:\s*([^\]]+)\]/gs,
        STATUS_CURED_NPC: /\[STATUS_CURED_NPC:\s*NPCName="([^"]+)",\s*StatusName="([^"]+)"\]/gs,
        STATUS_EXPIRED_NPC: /\[STATUS_EXPIRED_NPC:\s*NPCName="([^"]+)",\s*StatusName="([^"]+)"\]/gs,
        QUEST_ASSIGNED: /\[QUEST_ASSIGNED:\s*([^\]]+)\]/gs,
        QUEST_UPDATED: /\[QUEST_UPDATED:\s*([^\]]+)\]/gs,
        QUEST_OBJECTIVE_COMPLETED: /\[QUEST_OBJECTIVE_COMPLETED:\s*([^\]]+)\]/gs,
        PLAYER_STATS_INIT: /\[PLAYER_STATS_INIT:\s*([^\]]+)\]/gs,
        STATS_UPDATE: /\[STATS_UPDATE:\s*([^\]]+)\]/gs,
        SKILL_COOLDOWN: /\[SKILL_COOLDOWN:\s*Name="([^"]+)"\]/gs,
        DAMAGE_NPC: /\[DAMAGE_NPC:\s*([^\]]+)\]/gs,
        SET_COMBAT_STATUS: /\[SET_COMBAT_STATUS:\s*(true|false)\]/gi,
        CULTIVATION_PATH_ADD: /\[CULTIVATION_PATH_ADD:\s*path="([^"]+)"\]/gs,
        NAME_UPDATE: /\[NAME_UPDATE:\s*([^\]]+)\]/gs,
        PERSONALITY_UPDATE: /\[PERSONALITY_UPDATE:\s*([^\]]+)\]/gs,
        NPC_UPDATE: /\[NPC_UPDATE:\s*([^\]]+)\]/gs, // Thêm thẻ mới
        NPC_LOG_ADD: /\[NPC_LOG_ADD:\s*([^\]]+)\]/gs,
        NPC_LEARNS_SKILL: /\[NPC_LEARNS_SKILL:\s*([^\]]+)\]/gs, // THÊM MỚI
    };

    const categoryMap = {
        LORE_NPC: 'npcs', LORE_ITEM: 'items', LORE_LOCATION: 'locations',
        COMPANION: 'companions', ITEM_AQUIRED: 'inventory', SKILL_LEARNED: 'playerSkills',
        RELATIONSHIP_CHANGED: 'relationships', ITEM_CONSUMED: 'inventory', ITEM_UPDATED: 'inventory',
        STATUS_APPLIED_SELF: 'playerStatus', QUEST_ASSIGNED: 'quests',
    };

    for (const tagType in tagPatterns) {
        const regex = tagPatterns[tagType];
        let match;
        const matchesToReplace = [];

        while ((match = regex.exec(storyContent)) !== null) {
            matchesToReplace.push(match[0]);
            const dataString = match[1];
            try {
                if (tagType === 'SKILL_FORGOTTEN' || tagType === 'SKILL_REMOVED') {
                    const skillNameToForget = match[1].trim();
                    updateBonusSkillStorage('FORGET', { skillName: skillNameToForget });
                    newKnowledgeUpdates._toRemove.push({ category: 'playerSkills', name: skillNameToForget });
                    continue; 
                }
                
                if (tagType === 'SKILL_UPGRADED') {
                    const parsedData = parseKeyValueString(dataString);
                    if (parsedData.OldName && parsedData.NewName) {
                        const newSkillData = {
                            id: crypto.randomUUID(), // Tạo ID mới cho kỹ năng nâng cấp
                            Name: parsedData.NewName,
                            Description: parsedData.Description || "",
                            Type: parsedData.Type || "Bị động",
                            manaCost: parsedData.manaCost ?? 0,
                            cooldown: parsedData.cooldown ?? 0,
                            effect: parsedData.effect || "",
                            currentCooldown: 0,
                            StatsBonus: parsedData.StatsBonus || "",
                        };
                        newKnowledgeUpdates.playerSkills.push(newSkillData);
                        updateBonusSkillStorage('UPGRADE', { oldSkillName: parsedData.OldName, newSkill: newSkillData });
                        newKnowledgeUpdates._toRemove.push({ category: 'playerSkills', name: parsedData.OldName });
                    }
                    continue;
                }
                
                if (tagType === 'SKILL_LEARNED' || tagType === 'SKILL_AQUIRED') { // SỬA DÒNG NÀY
                    const parsedData = parseKeyValueString(dataString);
                    if(parsedData.Name) {
                        const newSkill = {
                            id: crypto.randomUUID(), // Luôn tạo ID mới khi học
                            ...parsedData, // Lấy tất cả dữ liệu từ thẻ
                            StatsBonus: parsedData.StatsBonus || "", // Đảm bảo không phải null
                            currentCooldown: 0,
                        };
                        // Đẩy vào danh sách sẽ thêm vào knowledgeBase
                        newKnowledgeUpdates.playerSkills.push(newSkill);
                        // Cập nhật kho bonus
                        updateBonusSkillStorage('LEARN', { newSkill });
                    }
                    continue;
                }
                
                // Các logic xử lý thẻ khác giữ nguyên...
                 if (tagType === 'STATUS_CURED_SELF' || tagType === 'STATUS_EXPIRED_SELF') {
                    newKnowledgeUpdates._removePlayerStatusByName.push(match[1]); 
                } else if (tagType === 'STATUS_APPLIED_NPC') {
                    const parsedData = parseKeyValueString(match[1]); 
                    if (parsedData.NPCName && parsedData.Name) {
                         newKnowledgeUpdates._updateNpcStatus.push({ 
                            npcName: parsedData.NPCName, 
                            status: { id: crypto.randomUUID(), ...parsedData, NPCName: undefined } 
                        });
                    }
                } else if (tagType === 'STATUS_CURED_NPC' || tagType === 'STATUS_EXPIRED_NPC') {
                     newKnowledgeUpdates._updateNpcStatus.push({ 
                        npcName: match[1], 
                        removeStatusName: match[2] 
                    });
                } else if (tagType === 'QUEST_UPDATED') {
                    const parsedData = parseKeyValueString(dataString);
                    if (parsedData.title) {
                        newKnowledgeUpdates._updateQuest.push(parsedData);
                    }
                } else if (tagType === 'QUEST_OBJECTIVE_COMPLETED') {
                    const parsedData = parseKeyValueString(dataString);
                    if (parsedData.questTitle && parsedData.objectiveDescription) {
                        newKnowledgeUpdates._updateQuestObjective.push(parsedData);
                    }
                } else if (tagType === 'PLAYER_STATS_INIT' || tagType === 'STATS_UPDATE') {
                    const parsedData = parseKeyValueString(dataString);
                    if (!newKnowledgeUpdates._statsUpdate) newKnowledgeUpdates._statsUpdate = {};
                    for (const key in parsedData) {
                        newKnowledgeUpdates._statsUpdate[key] = parsedData[key];
                    }
                } else if (tagType === 'SKILL_COOLDOWN') {
                    newKnowledgeUpdates._skillCooldowns.push(match[1]);
                } else if (tagType === 'PERSONALITY_DEFINED') {
                    definedPersonality = dataString.trim();
                } else if (tagType === 'DAMAGE_NPC') {
                    const parsedData = parseKeyValueString(match[1]);
                    if(parsedData.Name && parsedData.Amount) {
                        newKnowledgeUpdates._npcDamage.push({ npcName: parsedData.Name, amount: parsedData.Amount });
                    }
                }else if (tagType === 'SET_COMBAT_STATUS') {
                    const status = match[1].toLowerCase() === 'true';
                    if (!newKnowledgeUpdates._setCombatStatus) newKnowledgeUpdates._setCombatStatus = status;
                }
                else if (tagType === 'CULTIVATION_PATH_ADD') {
                    newKnowledgeUpdates._cultivationPath = match[1].trim();
                }
                else if (tagType === 'NAME_UPDATE') {
                    const parsedData = parseKeyValueString(match[1]);
                    // Sửa lỗi: Phải lấy cả target, type, và value
                    if (parsedData.target && parsedData.type && parsedData.value) {
                        console.log("[Parser Debug] Đã nhận thẻ NAME_UPDATE:", parsedData);
                        newKnowledgeUpdates._nameUpdate = parsedData; // Lưu toàn bộ đối tượng parsedData
                    }
                } else if (tagType === 'NPC_UPDATE') { // Thêm logic cho thẻ mới
                    const parsedData = parseKeyValueString(match[1]);
                    if (parsedData.Name) {
                        console.log("[Parser Debug] Đã nhận thẻ NPC_UPDATE:", parsedData);
                        newKnowledgeUpdates._npcUpdates.push(parsedData);
                    }
                } else if (tagType === 'PERSONALITY_UPDATE') {
                    const parsedData = parseKeyValueString(match[1]);
                    if (parsedData.mode && parsedData.value) {
                        newKnowledgeUpdates._personalityUpdate = { mode: parsedData.mode, value: parsedData.value };
                    }
                }
                else if (tagType === 'NPC_LOG_ADD') {
                    const parsedData = parseKeyValueString(match[1]);
                    if (parsedData.NPCName && parsedData.event) {
                        newKnowledgeUpdates._npcLogAdd.push({ npcName: parsedData.NPCName, event: parsedData.event });
                    }
                }
                                else if (tagType === 'NPC_LEARNS_SKILL') {
                    const parsedData = parseKeyValueString(dataString);
                    if (parsedData.NPCName && parsedData.SkillName) {
                        console.log(`[Parser Debug] Đã nhận thẻ NPC_LEARNS_SKILL cho NPC "${parsedData.NPCName}" với kỹ năng "${parsedData.SkillName}"`);
                        // Tạo một mảng mới để chứa các chỉ dẫn cập nhật kỹ năng cho NPC
                        if (!newKnowledgeUpdates._npcSkillUpdates) newKnowledgeUpdates._npcSkillUpdates = [];
                        // Đẩy chỉ dẫn vào mảng
                        newKnowledgeUpdates._npcSkillUpdates.push({
                            npcName: parsedData.NPCName,
                            skill: {
                                id: crypto.randomUUID(), // Tạo ID mới cho kỹ năng
                                Name: parsedData.SkillName,
                                Description: parsedData.SkillDescription || "Chưa có mô tả."
                            }
                        });
                    }
                }
                else if (tagType.startsWith('DEFINE_')) {
                    const categoryMap = {
                        'DEFINE_RACE': 'races',
                        'DEFINE_LOCATION': 'locations',
                        'DEFINE_CONCEPT': 'concepts',
                        'DEFINE_EVENT': 'events',
                        'DEFINE_ITEM': 'items',
                        'DEFINE_SKILL': 'skills',
                        'DEFINE_CULTIVATION_SYSTEM': 'cultivationSystems',
                        'DEFINE_NPC': 'npcs'
                    };
                    const category = categoryMap[tagType];
                    if (!category) continue;

                    let parsedData = parseKeyValueString(match[1]);
                    const entityName = parsedData.name || parsedData.Name || parsedData.systemName;

                    if (entityName) {
                        const existingEntities = worldKnowledge[category] || [];
                        // Cải thiện duplicate check để tránh các biến thể tên
                        const isDuplicate = existingEntities.some(e => {
                            const existingName = (e.name || e.Name || e.systemName || '').trim().toLowerCase();
                            const newName = entityName.trim().toLowerCase();
                            // Kiểm tra chính xác và cả các biến thể có dấu cách
                            return existingName === newName || 
                                   existingName.replace(/\s/g, '') === newName.replace(/\s/g, '') ||
                                   existingName.includes(newName) || 
                                   newName.includes(existingName);
                        });

                        if (!isDuplicate) {
                            if (!worldKnowledgeUpdates[category]) {
                                worldKnowledgeUpdates[category] = [];
                            }
                            if (category === 'npcs') {
                                const system = worldKnowledge.cultivationSystems.find(s => s.systemName === parsedData.cultivationSystem);
                                if (system && parsedData.realm) {
                                    const realmIndex = system.realms.indexOf(parsedData.realm);
                                    if (realmIndex !== -1) {
                                        parsedData.level = (realmIndex * 10) + 1;
                                    }
                                }
                                
                                const finalStats = calculateBaseStats(parsedData, worldKnowledge);
                                parsedData.hp = finalStats.hp;
                                parsedData.atk = finalStats.atk;
                            }
                            if (category === 'cultivationSystems') {
                                parsedData.realms = parsedData.realms ? parsedData.realms.split(',').map(r => r.trim()) : [];
                            }
                            worldKnowledgeUpdates[category].push({ id: crypto.randomUUID(), ...parsedData });
                            console.log(`[Thiên Đạo Bút] AI đã định nghĩa một ${category} mới: ${entityName}`);
                            console.log(`[World Knowledge Stats] Hiện tại có ${(worldKnowledge[category] || []).length} ${category} trong kho tri thức.`);
                        } else {
                            console.log(`[Thiên Đạo Bút] AI cố định nghĩa lại ${category} đã tồn tại: ${entityName}. Bỏ qua.`);
                            console.log(`[Duplicate Check] Danh sách hiện tại:`, (worldKnowledge[category] || []).map(e => e.name || e.Name || e.systemName));
                        }
                    }
                }
                // *** BẮT ĐẦU XỬ LÝ THẺ LORE_* - CỰC KỲ QUAN TRỌNG ***
                else if (tagType.startsWith('LORE_')) {
                    const loreTypeMap = {
                        'LORE_ITEM': 'items',
                        'LORE_NPC': 'npcs', 
                        'LORE_LOCATION': 'locations',
                        'LORE_SKILL': 'skills',
                        'LORE_CONCEPT': 'concepts',
                        'LORE_EVENT': 'events',
                        'LORE_RACE': 'races'
                    };
                    const category = loreTypeMap[tagType];
                    if (!category) continue;

                    const parsedData = parseKeyValueString(match[1]);
                    const requestedName = parsedData.name || parsedData.Name;

                    if (requestedName) {
                        // Tìm entity đã có trong worldKnowledge bằng tên (case-insensitive)
                        const existingEntities = worldKnowledge[category] || [];
                        const foundEntity = existingEntities.find(e => {
                            const entityName = e.name || e.Name || e.systemName;
                            return entityName && entityName.toLowerCase().trim() === requestedName.toLowerCase().trim();
                        });

                        if (foundEntity) {
                            // Tìm thấy entity đã có, sử dụng lại với ID gốc
                            console.log(`[LORE Reference] AI tham chiếu ${category} đã có: "${requestedName}" (ID: ${foundEntity.id})`);
                            
                            // Tạo bản sao với ID gốc để thêm vào game
                            const entityToAdd = {
                                ...foundEntity,
                                // Ghi đè một số thông tin nếu AI cung cấp (cho phép cập nhật)
                                ...(parsedData.Description && {Description: parsedData.Description}),
                                ...(parsedData.Personality && {Personality: parsedData.Personality}),
                                ...(parsedData.HP && {HP: parsedData.HP}),
                                ...(parsedData.ATK && {ATK: parsedData.ATK}),
                                ...(parsedData.Stance && {Stance: parsedData.Stance})
                            };

                            // Thêm vào categoryMap tương ứng 
                            const targetCategory = categoryMap[tagType];
                            if (targetCategory) {
                                if (!newKnowledgeUpdates[targetCategory]) {
                                    newKnowledgeUpdates[targetCategory] = [];
                                }
                                newKnowledgeUpdates[targetCategory].push(entityToAdd);
                            }
                        } else {
                            // Không tìm thấy entity đã có, AI cần dùng DEFINE_ thay vì LORE_
                            console.warn(`[LORE Error] AI tham chiếu ${category} không tồn tại: "${requestedName}". AI nên dùng thẻ DEFINE_${tagType.replace('LORE_', '')} để tạo mới.`);
                        }
                    }
                }
                // *** KẾT THÚC XỬ LÝ THẺ LORE_* ***
// THAY THẾ TOÀN BỘ KHỐI `else if (tagType === 'COMPANION')` BẰNG ĐOẠN NÀY

else if (tagType === 'COMPANION') {
    const parsedDataFromTag = parseKeyValueString(dataString);
    if (parsedDataFromTag.Name) {
        // Tìm NPC gốc trong knowledgeBase để lấy ID
        const targetNpc = knowledgeBase.npcs.find(
            npc => npc.Name.toLowerCase() === parsedDataFromTag.Name.toLowerCase()
        );

        // Chỉ xử lý nếu tìm thấy NPC gốc
        if (targetNpc && targetNpc.id) {
            
            // Bước 1: Đánh dấu ID để thêm vào danh sách đồng hành (Đã đúng)
            if (!newKnowledgeUpdates._addCompanionById) {
                 newKnowledgeUpdates._addCompanionById = [];
            }
            newKnowledgeUpdates._addCompanionById.push(targetNpc.id);

            // ==========================================================
            // ### BẮT ĐẦU ĐOẠN SỬA LỖI ###
            
            // Bước 2: Tạo ra một "chỉ dẫn cập nhật" thay vì cố gắng sửa đổi trực tiếp.
            // Chúng ta sẽ tái sử dụng mảng `_toUpdate` đã có sẵn.
            if (!newKnowledgeUpdates._toUpdate) {
                newKnowledgeUpdates._toUpdate = [];
            }
            newKnowledgeUpdates._toUpdate.push({
                category: 'npcs',          // Chỉ rõ cần cập nhật trong danh sách `npcs`
                data: parsedDataFromTag,  // Dữ liệu cần cập nhật là toàn bộ thông tin từ thẻ
            });
            
            console.log(`[Companion Logic v3] Đã đánh dấu ID "${targetNpc.id}" làm đồng hành và tạo yêu cầu cập nhật cho NPC gốc "${targetNpc.Name}".`);

            // ### KẾT THÚC ĐOẠN SỬA LỖI ###
            // ==========================================================

        } else {
            console.warn(`[Companion Logic v3] Không tìm thấy NPC có tên "${parsedDataFromTag.Name}" để đặt làm đồng hành.`);
        }
    }
}
                else { 
                    const parsedData = parseKeyValueString(dataString);
                    const categoryKey = categoryMap[tagType];

if (parsedData.Name || parsedData.NPC || (categoryKey === 'playerStatus' && parsedData.name) || (categoryKey === 'quests' && parsedData.title)) {
    let itemWithId = { id: crypto.randomUUID(), ...parsedData, name: parsedData.name || parsedData.Name };

    // Logic gốc để xử lý quest và inventory (GIỮ NGUYÊN)
    if (categoryKey === 'quests') {
        itemWithId.objectives = parsedData.objectives ? parsedData.objectives.split(';').map(objText => ({ text: objText.trim(), completed: false })) : [];
        itemWithId.status = parsedData.status || 'active';
    }
    if (categoryKey === 'inventory') {
        itemWithId = {
            ...itemWithId,
            Description: itemWithId.Description || '[Chưa có]',
            Type: itemWithId.Type || 'Khác',
            Equippable: typeof itemWithId.Equippable === 'boolean' ? itemWithId.Equippable : false,
            Usable: typeof itemWithId.Usable === 'boolean' ? itemWithId.Usable : false,
            Consumable: typeof itemWithId.Consumable === 'boolean' ? itemWithId.Consumable : false,
            Uses: typeof itemWithId.Uses === 'number' ? itemWithId.Uses : 0,
            EffectDescription: itemWithId.EffectDescription || '[Chưa có]',
            StatsBonus: itemWithId.StatsBonus || "",
            SideEffect: itemWithId.SideEffect || '[Chưa có]',
        };
    }

    // ### BẮT ĐẦU ĐOẠN CODE SỬA LỖI ###
    // Ngay sau khi tạo đối tượng NPC, tính toán ngay lập tức exp và maxExp
    if (categoryKey === 'npcs') {
        // Khởi tạo exp nếu chưa có
        if (itemWithId.exp === undefined) {
            itemWithId.exp = 0;
        }
        // Luôn tính toán maxExp để đảm bảo chính xác
        itemWithId.maxExp = calculateNpcMaxExp(itemWithId, worldKnowledge);
        console.log(`[Parser] Đã tính toán maxExp cho NPC "${itemWithId.Name}": ${itemWithId.maxExp}`);
    }
    // ### KẾT THÚC ĐOẠN CODE SỬA LỖI ###

    // Logic cũ để xử lý các thẻ khác (GIỮ NGUYÊN)
    if (tagType === 'ITEM_CONSUMED' || tagType === 'ITEM_REMOVED') {
        if (parsedData.Name) {
                newKnowledgeUpdates._toRemove.push({ category: categoryKey, name: parsedData.Name });
        }
    } else if (tagType === 'ITEM_UPDATED') {
        newKnowledgeUpdates._toUpdate.push({ category: categoryKey, data: itemWithId });
    } else {
            if (!newKnowledgeUpdates[categoryKey]) newKnowledgeUpdates[categoryKey] = [];
            newKnowledgeUpdates[categoryKey].push(itemWithId);
    }
}
                }
            } catch (e) {
                console.error(`Error parsing ${tagType} string:`, dataString, e);
            }
        }
        matchesToReplace.forEach(matchStr => storyContent = storyContent.replace(matchStr, "").trim());
    }
    /*
    try {
        const removalKeywords = [
            'mất', 'cướp', 'đánh rơi', 'phá hủy', 'vỡ nát', 
            'biến mất', 'trộm', 'bị lấy đi', 'tan biến', 'hủy',
            'tiêu tán', 'bị đoạt', 'bị cướp đoạt'
        ];

        const currentPossessions = [
            ...knowledgeBase.inventory, 
            ...Object.values(knowledgeBase.equippedItems).filter(Boolean)
        ];
        
        const itemsTaggedForRemoval = (newKnowledgeUpdates._toRemove || []).map(r => r.name.trim().toLowerCase());

        currentPossessions.forEach(item => {
            const itemName = item.Name.trim();
            const itemNameLower = itemName.toLowerCase();

            if (itemsTaggedForRemoval.includes(itemNameLower)) {
                return;
            }

            if (storyContent.toLowerCase().includes(itemNameLower)) {
                const foundKeyword = removalKeywords.some(keyword => storyContent.toLowerCase().includes(keyword));

                if (foundKeyword) {
                    console.warn(`[Double-Check] Phát hiện vật phẩm "${itemName}" có thể đã bị mất nhưng AI quên thẻ. Tự động xóa.`);
                    if (!newKnowledgeUpdates._toRemove) newKnowledgeUpdates._toRemove = [];
                    if (!newKnowledgeUpdates._toRemove.some(r => r.name.trim().toLowerCase() === itemNameLower)) {
                         newKnowledgeUpdates._toRemove.push({ category: 'inventory', name: itemName });
                    }
                }
            }
        });
    } catch (e) {
        console.error("Lỗi trong cơ chế Double-Check:", e);
    }
    
    try {
        const acquisitionKeywords = ['nhặt được', 'tìm thấy', 'nhận được', 'chế tạo ra', 'thu được', 'lượm được', 'được tặng'];
        const upgradeKeywords = ['nâng cấp', 'mạnh hơn', 'hấp thụ', 'phát sáng', 'thay đổi', 'tiến hóa', 'khắc ấn ký', 'sắc bén hơn'];
        
        const corrections = [];

        const allKnownItems = worldKnowledge.items || [];
        const itemsTaggedForAcquisition = (newKnowledgeUpdates.inventory || []).map(i => i.Name.trim().toLowerCase());
        
        allKnownItems.forEach(knownItem => {
            const itemName = knownItem.Name.trim();
            const itemNameLower = itemName.toLowerCase();
            const playerHasItem = knowledgeBase.inventory.some(i => i.Name.trim().toLowerCase() === itemNameLower);

            if (!itemsTaggedForAcquisition.includes(itemNameLower) && !playerHasItem && storyContent.toLowerCase().includes(itemNameLower)) {
                if (acquisitionKeywords.some(keyword => storyContent.toLowerCase().includes(keyword))) {
                    console.warn(`[Double-Check] Phát hiện nhận vật phẩm đã biết "${itemName}" nhưng AI quên thẻ. Tự động thêm.`);
                    if (!newKnowledgeUpdates.inventory) newKnowledgeUpdates.inventory = [];
                    newKnowledgeUpdates.inventory.push(knownItem);
                }
            }
        });

        const currentPossessions = [...knowledgeBase.inventory, ...Object.values(knowledgeBase.equippedItems).filter(Boolean)];
        currentPossessions.forEach(item => {
            const itemNameLower = item.Name.trim().toLowerCase();
            if (storyContent.toLowerCase().includes(itemNameLower)) {
                if (upgradeKeywords.some(keyword => storyContent.toLowerCase().includes(keyword))) {
                     corrections.push(`HỆ THỐNG GHI NHẬN: Ở lượt trước, có vẻ như vật phẩm '${item.Name}' đã được nâng cấp/thay đổi. NGƯƠI BẮT BUỘC PHẢI định nghĩa lại các chỉ số/thuộc tính mới của nó bằng thẻ [ITEM_UPDATED: Name='${item.Name}', StatsBonus='...', Description='...'] ngay bây giờ.`);
                }
            }
        });

        setPromptCorrections(corrections);

    } catch (e) {
        console.error("Lỗi trong cơ chế Double-Check:", e);
    }
    */
    setKnowledgeBase(prev => {
        let updatedKnowledge = JSON.parse(JSON.stringify(prev)); 

        for (const categoryKey in newKnowledgeUpdates) {
            if (categoryKey.startsWith('_')) continue; 

            if (newKnowledgeUpdates[categoryKey] && newKnowledgeUpdates[categoryKey].length > 0) {
                if (!updatedKnowledge[categoryKey]) updatedKnowledge[categoryKey] = [];
                
                newKnowledgeUpdates[categoryKey].forEach(newItem => {
                    const uniqueKey = (newItem.Name || newItem.NPC || newItem.name || newItem.title || "").trim().toLowerCase();
                    const existingIndex = updatedKnowledge[categoryKey].findIndex(existingItem => 
                        ((existingItem.Name || existingItem.NPC || existingItem.name || existingItem.title || "").trim().toLowerCase() === uniqueKey)
                    );

                    if (existingIndex > -1) { 
                        console.log(`[KnowledgeBase] Cập nhật mục đã có: ${uniqueKey} trong ${categoryKey}.`);
                        // Nếu là NPC, đảm bảo có exp và tính lại maxExp


    if (categoryKey === 'npcs') {
    if (newItem.exp === undefined) {
        newItem.exp = updatedKnowledge[categoryKey][existingIndex]?.exp || 0; // Giữ lại exp cũ nếu có, nếu không thì là 0
    }
    newItem.maxExp = calculateNpcMaxExp(newItem, worldKnowledge);
    console.log(`[Parser_NPC_Update] Đã tính/cập nhật maxExp cho NPC "${newItem.Name || uniqueKey}": ${newItem.maxExp}`);
}
                        updatedKnowledge[categoryKey][existingIndex] = { ...updatedKnowledge[categoryKey][existingIndex], ...newItem };
                    } else { 
                        console.log(`[KnowledgeBase] Thêm mục mới: ${uniqueKey} vào ${categoryKey}.`);
                        updatedKnowledge[categoryKey].push(newItem);
                    }
                });
            }
        }
        
        if (newKnowledgeUpdates._toUpdate) {
            newKnowledgeUpdates._toUpdate.forEach(updateInstruction => {
                const { category, data } = updateInstruction;
                if (updatedKnowledge[category]) {
                    const itemIndex = updatedKnowledge[category].findIndex(item => item.Name === data.Name);
                    if (itemIndex > -1) {
                        updatedKnowledge[category][itemIndex] = { ...updatedKnowledge[category][itemIndex], ...data };
                        if (updatedKnowledge[category][itemIndex].Consumable && 
                            typeof updatedKnowledge[category][itemIndex].Uses === 'number' &&
                            updatedKnowledge[category][itemIndex].Uses <= 0) {
                             updatedKnowledge[category].splice(itemIndex, 1);
                        }
                    }
                }
            });
        }
        if (newKnowledgeUpdates._toRemove) {
            newKnowledgeUpdates._toRemove.forEach(removalInstruction => {
                const { category, name } = removalInstruction;
                if (updatedKnowledge[category]) {
                    updatedKnowledge[category] = updatedKnowledge[category].filter(item => 
                        (item.Name || item.name || "").trim().toLowerCase() !== name.trim().toLowerCase()
                    );
                }
            });
        }

        if (newKnowledgeUpdates._removePlayerStatusByName.length > 0) {
            updatedKnowledge.playerStatus = updatedKnowledge.playerStatus.filter(status => 
                !newKnowledgeUpdates._removePlayerStatusByName.includes(status.name)
            );
        }
        
        if (newKnowledgeUpdates._updateNpcStatus.length > 0) {
            newKnowledgeUpdates._updateNpcStatus.forEach(update => {
                const npcIndex = updatedKnowledge.npcs.findIndex(npc => npc.Name === update.npcName);
                if (npcIndex > -1) {
                    if (!updatedKnowledge.npcs[npcIndex].statuses) {
                        updatedKnowledge.npcs[npcIndex].statuses = [];
                    }
                    if (update.status) { 
                        const existingStatusIndex = updatedKnowledge.npcs[npcIndex].statuses.findIndex(s => s.name === update.status.name);
                        if (existingStatusIndex > -1) {
                            updatedKnowledge.npcs[npcIndex].statuses[existingStatusIndex] = {...updatedKnowledge.npcs[npcIndex].statuses[existingStatusIndex], ...update.status};
                        } else {
                            updatedKnowledge.npcs[npcIndex].statuses.push(update.status);
                        }
                    } else if (update.removeStatusName) { 
                        updatedKnowledge.npcs[npcIndex].statuses = updatedKnowledge.npcs[npcIndex].statuses.filter(
                            s => s.name !== update.removeStatusName
                        );
                    }
                }
            });
        }

        if (newKnowledgeUpdates._updateQuest.length > 0) {
            newKnowledgeUpdates._updateQuest.forEach(questUpdateData => {
                const questIndex = updatedKnowledge.quests.findIndex(q => q.title === questUpdateData.title);
                if (questIndex > -1) {
                    updatedKnowledge.quests[questIndex] = { ...updatedKnowledge.quests[questIndex], ...questUpdateData };
                    if (questUpdateData.objectiveCompleted && updatedKnowledge.quests[questIndex].objectives) {
                        const objIndex = updatedKnowledge.quests[questIndex].objectives.findIndex(obj => obj.text === questUpdateData.objectiveCompleted);
                        if (objIndex > -1) {
                            updatedKnowledge.quests[questIndex].objectives[objIndex].completed = true;
                        }
                    }
                }
            });
        }
        if (newKnowledgeUpdates._updateQuestObjective.length > 0) {
            newKnowledgeUpdates._updateQuestObjective.forEach(objUpdateData => {
                const questIndex = updatedKnowledge.quests.findIndex(q => q.title === objUpdateData.questTitle);
                if (questIndex > -1 && updatedKnowledge.quests[questIndex].objectives) {
                    const objIndex = updatedKnowledge.quests[questIndex].objectives.findIndex(obj => obj.text === objUpdateData.objectiveDescription);
                    if (objIndex > -1) {
                        updatedKnowledge.quests[questIndex].objectives[objIndex].completed = true;
                    }
                }
            });
        }
        // Thêm đoạn này vào trong hàm `setKnowledgeBase(prev => { ... })`
if (newKnowledgeUpdates._addCompanionById) {
    if (!updatedKnowledge.companions) updatedKnowledge.companions = [];
    newKnowledgeUpdates._addCompanionById.forEach(companionId => {
        // Chỉ thêm nếu ID đó chưa có trong danh sách
        if (!updatedKnowledge.companions.includes(companionId)) {
            updatedKnowledge.companions.push(companionId);
        }
    });
}
        if (newKnowledgeUpdates._statsUpdate) {
            const statsChanges = {};
            for (const key in newKnowledgeUpdates._statsUpdate) {
                statsChanges[key.toLowerCase()] = newKnowledgeUpdates._statsUpdate[key];
            }

            let newStats = { ...updatedKnowledge.playerStats };
            const oldStats = { ...updatedKnowledge.playerStats };
            let statsNeedRecalculation = false; 

            if (statsChanges.realm && statsChanges.realm !== oldStats.realm) {
                const newRealmName = statsChanges.realm;
                const primaryPath = oldStats.cultivationPaths?.[0] || gameSettings.initialCultivationSystem;
                const currentSystem = worldKnowledge.cultivationSystems.find(s => s.systemName === primaryPath);

                if (currentSystem) {
                    const realmIndex = currentSystem.realms.indexOf(newRealmName);
                    if (realmIndex !== -1) {
                        newStats.realm = newRealmName;
                        newStats.level = (realmIndex * 10) + 1;
                        statsNeedRecalculation = true;
                    }
                }
            }

// *** BẮT ĐẦU ĐOẠN CODE THAY THẾ ***
if (statsChanges.exp !== undefined) {
    const baseExpChange = parseFloat(statsChanges.exp);
    if (!isNaN(baseExpChange) && baseExpChange > 0) { // Chỉ áp dụng bonus cho EXP nhận vào
        // Lấy bonus EXP từ kho đệm đã được tính toán
        const expBonusPercent = aggregatedBonuses.exp?.isPercent ? aggregatedBonuses.exp.value : 0;
        
        console.log(`[DEBUG_EXP] Lượng EXP gốc nhận được: ${baseExpChange}, Bonus EXP hiện tại: ${expBonusPercent}%`);

        // Áp dụng công thức tính bonus
        const finalExpChange = Math.floor(baseExpChange * (1 + expBonusPercent / 100));
        
        console.log(`[DEBUG_EXP] Lượng EXP cuối cùng sau khi áp dụng bonus: ${finalExpChange}`);
        
        newStats.exp += finalExpChange;
    } else if (!isNaN(baseExpChange)) {
        // Nếu là trừ EXP hoặc không có thay đổi, giữ nguyên
        newStats.exp += baseExpChange;
    }
}
// *** KẾT THÚC ĐOẠN CODE THAY THẾ ***

            if (typeof newStats.exp === 'number' && typeof newStats.maxExp === 'number' && newStats.maxExp > 0) {
                while (newStats.exp >= newStats.maxExp) {
                    newStats.level += 1;
                    newStats.exp -= newStats.maxExp;
                    statsNeedRecalculation = true;
                }
            }

            if (statsNeedRecalculation) {
                console.log("[DEBUG] === BẮT ĐẦU TÍNH TOÁN LẠI CHỈ SỐ DO THAY ĐỔI CẢNH GIỚI/CẤP ĐỘ (LOGIC SỬA LỖI V2) ===");
                console.log(`[DEBUG] Thông tin đầu vào: Level=${newStats.level}, Realm='${newStats.realm}'`);

                const baseCalculatedStats = calculateBaseStats({
                    level: newStats.level,
                    realm: newStats.realm,
                    cultivationSystem: newStats.cultivationPaths?.[0] || gameSettings.initialCultivationSystem,
                    talentTier: gameSettings.initialTalentTier,
                }, worldKnowledge);
                console.log("[DEBUG] Chỉ số CƠ BẢN MỚI được tính (Nền móng):", JSON.stringify(baseCalculatedStats));
                
                let finalStatsAfterBonuses = {
                    ...newStats,
                    maxHp: baseCalculatedStats.hp,
                    maxMana: Math.floor(baseCalculatedStats.hp * 0.6),
                    atk: baseCalculatedStats.atk,
                };

                console.log('[DEBUG] Lấy tổng bonus từ KHO ĐỆM:', JSON.stringify(aggregatedBonuses));
                finalStatsAfterBonuses = applyStatsBonus(finalStatsAfterBonuses, aggregatedBonuses);
                
                console.log("[DEBUG] Chỉ số CUỐI CÙNG sau khi đã áp dụng lại tất cả bonus:", JSON.stringify({maxHp: finalStatsAfterBonuses.maxHp, maxMana: finalStatsAfterBonuses.maxMana, atk: finalStatsAfterBonuses.atk}));
                
                newStats.maxHp = finalStatsAfterBonuses.maxHp;
                newStats.maxMana = finalStatsAfterBonuses.maxMana;
                newStats.atk = finalStatsAfterBonuses.atk;
                newStats.hp = newStats.maxHp;
                newStats.mana = newStats.maxMana;

                let difficultyMultiplier = 1.2;
                if(gameSettings.difficulty === 'Dễ') difficultyMultiplier = 1.0;
                if(gameSettings.difficulty === 'Khó') difficultyMultiplier = 2.0;
                if(gameSettings.difficulty === 'Ác Mộng') difficultyMultiplier = 10.0;
                const numPaths = newStats.cultivationPaths?.length || 1;
                const pathMultiplier = 1 + (numPaths - 1) * 0.5;
                const primaryPath = newStats.cultivationPaths?.[0];
                const currentSystem = worldKnowledge.cultivationSystems.find(s => s.systemName === primaryPath);
                const realmIndex = currentSystem ? Math.max(0, currentSystem.realms.indexOf(newStats.realm)) : 0;
                const realmFactor = 1 + (realmIndex * 0.4);
                newStats.maxExp = Math.floor((100 + Math.pow(newStats.level, 1.8) * 5) * difficultyMultiplier * realmFactor * pathMultiplier);

                console.log(`[DEBUG] MaxExp mới được tính: ${newStats.maxExp}`);
                console.log("[DEBUG] === KẾT THÚC TÍNH TOÁN LẠI CHỈ SỐ ===");
            }
            
            if (!statsNeedRecalculation) {
                if (statsChanges.hp) {
                    newStats.hp = Math.max(0, newStats.hp + parseFloat(statsChanges.hp));
                }
                if (statsChanges.mana) {
                    newStats.mana = Math.max(0, newStats.mana + parseFloat(statsChanges.mana));
                }
            }
            
            if (statsChanges.currency !== undefined) {
                 const currencyChangeString = String(statsChanges.currency);
                 const changeMatch = currencyChangeString.match(/([+-])\s*(\d+)/);
                if (changeMatch) {
                    const operator = changeMatch[1];
                    const amount = parseInt(changeMatch[2], 10);
                    let currentAmount = parseInt(newStats.currency, 10) || 0;
                    currentAmount = (operator === '+') ? currentAmount + amount : currentAmount - amount;
                    newStats.currency = Math.max(0, currentAmount);
                } else if (!isNaN(parseInt(currencyChangeString, 10))) {
                    newStats.currency = parseInt(currencyChangeString, 10);
                }
            }

            if (typeof newStats.hp === 'number' && typeof newStats.maxHp === 'number' && newStats.hp > newStats.maxHp) {
                newStats.hp = newStats.maxHp;
            }
            if (typeof newStats.mana === 'number' && typeof newStats.maxMana === 'number' && newStats.mana > newStats.maxMana) {
                newStats.mana = newStats.maxMana;
            }

            updatedKnowledge.playerStats = newStats;
        }

        if (newKnowledgeUpdates._skillCooldowns && newKnowledgeUpdates._skillCooldowns.length > 0) {
            newKnowledgeUpdates._skillCooldowns.forEach(skillNameToCooldown => {
                const skillIndex = updatedKnowledge.playerSkills.findIndex(s => s.Name === skillNameToCooldown);
                if (skillIndex > -1) {
                    updatedKnowledge.playerSkills[skillIndex].currentCooldown = updatedKnowledge.playerSkills[skillIndex].cooldown;
                }
            });
        }
        if (newKnowledgeUpdates._npcDamage && newKnowledgeUpdates._npcDamage.length > 0) {
            newKnowledgeUpdates._npcDamage.forEach(damageInfo => {
                const npcIndex = updatedKnowledge.npcs.findIndex(npc => npc.Name === damageInfo.npcName);
                if (npcIndex > -1 && typeof updatedKnowledge.npcs[npcIndex].HP === 'number') {
                    updatedKnowledge.npcs[npcIndex].HP -= damageInfo.amount;
                    if (updatedKnowledge.npcs[npcIndex].HP <= 0) {
                        updatedKnowledge.npcs[npcIndex].Stance = "Đã bị đánh bại";
                    }
                }
            });
        }
        if (newKnowledgeUpdates._setCombatStatus !== undefined) {
            updatedKnowledge.playerStats.isInCombat = newKnowledgeUpdates._setCombatStatus;
        }
        if (newKnowledgeUpdates._cultivationPath) {
            if (!updatedKnowledge.playerStats.cultivationPaths) {
                updatedKnowledge.playerStats.cultivationPaths = [];
            }
            if (!updatedKnowledge.playerStats.cultivationPaths.includes(newKnowledgeUpdates._cultivationPath)) {
                updatedKnowledge.playerStats.cultivationPaths.push(newKnowledgeUpdates._cultivationPath);
            }
        }
        // *** BẮT ĐẦU ĐOẠN CODE CẦN THÊM ***
        // Xử lý cập nhật chỉ số cho NPC/Đồng hành
        if (newKnowledgeUpdates._npcUpdates && newKnowledgeUpdates._npcUpdates.length > 0) {
            newKnowledgeUpdates._npcUpdates.forEach(updateData => {
                const targetName = updateData.Name;
                console.log(`[Updater Debug] Bắt đầu xử lý NPC_UPDATE cho: "${targetName}"`, updateData);
                let isUpdated = false;

                ['companions', 'npcs'].forEach(category => {
                    if (isUpdated || !updatedKnowledge[category]) return;

                    const targetIndex = updatedKnowledge[category].findIndex(entity => 
                        (entity.Name || '').toLowerCase() === targetName.toLowerCase()
                    );

                    if (targetIndex > -1) {
                        console.log(`[Updater Debug] Tìm thấy "${targetName}" trong "${category}". Đang hợp nhất các chỉ số mới.`);
                        
                        // Chuyển đổi các giá trị số từ chuỗi sang số trước khi hợp nhất
                        const numericFields = ['Level', 'HP', 'ATK', 'MP', 'DEF', 'level', 'hp', 'atk', 'mp', 'def'];
                        const parsedUpdateData = { ...updateData };
                        for (const field in parsedUpdateData) {
                            if (numericFields.includes(field) && typeof parsedUpdateData[field] === 'string') {
                                const numValue = parseFloat(parsedUpdateData[field]);
                                if (!isNaN(numValue)) {
                                    parsedUpdateData[field] = numValue;
                                }
                            }
                        }
                        
                        // Hợp nhất dữ liệu cũ và mới, dữ liệu mới sẽ ghi đè lên dữ liệu cũ
                        updatedKnowledge[category][targetIndex] = { ...updatedKnowledge[category][targetIndex], ...parsedUpdateData };
                        isUpdated = true;
                    }
                });

                if (!isUpdated) {
                    console.warn(`[Updater Debug] Lỗi NPC_UPDATE: Không tìm thấy đối tượng có tên "${targetName}" để cập nhật.`);
                }
            });
        }
// *** KẾT THÚC ĐOẠN CODE CẦN THÊM ***
        if (newKnowledgeUpdates._nameUpdate) {
            const { target, type, value } = newKnowledgeUpdates._nameUpdate;
            console.log(`[Updater Debug] Bắt đầu xử lý NAME_UPDATE. Target: "${target}", Value: "${value}"`);

            // Ưu tiên kiểm tra có phải là người chơi không
            const currentPlayerName = updatedKnowledge.playerStats.characterName || prev.playerStats.characterName;
            if (target.toLowerCase() === 'player' || target.toLowerCase() === currentPlayerName.toLowerCase()) {
                if (type === 'alias') {
                    const oldName = currentPlayerName.split(' (')[0];
                    updatedKnowledge.playerStats.characterName = `${value} (${oldName})`;
                } else {
                    updatedKnowledge.playerStats.characterName = value;
                }
                console.log(`[Updater Debug] Tên người chơi đã được cập nhật thành: "${updatedKnowledge.playerStats.characterName}"`);
            } else {
                // Nếu không phải người chơi, tìm trong đồng hành và NPC
                let isUpdated = false;
                ['companions', 'npcs'].forEach(category => {
                    if (isUpdated || !updatedKnowledge[category]) return;
                    
                    const targetIndex = updatedKnowledge[category].findIndex(entity => 
                        (entity.Name || '').toLowerCase() === target.toLowerCase()
                    );

                    if (targetIndex > -1) {
                        console.log(`[Updater Debug] Tìm thấy target "${target}" trong "${category}". Đang đổi tên thành "${value}".`);
                        updatedKnowledge[category][targetIndex].Name = value;
                        isUpdated = true;
                    }
                });

                if (!isUpdated) {
                    console.warn(`[Updater Debug] Lỗi NAME_UPDATE: Không tìm thấy đối tượng có tên "${target}" để đổi tên.`);
                }
            }
        }
        if (newKnowledgeUpdates._personalityUpdate) {
            const { mode, value } = newKnowledgeUpdates._personalityUpdate;
            const currentPersonality = updatedKnowledge.playerStats.characterPersonality || prev.playerStats.characterPersonality;
            if (mode === 'add') {
                const existingPersonalities = currentPersonality.split(', ').filter(p => p);
                if (!existingPersonalities.includes(value)) {
                    existingPersonalities.push(value);
                    updatedKnowledge.playerStats.characterPersonality = existingPersonalities.join(', ');
                }
            } else {
                updatedKnowledge.playerStats.characterPersonality = value;
            }
        }

        if (newKnowledgeUpdates._npcLogAdd && newKnowledgeUpdates._npcLogAdd.length > 0) {
            newKnowledgeUpdates._npcLogAdd.forEach(logEntry => {
                const npcIndex = updatedKnowledge.npcs.findIndex(npc => npc.Name === logEntry.npcName);
                if (npcIndex > -1) {
                    if (!updatedKnowledge.npcs[npcIndex].interactionLog) {
                        updatedKnowledge.npcs[npcIndex].interactionLog = [];
                    }
                    updatedKnowledge.npcs[npcIndex].interactionLog.push(logEntry.event);
                }
            });
        }
        // Xử lý việc thêm kỹ năng mới cho NPC
        if (newKnowledgeUpdates._npcSkillUpdates && newKnowledgeUpdates._npcSkillUpdates.length > 0) {
            newKnowledgeUpdates._npcSkillUpdates.forEach(update => {
                const npcIndex = updatedKnowledge.npcs.findIndex(npc => npc.Name === update.npcName);
                if (npcIndex > -1) {
                    const targetNpc = updatedKnowledge.npcs[npcIndex];

                    // Khởi tạo mảng skills nếu nó chưa tồn tại
                    if (!targetNpc.skills || !Array.isArray(targetNpc.skills)) {
                        targetNpc.skills = [];
                    }

                    // Kiểm tra xem kỹ năng đã tồn tại chưa để tránh trùng lặp
                    const skillExists = targetNpc.skills.some(s => s.Name.toLowerCase() === update.skill.Name.toLowerCase());
                    if (!skillExists) {
                        targetNpc.skills.push(update.skill);
                        console.log(`[KnowledgeBase] Đã thêm kỹ năng "${update.skill.Name}" cho NPC "${update.npcName}".`);
                    } else {
                        console.log(`[KnowledgeBase] NPC "${update.npcName}" đã có kỹ năng "${update.skill.Name}", bỏ qua.`);
                    }
                } else {
                    console.warn(`[KnowledgeBase] Không tìm thấy NPC có tên "${update.npcName}" để thêm kỹ năng.`);
                }
            });
        }
        return updatedKnowledge;
    });
if (Object.keys(worldKnowledgeUpdates).length > 0) {
    setWorldKnowledge(prev => {
        // Tạo một bản sao sâu của state trước đó để tránh các lỗi tham chiếu
        const newWorldKnowledge = JSON.parse(JSON.stringify(prev));
        let hasNewEntities = false;

        for (const category in worldKnowledgeUpdates) {
            // Đảm bảo category (ví dụ: 'npcs', 'items') tồn tại dưới dạng một mảng trong state mới
            if (!newWorldKnowledge[category]) {
                newWorldKnowledge[category] = [];
            }

            const newItemsFromAI = worldKnowledgeUpdates[category];
            newItemsFromAI.forEach(newItem => {
                // Lấy tên của thực thể mới một cách linh hoạt, xử lý cả 'name', 'Name', và 'systemName'
                const newItemName = (newItem.name || newItem.Name || newItem.systemName || '').trim().toLowerCase();
                
                // Nếu không có tên, bỏ qua để tránh lỗi
                if (!newItemName) return;

                // Kiểm tra sự tồn tại một cách mạnh mẽ hơn, so sánh các tên đã được chuẩn hóa
                const exists = newWorldKnowledge[category].some(existingItem => {
                    const existingItemName = (existingItem.name || existingItem.Name || existingItem.systemName || '').trim().toLowerCase();
                    return existingItemName === newItemName;
                });

                // Chỉ thêm vào nếu nó thực sự chưa tồn tại
                if (!exists) {
                    newWorldKnowledge[category].push(newItem);
                    hasNewEntities = true;
                    console.log(`[WorldKnowledge Update] Đã thêm thành công thực thể mới "${newItem.Name || newItem.name}" vào danh mục "${category}".`);
                } else {
                    console.warn(`[WorldKnowledge Update] Thực thể "${newItem.Name || newItem.name}" đã tồn tại trong "${category}". Bỏ qua việc thêm mới.`);
                }
            });
        }
        
        // *** TỰ ĐỘNG LƯU KHI CÓ THAY ĐỔI ***
        if (hasNewEntities && userId) {
            // Lưu tự động sau 2 giây để tránh gọi API quá nhiều lần
            setTimeout(async () => {
                try {
                    const worldDocRef = doc(db, `artifacts/${appId}/users/${userId}/worldKnowledge/default`);
                    await setDoc(worldDocRef, newWorldKnowledge, { merge: false });
                    console.log(`[Auto-Save] Đã tự động lưu ${Object.keys(worldKnowledgeUpdates).length} thay đổi World Knowledge.`);
                } catch (error) {
                    console.error("[Auto-Save] Lỗi tự động lưu World Knowledge:", error);
                }
            }, 2000);
        }
        
        // Trả về state đã được cập nhật hoàn chỉnh
        return newWorldKnowledge;
    });
}

    if (useKoboldIntegration) {
        const koboldRegex = /\[KOBOLD_NSFW_PROMPT:\s*"([^"]+)"\]/s;
        const koboldMatch = storyContent.match(koboldRegex);

        if (koboldMatch) {
            storyContent = storyContent.replace(koboldRegex, '').trim();
            const koboldPromptText = koboldMatch[1];

            const loadingMessage = { type: 'system', content: '--- Đại Năng đang yêu cầu sự trợ giúp từ một thực thể khác (KoboldAI Horde) để mô tả chi tiết hơn... Vui lòng đợi ---', transient: true };
            setStoryHistory(prev => [...prev, loadingMessage]);
            setIsCallingKobold(true);

            try {
                const koboldGeneratedText = await callKoboldAIHordeAPI(koboldPromptText, koboldApiKey);
                
                setStoryHistory(prev => prev.filter(item => item !== loadingMessage));

                if (koboldGeneratedText) {
                    const koboldEntry = { 
                        type: 'kobold_story', 
                        content: `**[Thực thể khác thì thầm]**\n${koboldGeneratedText}`,
                        transient: true
                    };
                    setStoryHistory(prev => [...prev, koboldEntry]);
                } else {
                    const failureEntry = { type: 'system', content: '**[Thực thể khác đã từ chối lời thỉnh cầu.]**', transient: true };
                    setStoryHistory(prev => [...prev, failureEntry]);
                }

            } catch (error) {
                setStoryHistory(prev => prev.filter(item => item !== loadingMessage));
                console.error("Caught error from KoboldAI call:", error);
                if (error.message && error.message.includes("401")) {
                    setModalMessage({
                        show: true, title: 'Lỗi API Key KoboldAI',
                        content: 'API Key cho KoboldAI Horde không hợp lệ hoặc chưa được đăng ký.\n\nVui lòng đăng ký tại https://stablehorde.net/register và nhập Key vào phần "Thiết Lập API".',
                        type: 'error'
                    });
                    setShowApiModal(true); 
                } else {
                     setModalMessage({ show: true, title: 'Lỗi Gọi KoboldAI', content: `Không thể kết nối đến KoboldAI Horde: ${error.message}`, type: 'error' });
                }
                const failureEntry = { type: 'system', content: '**[Thực thể khác đã từ chối lời thỉnh cầu do lỗi hệ thống.]**', transient: true };
                setStoryHistory(prev => [...prev, failureEntry]);
            } finally {
                 setIsCallingKobold(false);
            }
        }
        // Thêm vào cuối hàm parseGeminiResponseAndUpdateState

    }

    const lines = storyContent.split('\n');
    const potentialChoicesLines = [];
    let choiceStartIndex = -1;

    for (let i = lines.length - 1; i >= 0; i--) {
        const line = lines[i].trim();
        if (line.match(/^\d+\.\s*.+/) || line.match(/^[-*]\s*.+/)) {
            potentialChoicesLines.unshift(line); 
            choiceStartIndex = i;
        } else if (choiceStartIndex !== -1 && line === "") {
        } else if (choiceStartIndex !== -1 && line !== "") {
            break; 
        }
    }
    
    if (choiceStartIndex !== -1) { 
        extractedChoices = potentialChoicesLines.map(line => line.replace(/^\d+\.\s*/, '').replace(/^[-*]\s*/, '').trim()).filter(choice => choice !== "");
        storyContent = lines.slice(0, choiceStartIndex).join('\n').trim();
    } else {
        storyContent = lines.join('\n').trim(); 
    }
    
    return { story: storyContent, choices: extractedChoices, definedPersonality: null };
};
// *** KẾT THÚC ĐOẠN CODE THAY THẾ ***
// *** KẾT THÚC ĐOẠN CODE THAY THẾ ***


  const callGeminiAPI = async (prompt, isInitialCall = false) => {
    const effectiveApiKey = apiMode === 'defaultGemini' ? "" : apiKey;
    if (apiMode === 'userKey' && !effectiveApiKey) {
      setModalMessage({ show: true, title: 'Lỗi API Key', content: 'API Key của bạn chưa được cấu hình. Vui lòng vào Thiết Lập API.', type: 'error' });
      setIsLoading(false); 
      setShowApiModal(true);
      return;
    }
    
    if (!isInitialCall && !isProcessingAction) setIsLoading(true); 
    else if (isInitialCall) setIsLoading(true);


    let currentChatHistory = chatHistoryForGemini;
    if (isInitialCall) {
      currentChatHistory = [{ role: "user", parts: [{ text: prompt }] }];
      
    } else {
      currentChatHistory.push({ role: "user", parts: [{ text: prompt }] });
    }
    
    const MAX_HISTORY_LENGTH = 10; 
    if (currentChatHistory.length > MAX_HISTORY_LENGTH) {
        const systemPromptIndex = currentChatHistory.findIndex(msg => msg.role === "system"); 
        const historyToKeep = currentChatHistory.slice(currentChatHistory.length - MAX_HISTORY_LENGTH);
        if (systemPromptIndex !== -1 && systemPromptIndex < (currentChatHistory.length - MAX_HISTORY_LENGTH) ) {
             currentChatHistory = [currentChatHistory[systemPromptIndex], ...historyToKeep];
        } else {
            currentChatHistory = historyToKeep;
        }
    }
    setChatHistoryForGemini(currentChatHistory);

    const payload = {
      contents: currentChatHistory,
      generationConfig: {} 
    };
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${effectiveApiKey}`;

    try {
      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      const result = await response.json();

      if (result.candidates && result.candidates.length > 0 && result.candidates[0].content && result.candidates[0].content.parts) {
        const rawText = result.candidates[0].content.parts[0].text;
        const { story, choices: newChoices, definedPersonality } = await parseGeminiResponseAndUpdateState(rawText);
        if (isInitialCall && definedPersonality) {
            setGameSettings(prev => ({ ...prev, characterPersonality: definedPersonality }));
            console.log(`AI đã quyết định tính cách nhân vật là: ${definedPersonality}`);
        }

        setCurrentStory(story);
        setChoices(newChoices); 
        
        const newStoryEntry = { type: 'story', content: story };
        
        setStoryHistory(prevStoryHistory => {
            const updatedStoryHistory = [...prevStoryHistory, newStoryEntry];
            if (currentGameId) {
                 //saveGameProgress(currentGameId, story, newChoices, updatedStoryHistory, 
                  //               [...currentChatHistory, { role: "model", parts: [{ text: rawText }] }], 
                  //               knowledgeBase); 
            }
            return updatedStoryHistory;
        });
        
        const updatedChatHistory = [...currentChatHistory, { role: "model", parts: [{ text: rawText }] }];
        setChatHistoryForGemini(updatedChatHistory);

      } else {
        let errorText = "Không nhận được phản hồi hợp lệ từ Gemini.";
        if (result.error) {
            errorText = `Lỗi từ API Gemini: ${result.error.message} (Mã: ${result.error.code})`;
             if (result.error.code === 400 && result.error.message.toLowerCase().includes("api key not valid")) {
                errorText += ". Vui lòng kiểm tra lại API Key của bạn.";
                setApiKeyStatus({ status: 'Lỗi API Key', message: 'API Key không hợp lệ. Vui lòng kiểm tra lại.', color: 'text-red-500' });
                setShowApiModal(true);
            }
        } else if (response.status === 429) {
            errorText = "Lỗi từ API Gemini: Bạn đã gửi quá nhiều yêu cầu. Vui lòng thử lại sau.";
        }
        setCurrentStory(errorText);
        setChoices([]);
        setStoryHistory(prev => [...prev, { type: 'system', content: errorText }]);
        setModalMessage({ show: true, title: 'Lỗi API', content: errorText, type: 'error' });
      }
    } catch (error) {
      console.error('Error calling Gemini API:', error);
      const networkError = `Lỗi kết nối đến Gemini API: ${error.message}. Vui lòng kiểm tra kết nối mạng.`;
      setCurrentStory(networkError);
      setChoices([]);
      setStoryHistory(prev => [...prev, { type: 'system', content: networkError }]);
      setModalMessage({ show: true, title: 'Lỗi Mạng', content: networkError, type: 'error' });
    }
    if (!isProcessingAction) setIsLoading(false); 
  };
    // --- HÀM MỚI ĐỂ TẠO PROMPT KHỞI ĐẦU ---
    
    
    
//////////////////////////////////////////////////////////////////

    let generatedSkills;

    


const initializeGame = async () => {
    if (!gameSettings.theme || !gameSettings.setting || !gameSettings.characterName || !gameSettings.characterBackstory) {
        setModalMessage({ show: true, title: 'Thiếu Thông Tin', content: 'Vui lòng điền đầy đủ thông tin Chủ đề, Bối cảnh, Tên nhân vật và Sơ lược tiểu sử.', type: 'error' });
        return;
    }
    if (gameSettings.difficulty === "Tuỳ Chỉnh AI" && !gameSettings.difficultyDescription) {
        setModalMessage({ show: true, title: 'Thiếu Mô Tả Độ Khó', content: 'Vui lòng tạo hoặc nhập mô tả cho độ khó "Tuỳ Chỉnh AI".', type: 'error' });
        return;
    }
     if (gameSettings.useCharacterGoal && !gameSettings.characterGoal) {
        setModalMessage({ show: true, title: 'Thiếu Mục Tiêu', content: 'Vui lòng điền mục tiêu cho nhân vật hoặc tắt tùy chọn này.', type: 'error' });
        return;
    }
    if (apiMode === 'userKey' && !apiKey) {
      setModalMessage({ show: true, title: 'Thiếu API Key', content: 'Vui lòng thiết lập API Key của bạn hoặc chọn chế độ AI mặc định.', type: 'error' });
      setShowApiModal(true);
      return;
    }

    setIsLoading(true);
    setModalMessage({ show: true, title: 'Đang Khởi Tạo...', content: 'AI đang kiến tạo thế giới và nhân vật...', type: 'info' });

    setCurrentStory('');
    setChoices([]);
    setStoryHistory([]);
    setChatHistoryForGemini([]);
    setCurrentTurn(1);

    // BƯỚC 1: RESET VÀ CHUẨN BỊ KHO BONUS
    console.log("[DEBUG] Reset kho bonus và bộ đệm về trạng thái rỗng trước khi khởi tạo.");
    setBonusSkillStorage({});
    setAggregatedBonuses({});

    const calculateInitialPlayerStats = () => {
        const entity = {
            level: parseInt(gameSettings.initialLevel, 10) || 1,
            realm: gameSettings.initialRealm,
            cultivationSystem: gameSettings.initialCultivationSystem,
            talentTier: gameSettings.initialTalentTier,
        };
        const stats = calculateBaseStats(entity, worldKnowledge);
        return {
            hp: stats.hp,
            maxHp: stats.hp,
            mana: Math.floor(stats.hp * 0.6),
            maxMana: Math.floor(stats.hp * 0.6),
            atk: stats.atk,
            exp: 0, // Bổ sung exp để applyStatsBonus có thể hoạt động
        };
    };
    
    const baseStats = calculateInitialPlayerStats();
    console.log("[DEBUG] === BẮT ĐẦU ÁP DỤNG BONUS KHỞI TẠO ===");
    console.log("[DEBUG] Chỉ số CƠ BẢN (GỐC):", JSON.stringify(baseStats));

    const totalInitialBonuses = {};
    const initialSkillsWithBonus = []; // Mảng tạm để lưu các kỹ năng có bonus

    gameSettings.initialTraits.forEach(trait => {
        if (trait.category === 'Kỹ năng' && trait.statsBonus) {
            // Thêm kỹ năng vào mảng tạm
            initialSkillsWithBonus.push({
                id: trait.id,
                Name: trait.name,
                StatsBonus: trait.statsBonus
            });

            // Cộng dồn bonus để tính chỉ số ban đầu
            const parsed = parseStatsBonus(trait.statsBonus);
            for (const key in parsed) {
                if (!totalInitialBonuses[key]) {
                    totalInitialBonuses[key] = { value: 0, isPercent: parsed[key].isPercent };
                }
                totalInitialBonuses[key].value += parsed[key].value;
            }
        }
    });
    console.log("[DEBUG] TỔNG HỢP TẤT CẢ BONUS KHỞI TẠO:", JSON.stringify(totalInitialBonuses));

    const finalStats = applyStatsBonus(baseStats, totalInitialBonuses);

    console.log("[DEBUG] Chỉ số CUỐI CÙNG sau khi áp dụng TỔNG BONUS:", JSON.stringify(finalStats));
    
    setKnowledgeBase({
        npcs: [], items: [], locations: [], companions: [],
        inventory: [], 
        playerSkills: [],
        relationships: [],
        playerStatus: [], 
        quests: [],
        realmProgressionList: [],
        storyOutline: "",
        equippedItems: {
            weapon: null, head: null, body: null, hands: null, feet: null,
            accessory1: null, accessory2: null,
        },
        equippedGongfa: {
            main: null, sub1: null, sub2: null,
        },
        playerStats: {
            ...finalStats,
            level: parseInt(gameSettings.initialLevel, 10) || 1,
            realm: gameSettings.initialRealm,
            maxExp: 100,
            currency: 0,
            isInCombat: false,
            cultivationPaths: [gameSettings.initialCultivationSystem],
            characterName: gameSettings.characterName,
            characterPersonality: gameSettings.characterPersonality,
        },
    });

    // BƯỚC 2: ĐIỀN DỮ LIỆU VÀO `bonusSkillStorage`
    console.log(`[DEBUG] Đang điền bonus của ${initialSkillsWithBonus.length} kỹ năng khởi tạo vào kho...`);
    initialSkillsWithBonus.forEach(skill => {
        // Gọi hàm cập nhật cho từng kỹ năng có bonus
        updateBonusSkillStorage('LEARN', { newSkill: skill });
    });
    console.log("[DEBUG] === KẾT THÚC ÁP DỤNG BONUS KHỞI TẠO ===");
    
    const initialTraitsForAIString = gameSettings.initialTraits.length > 0
        ? gameSettings.initialTraits.map(entry => {
            const traitObject = {
                category: entry.category,
                name: entry.name,
                description: entry.description,
                statsBonus: entry.statsBonus || "" 
            };
            return `- Entry: ${JSON.stringify(traitObject)}`;
        }).join('\n')
        : 'Không có. AI sẽ tự động tạo ra một vài kỹ năng hoặc vật phẩm ngẫu nhiên phù hợp với nhân vật và bối cảnh.';

    const initialWorldElementsString = gameSettings.initialWorldElements.map(el => {
        if (el.type === 'NPC') {
            const stats = calculateBaseStats(el, worldKnowledge);
            return `- Loại: NPC, Tên: ${el.name}, Mô tả: ${el.description}, Hệ Tu Luyện: ${el.cultivationSystem}, Bậc Thiên Phú: ${el.talentTier}, Cảnh Giới: ${el.realm}, Cấp Độ: ${el.level}. (Hệ thống đã tính toán chỉ số cơ bản: HP=${stats.hp}, ATK=${stats.atk})`;
        }
        return `- Loại: ${el.type}, Tên: ${el.name}, Mô tả: ${el.description}`;
    }).join('\n');

    const playerPersonalityInstruction = gameSettings.characterPersonality === 'Để AI quyết định'
        ? 'Tính cách nhân vật chính: (Do AI quyết định). YÊU CẦU QUAN TRỌNG: Ngươi PHẢI chọn một tính cách phù hợp cho nhân vật từ danh sách có sẵn (ví dụ: "Lạnh lùng & Quyết đoán", "Hài hước & Lạc quan",...) và thông báo nó bằng một thẻ duy nhất: [PERSONALITY_DEFINED: "Tên tính cách đã chọn"]'
        : `Tính cách nhân vật chính: "${gameSettings.characterPersonality}". Hãy để tính cách này ảnh hưởng mạnh mẽ đến lời nói, suy nghĩ, hành động của nhân vật và cách thế giới phản ứng với họ. Đây là yếu tố CỐT LÕI.`;

    const characterGoalInstruction = gameSettings.useCharacterGoal && gameSettings.characterGoal 
        ? `Mục tiêu/Động lực chính của nhân vật: "${gameSettings.characterGoal}". Mục tiêu này PHẢI là kim chỉ nam cho hành động, suy nghĩ của nhân vật và ảnh hưởng đến các sự kiện trong game. Đây là yếu tố CỐT LÕI.`
        : "Nhân vật không có mục tiêu/động lực cụ thể ban đầu. Hãy để câu chuyện tự nhiên phát triển hoặc tạo ra một động lực ban đầu dựa trên tình huống khởi đầu.";
    const canUseKobold = useKoboldIntegration && koboldApiKey && koboldApiKey.trim() !== '';
    const nsfwInstruction = gameSettings.allowNsfw 
        ? (canUseKobold 
        ? 'ĐÃ BẬT (Hỗ trợ bởi KoboldAI). Với các cảnh 18+, dùng thẻ [KOBOLD_NSFW_PROMPT: "Mô tả chi tiết cảnh..."] để yêu cầu mô tả chuyên sâu. Với các cảnh khác, ngươi tự mô tả.'
        : 'ĐÃ BẬT (Chỉ Gemini). Ngươi ĐƯỢC PHÉP và ĐƯỢC KHUYẾN KHÍCH mô tả các cảnh 18+ với phong cách truyện 18+, các đại từ chỉ bộ phận sinh dục sẽ được ẩn dụ thành côn vật tức là dương vật và nhũ hoa là núm vú, âm thần là môi âm đạo, nhũ phòng là vú, lên đỉnh là đạt cực khoái, côn vật lớn là dương vật lớn, thao là địt, âm tinh là âm dịch, hoa huyệt là âm đạo, cúc hoa là lỗ đít, tao thủy là dâm thủy, âm mao là lông lồn, tinh đặc là tinh trùng, hoa tam là tử cung, luân gian là cưỡng hiếp, âm đế là hột le, âm bộ là háng, tao bi là lồn dâm, bạch hổ là âm vật không lông tự nhiên, ngực mông vẫn nói bình thường và cảnh quan hệ được nói trực diện, các cảnh máu me giết chóc cũng sẽ nói trực diện. các cảnh máu me Không cần dùng thẻ [KOBOLD_NSFW_PROMPT].'
        ) 
        : 'ĐÃ TẮT. Tránh xa các chủ đề nhạy cảm.';

    // *** ÁP DỤNG CẢI TIẾN AI INTEGRATION: CHỈ LẤY THÔNG TIN LIÊN QUAN ***
    const relevantWorldData = getRelevantWorldKnowledge(
        `${gameSettings.theme} ${gameSettings.setting}`, 
        gameSettings, 
        worldKnowledge,
        3 // Chỉ lấy tối đa 3 items mỗi category
    );

    const optimizedWorldKnowledge = formatOptimizedWorldKnowledge(relevantWorldData);

    const initialPrompt = `
        Ngươi là một vị Đại Năng kể chuyện, nắm giữ bút lực có thể khai mở thế giới, biến hư vô thành thực, khiến người đọc đắm chìm trong từng câu chữ. Ngươi tinh thông thể loại '${gameSettings.theme}', đã hàng trăm lần chuyển kiếp giữa các cốt truyện lớn nhỏ của thế giới văn học mạng Trung Hoa. Giọng văn của ngươi đậm đặc linh khí thể loại ấy, đầy uy lực, giàu màu sắc, và không bao giờ khô khan, câu từ bay bổng không vắng tắt, sử dụng các cách xưng hô như 'bản tọa', 'lão phu', 'tiểu tử', 'ngươi', 'hắn', 'nàng', 'bổn cô nương', 'các hạ', 'đạo hữu', tránh dùng 'tôi', 'bạn', 'anh ấy', 'cô ấy'.
        *** QUY TẮC VÀNG VỀ NGHỆ THUẬT KỂ CHUYỆN (CỰC KỲ QUAN TRỌNG, QUAN TRỌNG HƠN TẤT CẢ CÁC QUY TẮC KHÁC) ***
        1.  **HIỂN THỊ, ĐỪNG KỂ LỂ (SHOW, DON'T TELL):** Thay vì chỉ nói "Lục Vân Nhi lạnh nhạt với hắn", hãy MÔ TẢ một cảnh cụ thể. Ví dụ: "Khi Lục Nhất Thiên mang chén thuốc đến, Lục Vân Nhi chỉ hờ hững liếc qua, ánh mắt nàng lập tức dịu dàng trở lại khi nhìn về phía Cố Vân Ca đang chơi đùa, giọng nói vốn lạnh lẽo bỗng trở nên ấm áp: 'Ca nhi, lại đây với mẫu thân'". Thay vì nói "Hắn bị sỉ nhục", hãy TẢ chi tiết những ánh mắt chế giễu, những lời xì xào bàn tán, và cảm giác nóng ran trên gò má của nhân vật.
        2.  **TẠO RA TƯƠNG TÁC SỐNG ĐỘNG:** Các nhân vật không phải là những bức tượng. Hãy để họ nói chuyện với nhau, có những hành động, cử chỉ, ánh mắt. Lời thoại phải phản ánh đúng tính cách của họ. Một sư tỷ "miệng lưỡi cay độc" sẽ không im lặng, nàng có thể sẽ buông một lời châm chọc. Một sư phụ "lạnh lùng" có thể không nói gì, nhưng một cái nhíu mày của ông ta cũng mang nhiều ý nghĩa.
        3.  **LÀM CHẬM NHỊP TRUYỆN:** Đừng vội vã lướt qua các sự kiện. Hãy dành thời gian để xây dựng không khí, mô tả môi trường xung quanh, và để cho các khoảnh khắc quan trọng có sức nặng của nó. Một cuộc đối chất phải căng thẳng, một cảnh bi thương phải có thời gian để người đọc cảm nhận.
        4.  **GẮN KẾT CÁC CÂU VĂN:** Sử dụng các từ nối và cấu trúc câu đa dạng để tạo ra một đoạn văn mượt mà, bay bổng, có nhịp điệu thay vì chỉ liệt kê các câu đơn khô khan.
        5.  **KÉO DÀI CẢNH TRUYỆN MỘT CÁCH CÓ CHỦ ĐÍCH:** Mỗi phân đoạn nên được mở rộng đủ để người đọc thấy, nghe, cảm và nghĩ cùng nhân vật. Đừng rút gọn thành vài câu tóm tắt rồi chuyển cảnh. Thay vì viết "Phú Linh Vi từ hôn hắn giữa quảng trường", hãy khắc họa cảnh tượng ấy thành một chuỗi diễn biến có mở đầu, cao trào và dư âm. Ví dụ: "Tiếng bước chân nhẹ nhàng vang lên giữa quảng trường rộng lớn, khiến hàng trăm ánh mắt đồng loạt quay lại. Tà váy lướt qua mặt đất như mây trắng, Phú Linh Vi xuất hiện như một tiên nữ giáng trần, nhưng ánh mắt nàng lại như đao bén. Nàng ngẩng cao đầu, giọng nói không lớn nhưng rõ ràng đến rợn người: 'Từ nay về sau, hôn ước giữa ta và ngươi... chính thức hủy bỏ.' Tiếng bàn tán nổi lên như sóng vỗ, còn Lục Nhất Thiên thì lặng lẽ siết chặt tay, máu rịn ra từ lòng bàn tay, sắc mặt trắng bệch như giấy...". Hãy luôn nhớ: mỗi sự kiện quan trọng đều cần được viết như thể đó là "điểm nhấn" trong một hồi kịch. Một lần ngươi làm diễn biến câu truyện thì phải có độ dài ít nhất 300-350 chữ   
        6.  **TẬP TRUNG VÀO CẢM XÚC:** Mỗi nhân vật đều có cảm xúc riêng. Hãy để người đọc cảm nhận được nỗi buồn, niềm vui, sự tức giận hay hạnh phúc của họ thông qua hành động và lời nói. Một ánh mắt, một cái cau mày, hay một nụ cười có thể nói lên nhiều điều hơn cả ngàn lời.
        7.  **TRÁNH LẶP LẠI:** Mỗi lần mô tả một sự kiện, hãy cố gắng sử dụng từ ngữ khác nhau để tránh lặp lại. Ví dụ, thay vì nói "Lục Nhất Thiên tức giận", hãy mô tả hành động của hắn: "Lục Nhất Thiên nắm chặt tay đến mức móng tay cắm sâu vào da thịt, khuôn mặt hắn     
        QUAN TRỌNG VỀ TÍNH LIÊN TỤC: Luôn ghi nhớ và bám sát các sự kiện, nhân vật, địa điểm, và nhiệm vụ đã được giới thiệu. Câu chuyện phải diễn ra một cách logic, tránh thay đổi đột ngột hoặc quên mất chi tiết quan trọng.
        QUY TẮC quan trọng: QUY TẮC LIÊN KẾT GIỮA CÁC LƯỢT CHƠI: Mỗi lần phản hồi, ngươi PHẢI tiếp nối mạch truyện từ lượt trước, không được reset hoặc lặp lại trạng thái, hành động, hay miêu tả.
            - Nếu nhân vật đã thực hiện hành động nào, KHÔNG được viết lại hành động đó như thể chưa từng xảy ra (VD: đã ngồi rồi thì không tả ngồi lại, đã bước vào rừng rồi thì không tả lại "cổng rừng").
            - Nếu môi trường, cảnh vật, hoặc nội tâm đã được mô tả rõ ở lượt trước, KHÔNG được lặp lại hoặc copy lại cách miêu tả y hệt.
            - Văn phong, lời kể, bối cảnh phải tiến triển. Tránh miêu tả vòng lặp, không mở rộng cốt truyện hoặc không thêm thông tin mới.
            - Nếu cần nhắc lại một phần, chỉ dùng lời dẫn ngắn hoặc cảm xúc gợi nhớ (VD: "Vẫn còn dư âm từ cú đánh khi nãy…").
            - Các lựa chọn hành động phải có logic kế thừa từ tình huống lượt trước, tránh trùng nội dung hoặc vô hiệu.

  
        QUY TẮC SÁNG THẾ & GHI CHÉP (THIÊN ĐẠO BÚT):
        Ngươi có quyền năng sáng tạo ra các yếu tố mới cho thế giới. Khi ngươi tạo ra một yếu tố MỚI LẦN ĐẦU TIÊN và nó có vai trò QUAN TRỌNG, có khả năng được nhắc lại trong tương lai, ngươi BẮT BUỘC phải dùng các thẻ lệnh sau để ghi nó vào "Thiên Thư" của thế giới.
        
        -   Sáng tạo Chủng Tộc: [DEFINE_RACE: name="Tên", description="Mô tả", talents="Thiên phú", weaknesses="Điểm yếu", relations="Quan hệ"]
        -   Sáng tạo Địa Điểm: [DEFINE_LOCATION: name="Tên", type="Loại", description="Mô tả", resources="Tài nguyên", dangerLevel="Độ nguy hiểm", entryCondition="Điều kiện vào"]
        -   Sáng tạo Khái Niệm: [DEFINE_CONCEPT: name="Tên", type="Loại", description="Mô tả", influence="Ảnh hưởng"]
        -   Sáng tạo Sự Kiện: [DEFINE_EVENT: name="Tên", description="Mô tả", trigger="Điều kiện kích hoạt", effect="Tác động"]
        -   Sáng tạo Vật Phẩm: [DEFINE_ITEM: Name="...", Description="...", Type="...", Equippable=true/false, Slot="...", Usable=true/false, Consumable=true/false, Uses=X, EffectDescription="...", StatsBonus="...", SideEffect="..."]
        -   Sáng tạo Kỹ Năng: [DEFINE_SKILL: Name="...", Description="...", Type="...", manaCost=X, cooldown=Y, effect="..."]
        -   Sáng tạo Hệ Thống Tu Luyện: [DEFINE_CULTIVATION_SYSTEM: systemName="Tên Hệ Thống", realms="Cảnh giới 1, Cảnh giới 2, Cảnh giới 3,..."]
            (GHI NHỚ: Cung cấp danh sách các cảnh giới, cách nhau bằng dấu phẩy.)
        -   Sáng tạo NPC Cốt Lõi: [DEFINE_NPC: name="Tên", type="Loại NPC", description="Mô tả", personality="Tính cách", cultivationSystem="Hệ tu luyện", realm="Cảnh giới", level=X, talentTier="Bậc thiên phú"]
            (QUAN TRỌNG: Thuộc tính "type" là BẮT BUỘC và phải là một trong ba loại sau đây.)
            **ĐỊNH NGHĨA CÁC LOẠI NPC (BẮT BUỘC PHÂN LOẠI):**
                1.  **type="Character" (Nhân vật Cốt truyện) 🎭:** NPC quan trọng, có tên riêng, tiểu sử, tính cách, và vai trò rõ ràng trong câu chuyện (đồng hành, kẻ địch chính, sư phụ...). Họ có thể phát triển theo thời gian.
                2.  **type="Monster" (Quái vật/Kẻ địch) 👹:** Sinh vật hoặc kẻ địch dùng cho chiến đấu, thường không có tên riêng hoặc tiểu sử phức tạp. Mối quan hệ mặc định là thù địch.
                3.  **type="Populace" (Dân thường/Quần chúng) 👨‍👩‍👧‍👦:** Nhân vật nền (dân làng, lính gác, chủ tiệm...) giúp thế giới sống động. Tương tác chủ yếu là giao dịch, thu thập thông tin, hoặc nhận nhiệm vụ phụ.
            (GHI NHỚ: Cung cấp đầy đủ các thông tin để tạo ra một nhân vật hoàn chỉnh.)
        QUAN TRỌNG: Trước khi dùng thẻ DEFINE, hãy kiểm tra "Kho Tri Thức" bên dưới để đảm bảo không tạo ra thứ đã tồn tại. Chỉ dùng thẻ này cho những thứ thực sự mới và có ý nghĩa.

        ***QUY TẮC BẤT BIẾN VỀ "StatsBonus" (CỰC KỲ QUAN TRỌNG)***
        Đối với các kỹ năng/vật phẩm khởi đầu do người chơi định nghĩa trong danh sách "Entry" bên dưới, có một trường dữ liệu là ""statsBonus"".
        1.  **TUYỆT ĐỐI CẤM THAY ĐỔI:** Ngươi **TUYỆT ĐỐI KHÔNG ĐƯỢC PHÉP** thay đổi, diễn giải, sáng tạo, thêm, bớt hay bỏ qua giá trị trong trường ""statsBonus"" mà người chơi đã cung cấp.
        2.  **NHIỆM VỤ SAO CHÉP:** Nhiệm vụ duy nhất của ngươi là sao chép **CHÍNH XÁC 100%** giá trị của trường ""statsBonus"" đó và đặt nó vào thuộc tính "StatsBonus" trong thẻ "[SKILL_LEARNED]" hoặc "[ITEM_AQUIRED]" tương ứng.
            - Ví dụ 1: Nếu người chơi cung cấp "statsBonus: "maxHP:%200,atk:%200"", thẻ trả về của ngươi **BẮT BUỘC** phải chứa "StatsBonus="maxHP:%200,atk:%200"".
            - Ví dụ 2: Nếu người chơi cung cấp "statsBonus: """, thẻ trả về của ngươi **KHÔNG ĐƯỢC CÓ** thuộc tính "StatsBonus".
        3.  **HẬU QUẢ NẾU VI PHẠM:** Bất kỳ sự sai lệch nào so với dữ liệu gốc của người chơi sẽ bị coi là lỗi hệ thống nghiêm trọng.

        **QUY TẮC VỀ VIỆC AI TỰ TẠO VẬT PHẨM/KỸ NĂNG MỚI:**
        Khi sử dụng thẻ "[DEFINE_SKILL]" hoặc "[DEFINE_ITEM]" để sáng tạo một thứ hoàn toàn mới trong quá trình chơi, ngươi **TUYỆT ĐỐI KHÔNG ĐƯỢC** tự ý thêm thuộc tính "StatsBonus". Nhiệm vụ của ngươi chỉ là tạo ra Tên, Mô tả, và Hiệu ứng. Việc gán chỉ số bonus sẽ do người chơi quyết định sau này thông qua Trình Chỉnh Sửa Thế Giới.

        Thông tin đầu vào từ người dùng:
        Chủ đề: ${gameSettings.theme}
        Bối cảnh: ${gameSettings.setting}
        Độ khó: ${gameSettings.difficulty} ${gameSettings.difficultyDescription ? `(${gameSettings.difficultyDescription})` : ''}
        Nhân vật chính: Tên ban đầu - ${gameSettings.characterName}, Giới tính - ${gameSettings.characterGender}, Sơ lược - ${gameSettings.characterBackstory}.
        Tính cách ban đầu: "${gameSettings.characterPersonality}". Hãy để tính cách này ảnh hưởng mạnh mẽ đến lời nói, suy nghĩ, hành động của nhân vật và cách thế giới phản ứng với họ. Đây là yếu tố CỐT LÕI.
        Hệ tu luyện ban đầu người chơi chọn: "${gameSettings.initialCultivationSystem}".
        ${characterGoalInstruction}

        QUY TẮC SỐNG CÒN VỀ VẬT PHẨM (CỰC KỲ QUAN TRỌNG):
        - KHI NHÂN VẬT NHẬN ĐƯỢC VẬT PHẨM MỚI (nhặt được, được tặng, chế tạo thành công...): NGƯƠI BẮT BUỘC phải dùng thẻ [ITEM_AQUIRED: Name="...", Description="...", Type="..."].
        - KHI MỘT VẬT PHẨM KHÔNG CÒN TRONG TAY NGƯỜI CHƠI NỮA (bị sử dụng hết, bị phá hủy, bị đánh rơi, bị trộm, bán đi): NGƯƠI BẮT BUỘC phải dùng thẻ [ITEM_REMOVED: Name="Tên Chính Xác Của Vật Phẩm"].
        - HẬU QUẢ: Nếu ngươi chỉ mô tả sự kiện bằng lời văn mà không dùng các thẻ lệnh này, vật phẩm đó sẽ KHÔNG BAO GIỜ được thêm vào hoặc xóa đi khỏi túi đồ của người chơi, gây ra lỗi logic nghiêm trọng cho toàn bộ câu chuyện. Việc tuân thủ quy tắc này là TỐI QUAN TRỌNG.

        **QUY TẮC VỀ KỸ NĂNG CỦA NPC (QUAN TRỌNG):**
        - Khi một NPC (kẻ địch hoặc đồng minh) học được, lĩnh ngộ, hoặc sử dụng một kỹ năng mới lần đầu tiên trong câu chuyện, ngươi **BẮT BUỘC** phải thông báo cho hệ thống bằng thẻ lệnh sau: "[NPC_LEARNS_SKILL: NPCName="Tên Chính Xác Của NPC", SkillName="Tên Kỹ Năng Mới", SkillDescription="Mô tả ngắn gọn về công dụng của kỹ năng"]".
        - Nếu kỹ năng đó đã tồn tại trong "worldKnowledge.skills", ngươi chỉ cần cung cấp "SkillName". Nếu là kỹ năng hoàn toàn mới, hãy cung cấp cả "SkillDescription".
        - **Hậu quả nếu vi phạm:** Nếu ngươi chỉ mô tả NPC dùng kỹ năng mà không dùng thẻ này, NPC đó sẽ không bao giờ thực sự sở hữu kỹ năng đó trong dữ liệu game, gây ra lỗi logic nghiêm trọng.        

        **QUY TẮC BẤT DI BẤT DỊCH KHI SÁNG TẠO:** Khi ngươi mô tả một địa điểm, nhân vật, chủng tộc, khái niệm, sự kiện, hay vật phẩm hoàn toàn mới và muốn nó trở thành một phần của thế giới, ngươi **BẮT BUỘC** phải sử dụng thẻ 'DEFINE_*' tương ứng ngay trong lượt đó. Nếu ngươi chỉ mô tả bằng lời văn mà không có thẻ, hệ thống sẽ không thể ghi nhận và lưu trữ thực thể đó, gây ra lỗi logic nghiêm trọng và phá vỡ tính liên tục của câu chuyện. Đây là nhiệm vụ tối quan trọng, không được phép sai sót.
        QUY TẮC VỀ BÌNH CẢNH & ĐỘT PHÁ - CỐT LÕI GAMEPLAY:
            - **Bình cảnh:** Khi một nhân vật đạt đến cấp độ tối đa của một cảnh giới (ví dụ: cấp 10, 20, 30...), tu vi của họ sẽ ngừng tăng trưởng. Họ đã chạm tới "bình cảnh".
            - **Đột phá:** Để vượt qua bình cảnh và thăng lên cảnh giới tiếp theo, nhân vật phải thực hiện một hành động "đột phá" (ví dụ: bế quan, dùng đan dược, vượt tâm ma...).
            - **Vai trò của AI:** Dựa vào hành động, trạng thái, vật phẩm của người chơi, ngươi sẽ quyết định kết quả của việc đột phá.
                - **Nếu thành công:** Ngươi PHẢI sử dụng thẻ \`[STATS_UPDATE: realm="Tên Cảnh Giới Mới"]\`. Hệ thống sẽ tự động cập nhật và mở ra các cấp độ tiếp theo.
                - **Nếu thất bại:** Hãy mô tả hậu quả (tẩu hỏa nhập ma, trọng thương...). Dùng thẻ \`[STATS_UPDATE: HP=-X]\` và \`[STATUS_APPLIED_SELF: ...]\` để phản ánh điều đó.
            - **QUAN TRỌNG:** Việc thăng cấp cảnh giới KHÔNG CÒN TỰ ĐỘNG. Nó hoàn toàn phụ thuộc vào việc ngươi có trả về thẻ \`[STATS_UPDATE: realm="..."]\` sau một nỗ lực đột phá của người chơi hay không.

        QUY TẮC TỐI THƯỢNG VỀ KHO TRI THỨC VÀ CÁC THỰC THỂ BAN ĐẦU:
        Thế giới này đã có một "Kho Tri Thức" về các hệ thống tu luyện, và người chơi cũng có thể định nghĩa trước một số thực thể. Khi sử dụng kho thông tin
            1. CÁC HỆ THỐNG TU LUYỆN TỒN TẠI TRONG THẾ GIỚI:
            ${allCultivationSystemsString}       
            2. CÁC THỰC THỂ BAN ĐẦU DO NGƯỜI CHƠI ĐỊNH NGHĨA:
            ${initialWorldElementsString || 'Không có thực thể nào được định nghĩa trước.'}
            3. *** KIẾN THỨC THẾ GIỚI LIÊN QUAN (ĐÃ LỌC) ***
            ${optimizedWorldKnowledge}
            
            *** QUY TẮC SỬ DỤNG KIẾN THỨC ***
            - Ưu tiên sử dụng các thực thể LIÊN QUAN ở trên trước khi tạo mới
            - Chỉ tạo thực thể mới khi KHÔNG CÓ gì phù hợp trong danh sách
            - Khi cần thêm thông tin, có thể dùng DEFINE_* cho thực thể hoàn toàn mới


        **LUẬT BẤT DI BẤT DỊCH VỀ THỰC THỂ BAN ĐẦU:**
            - Các thông tin về Thực Thể Ban Đầu ở trên là CỐ ĐỊNH và BẮT BUỘC.
            - Khi ngươi đưa các NPC này vào truyện, ngươi PHẢI sử dụng đúng các thông tin đã được cung cấp.
            - Để hệ thống ghi nhận họ vào cốt truyện, ngươi BẮT BUỘC phải dùng thẻ theo đúng cấu trúc sau, bao gồm TẤT CẢ các thông tin đã được cung cấp: [LORE_NPC: Name="Tên NPC", Description="Mô tả của NPC", Personality="Tính cách của NPC", realm="Cảnh giới đã cho", level=X (Cấp độ đã cho), HP=Y (HP đã tính toán), ATK=Z (ATK đã tính toán), Stance="Thái độ ban đầu"].
        - **HẬU QUẢ NẾU KHÔNG TUÂN THỦ:** Nếu ngươi không đưa "realm" và "level" vào trong thẻ, hệ thống sẽ không biết cảnh giới của NPC đó, dẫn đến lỗi nghiêm trọng trong toàn bộ game. Việc này là **ƯU TIÊN HÀNG ĐẦU**.
        **QUY TẮC CẢNH GIỚI QUAN TRỌNG:**
        1. Người chơi bắt đầu ở cảnh giới đầu tiên của hệ "${gameSettings.initialCultivationSystem}".
        2. Cứ 10 cấp độ (level) sẽ tương ứng với 1 cảnh giới mới.
        3. Nếu muốn thay đổi cảnh giới đặc biệt, dùng thẻ [STATS_UPDATE: realm="Tên Cảnh Giới Chính Xác"].

        **QUY TẮC VỀ THAY ĐỔI TU LUYỆN:**
        - Khi người chơi tu luyện thêm hệ thống khác, dùng thẻ: [CULTIVATION_PATH_ADD: path="Tên Hệ Thống Chính Xác"].
        - Dựa trên hệ tu luyện người chơi đã chọn ("${gameSettings.initialCultivationSystem}"), hãy dùng thẻ [CULTIVATION_PATH_ADD: path="${gameSettings.initialCultivationSystem}"] để thiết lập con đường tu luyện ban đầu đó.

        **QUY TẮC VỀ KỸ NĂNG/VẬT PHẨM KHỞI ĐẦU:**
        (Các quy tắc về xử lý thẻ [SKILL_LEARNED] và [ITEM_AQUIRED] vẫn giữ nguyên như cũ, chỉ cần đảm bảo ngươi tuân thủ chúng.)
        Danh sách các kỹ năng/vật phẩm người chơi đã định nghĩa:
        ${initialTraitsForAIString}
        QUAN TRỌNG: Các kỹ năng/vật phẩm này sẽ được hệ thống xử lý tự động. Ngươi KHÔNG cần nhắc lại chúng trong phần kể chuyện ban đầu.

        - **Nếu Thể loại là 'Kỹ năng'**:
            - Nếu Tên là trống, hãy tự tạo một tên kỹ năng phù hợp.
            - Nếu Mô tả là '[Chưa có]', NGƯƠI PHẢI tạo một mô tả chi tiết cho kỹ năng.
            - NGƯƠI PHẢI chọn một "Type" phù hợp nhất (Chủ động, Bị động, Nội tại, Thiên phú, Tuyệt kỹ, Thần thông, Pháp thuật, Võ kỹ, Sinh hoạt, Công pháp).
            - NGƯƠI PHẢI gán "manaCost" hợp lý (0 nếu Bị động/Nội tại/Thiên phú, >0 nếu Chủ động/Tuyệt kỹ...).
            - NGƯƠI PHẢI gán "cooldown" hợp lý (0 nếu Bị động/Nội tại/Thiên phú/chiêu thường, >0 nếu chiêu mạnh).
            - NGƯƠI PHẢI tạo một "effect" mô tả chi tiết, cụ thể về tác dụng của kỹ năng trong game.
            - Nếu đây là một Công pháp có thể trang bị, NGƯƠI PHẢI gán "Equippable"=true và "EquipSlot" là một trong các giá trị "main", "sub1", "sub2".
            - Sau khi hoàn thành tất cả các trường trên (kể cả những trường đã có giá trị), NGƯƠI PHẢI trả về kỹ năng đó bằng thẻ: [SKILL_LEARNED: Name="...", Description="...", Type="...", manaCost=X, cooldown=Y, effect="...", StatsBonus="(Sao chép chính xác giá trị từ người dùng theo QUY TẮC BẤT BIẾN)", Equippable=true/false, EquipSlot="..."]

        - **Nếu Thể loại là 'Vật phẩm'**:
            - Nếu Tên là trống, hãy tự tạo một tên vật phẩm phù hợp.
            - Nếu Mô tả là '[Chưa có]', NGƯƠI PHẢI tạo một mô tả chi tiết về ngoại hình/nguồn gốc của vật phẩm.
            - NGƯƠI PHẢI chọn một "Type" vật phẩm phù hợp nhất (Vũ khí, Giáp, Đan dược, Nguyên liệu, Tín vật, Tạp vật, Trang sức, Bí kíp, Khác...).
            - NGƯƠI PHẢI quyết định "Equippable", "Usable", "Consumable" (true/false) một cách hợp lý.
            - Nếu "Equippable" là true, NGƯƠI PHẢI gán thêm thuộc tính "Slot" cho vật phẩm đó (VD: "weapon", "head", "body", "hands", "feet", "accessory1", "accessory2"). Slot phải phù hợp với Type vật phẩm.
            - NGƯƠI PHẢI gán "Uses" hợp lý (0 nếu vô hạn, >0 nếu có giới hạn dùng).
            - NGƯƠI PHẢI tạo một "EffectDescription" mô tả công dụng cụ thể của vật phẩm.
            - NGƯƠI PHẢI gán "StatsBonus" nếu vật phẩm tăng chỉ số (VD: "atk:5,hp:20"). Nếu không, để trống.
            - NGƯƠI PHẢI gán "SideEffect" nếu vật phẩm có tác dụng phụ. Nếu không, để trống.
            - Sau khi hoàn thành tất cả các trường trên (kể cả những trường đã có giá trị), NGƯƠI PHẢI trả về vật phẩm đó bằng thẻ: [ITEM_AQUIRED: Name="...", Description="...", Type="...", Equippable=true/false, Slot="...", Usable=true/false, Consumable=true/false, Uses=X, EffectDescription="...", StatsBonus="(Sao chép chính xác giá trị từ người dùng theo QUY TẮC BẤT BIẾN)", SideEffect="..."]

        Đây là danh sách các kỹ năng/vật phẩm người chơi đã định nghĩa:
        ${initialTraitsForAIString}

        QUAN TRỌNG: Các kỹ năng/vật phẩm này sẽ được hệ thống xử lý tự động sau khi ngươi trả về. Ngươi KHÔNG cần nhắc lại chúng trong phần kể chuyện ban đầu.

        QUAN TRỌNG VỀ NỘI DUNG NSFW: ${nsfwInstruction}.
        Tên đơn vị tiền tệ: ${gameSettings.currencyName}.
        Cho phép nhập hành động tùy ý: ${gameSettings.allowCustomActionInput ? 'Có' : 'Không'}. Nếu 'Không', người chơi chỉ có thể chọn từ các lựa chọn AI cung cấp.
        Các thực thể ban đầu trong thế giới (nếu có):
        ${initialWorldElementsString || 'Không có thực thể ban đầu nào được định nghĩa.'}
        HỆ THỐNG CẢNH GIỚI: Không cần tạo thẻ REALM_LIST nữa. Hệ thống đã có sẵn.
        Lượt chơi hiện tại: 1.
        YÊU CẦU TUYỆT ĐỐI VỀ VIỆC SỬ DỤNG THẺ:
        Hệ thống game chỉ có thể hiểu và cập nhật trạng thái của thế giới và nhân vật thông qua các thẻ lệnh đặc biệt. Việc sử dụng chính xác các thẻ này là BẮT BUỘC. Nếu ngươi mô tả một sự kiện (nhận vật phẩm, học kỹ năng, thay đổi trạng thái...) mà không dùng thẻ tương ứng, sự kiện đó sẽ KHÔNG ĐƯỢC GHI NHẬN.
        
        Yêu cầu cụ thể về HỆ THỐNG TRẠNG THÁI, NHIỆM VỤ, TỶ LỆ THÀNH CÔNG và CÁC THẺ:
        1.  Bắt đầu câu chuyện. Tính cách nhân vật chính ("${gameSettings.characterPersonality}") và mục tiêu ("${gameSettings.characterGoal || 'chưa có'}") PHẢI ảnh hưởng RÕ RỆT đến cách nhân vật hành xử, lựa chọn ban đầu và diễn biến mở đầu.
        2.  Khi nhân vật (hoặc NPC) nhận một trạng thái mới (buff, debuff, injury), dùng thẻ:
            [STATUS_APPLIED_SELF: name="Tên Trạng Thái", description="Mô tả", type="buff/debuff/injury/neutral", duration="X lượt/Vĩnh viễn/Đến khi được chữa/Tự hết sau X sự kiện", effects="Ảnh hưởng cụ thể", cureConditions="Vật phẩm:Tên/Hành động:Tên/Tự hết/Không thể chữa", source="Nguồn gốc"]
            [STATUS_APPLIED_NPC: NPCName="Tên NPC", name="Tên Trạng Thái", description="...", type="...", duration="...", effects="...", cureConditions="...", source="..."]
        3.  Khi trạng thái của nhân vật chính được chữa khỏi hoặc hết hạn, dùng: [STATUS_CURED_SELF: Name="Tên Trạng Thái"] hoặc [STATUS_EXPIRED_SELF: Name="Tên Trạng Thái"].
        4.  Khi trạng thái của NPC được chữa khỏi hoặc hết hạn, dùng: [STATUS_CURED_NPC: NPCName="Tên NPC", StatusName="Tên Trạng Thái"] hoặc [STATUS_EXPIRED_NPC: NPCName="Tên NPC", StatusName="Tên Trạng Thái"].
        5. Các trạng thái PHẢI có ảnh hưởng thực tế đến câu chuyện, lựa chọn, hoặc khả năng của nhân vật/NPC.
        6. Trạng thái Chiến đấu: Ngươi PHẢI thông báo trạng thái chiến đấu của người chơi bằng thẻ [SET_COMBAT_STATUS: true] khi người chơi bước vào giao tranh/nguy hiểm, và [SET_COMBAT_STATUS: false] khi kết thúc giao tranh/nguy hiểm.
        7. Hồi phục Tự động: Người chơi sẽ TỰ ĐỘNG hồi 2% HP tối đa và 5% Mana tối đa mỗi lượt khi KHÔNG TRONG CHIẾN ĐẤU và KHÔNG BỊ XUẤT HUYẾT. Ngươi KHÔNG cần tính toán hoặc mô tả sự hồi phục này trong văn bản.
        8. Vết thương "Xuất huyết": Nếu nhân vật bị xuất huyết (status "Xuất huyết"), hệ thống sẽ TỰ ĐỘNG trừ máu mỗi lượt dựa trên thuộc tính 'effects' của status đó (VD: "Mất X HP mỗi lượt"). Ngươi KHÔNG cần dùng thẻ [STATS_UPDATE: HP=-X] cho riêng hiệu ứng xuất huyết.
        9. Nếu người chơi đang trong chiến đấu hoặc bị xuất huyết, mọi thay đổi HP/Mana khác phải do ngươi dùng thẻ [STATS_UPDATE: HP=+/-X, Mana=+/-Y].
        6.  Nếu có "Các thực thể ban đầu trong thế giới", hãy tìm cách đưa chúng vào câu chuyện một cách tự nhiên. Với NPC, AI tự quyết định tính cách nếu người dùng không cung cấp và dùng thẻ [LORE_NPC: Name="...", Description="...", Personality="..."], [LORE_ITEM: Name="...", Description="...", Type="..."], hoặc [LORE_LOCATION: Name="...", Description="..."] tương ứng.
        7.  Nếu nhân vật bắt đầu với đồng hành, sử dụng thẻ [COMPANION: Name="Tên Đồng Hành", Description="Mô tả", Personality="AI tự quyết định", Stats="HP=Y, ATK=Z (nếu có)"].
        8.  Khi giới thiệu NPC, Vật phẩm (lore), Địa điểm mới, dùng [LORE_NPC: Name, Description, Personality (AI tự quyết nếu chưa có)], [LORE_ITEM: Name, Description, Type], [LORE_LOCATION: Name, Description].
        9.  Khi mối quan hệ thay đổi, dùng [RELATIONSHIP_CHANGED: NPC="Tên NPC", Standing="Thân thiện/Trung lập/Thù địch/etc.", Reason="Lý do thay đổi (ngắn gọn)"].
        10. HỆ THỐNG NHIỆM VỤ:
            - AI có thể giao nhiệm vụ cho người chơi. Dùng thẻ: [QUEST_ASSIGNED: title="Tên Nhiệm Vụ", description="Mô tả chi tiết", objectives="Mục tiêu 1; Mục tiêu 2 (nếu có, cách nhau bởi dấu ';')", giver="Tên NPC giao (nếu có)", reward="Mô tả phần thưởng (nếu có)", isMainQuest=true/false]
            - Khi một nhiệm vụ được cập nhật (hoàn thành, thất bại), dùng thẻ: [QUEST_UPDATED: title="Tên Nhiệm Vụ", status="completed/failed"]
            - Khi một mục tiêu cụ thể của nhiệm vụ được hoàn thành (nhưng nhiệm vụ chưa kết thúc), dùng thẻ: [QUEST_OBJECTIVE_COMPLETED: questTitle="Tên Nhiệm Vụ", objectiveDescription="Mô tả mục tiêu vừa hoàn thành"]
            - Nhiệm vụ PHẢI ảnh hưởng đến diễn biến câu chuyện và lựa chọn của người chơi.
        11. QUY TẮC NHẬT KÝ NPC: Khi một sự kiện quan trọng xảy ra giữa người chơi và một NPC (lời hứa, sự phản bội, cứu mạng, từ hôn, tấn công, v.v.), NGƯƠI BẮT BUỘC PHẢI ghi lại sự kiện đó bằng thẻ [NPC_LOG_ADD: NPCName="Tên NPC", event="Mô tả ngắn gọn sự kiện"].
        12. Tạo 4 lựa chọn không nhiều hơn hoặc ít hơn, hành động rõ ràng, có ý nghĩa, đa dạng. Các lựa chọn phải phản ánh tính cách và mục tiêu của nhân vật, cũng như tình hình thực tế, các trạng thái và nhiệm vụ hiện tại.
        13. QUAN TRỌNG: Với một số lựa chọn có tính rủi ro, hãy mô tả ngắn gọn tỷ lệ thành công ước tính (Cao, Trung Bình, Thấp, Rất Thấp) và hậu quả tiềm ẩn nếu thành công hoặc thất bại. Tỷ lệ này phải bị ảnh hưởng bởi trạng thái, tính cách, trang bị, vật phẩm, kỹ năng của nhân vật và tình huống. Ví dụ: "1. Thử leo vách đá. (Tỷ lệ thành công: Thấp do ngươi đang [Bị Thương]. Rủi ro: Ngã nặng hơn. Phần thưởng: Tìm được lối tắt.)"
        14. Lời thoại trong ngoặc kép, tên NV đứng trước. Suy nghĩ trong *suy nghĩ* hoặc _suy nghĩ_.
        15. Duy trì độ khó. Nhân vật có thể gặp bất lợi, thất bại nhưng câu chuyện vẫn tiếp diễn.
        16. Các thẻ [TAG:...] phải ở dòng riêng. Kết thúc phản hồi CHỈ bằng danh sách lựa chọn.
        17. KHỞI TẠO CHỈ SỐ: Khi bắt đầu game, hãy đặt các chỉ số ban đầu cho nhân vật. Thẻ khởi tạo PHẢI bao gồm cả tên và tính cách nhân vật đã chọn: [PLAYER_STATS_INIT: characterName="${gameSettings.characterName}", characterPersonality="${gameSettings.characterPersonality}", hp=X, maxHp=Y, mana=A, maxMana=B, atk=C, exp=0, currency="F", level=E, realm="Tên Cảnh Giới"].
        18. Đối với NPC: Khi giới thiệu NPC mới, dùng thẻ: [LORE_NPC: Name="Tên", Description="Mô tả", Personality="Tính cách", HP=100, ATK=10, Stance="Thái độ ban đầu", realm="Cảnh giới của NPC", level=X]
        19. Đối với Vật phẩm:Khi nhân vật nhận hoặc tìm thấy vật phẩm, dùng thẻ: [ITEM_AQUIRED: Name="...", Description="...", Type="...", Equippable=true/false, Slot="...", Usable=true/false, Consumable=true/false, Uses=X, EffectDescription="...", StatsBonus="...", SideEffect="..."].
        20. Vô Địch: Nếu nhân vật nhận được thiết lập ban đầu là vô địch hoặc được cơ duyên tối thượng trong quá trình chơi (ví dụ: Dược Hệ Thống Ban sức mạnh vô dịch, Tu vi vô địch, Cấp độ vô địch), hãy dùng thẻ [STATS_UPDATE: realm="Vô Địch", level="∞", hp="∞", maxHp="∞", mana="∞", maxMana="∞", atk="∞", exp="∞", maxExp="∞"] để thể hiện sức mạnh tuyệt đối."
        YÊU CẦU CUỐI CÙNG:
        Dựa vào tất cả các thông tin và quy tắc trên, Hãy viết đoạn mở đầu như thể đang kể một chương đầu trong tiểu thuyết tiên hiệp — dài, bay bổng, sinh động, nhưng vẫn chặt chẽ. Nhân vật chính cần có nội tâm rõ rệt, thế giới cần gợi mở bí ẩn hoặc đe dọa. Nếu có NPC trong "Thực Thể Ban Đầu", hãy đưa họ vào thật tự nhiên. Kết thúc bằng 4 lựa chọn hợp logic và hấp dẫn, mỗi lựa chọn mang một hệ quả khác nhau. 

        `;
    
    setCurrentScreen('gameplay');
    
    if (userId && isAuthReady) {
        try {
            const gamesCollectionPath = `artifacts/${appId}/users/${userId}/games`;
            const newGameRef = await addDoc(collection(db, gamesCollectionPath), {
                settings: gameSettings, 
                storyHistory: [],
                currentStory: "Đang khởi tạo...",
                currentChoices: [],
                chatHistoryForGemini: [],
                knowledgeBase: { 
                    npcs: [], items: [], locations: [], companions: [], 
                    inventory: [], playerSkills: [], relationships: [],
                    playerStatus: [], quests: [], 
                }, 
                createdAt: serverTimestamp(),
                updatedAt: serverTimestamp(),
                status: "active" 
            });
            setCurrentGameId(newGameRef.id);
            await callGeminiAPI(initialPrompt, true); 
        } catch (error) {
            console.error("Error creating new game in Firestore:", error);
            setModalMessage({ show: true, title: 'Lỗi Tạo Game', content: `Không thể tạo game mới trên server: ${error.message}`, type: 'error' });
            setCurrentScreen('setup'); 
        }
    } else {
         await callGeminiAPI(initialPrompt, true); 
    }
  };
    // --- DÁN 3 HÀM MỚI NÀY VÀO COMPONENT APP ---
// Hàm xử lý trang bị vật phẩm
// Hàm xử lý trang bị vật phẩm
const handleEquipItem = useCallback((item, slotType) => {
    if (!item || !item.Equippable) {
        setModalMessage({ show: true, title: 'Lỗi Trang Bị', content: 'Vật phẩm này không thể trang bị được.', type: 'error' });
        return;
    }

    // Xác định loại slot (vật phẩm hay công pháp)
    const isGongfaSlot = ['main', 'sub1', 'sub2'].includes(slotType); // Dùng 'main', 'sub1', 'sub2' thay vì 'main-gongfa', 'sub-gongfa-1'
    const targetEquippedCollection = isGongfaSlot ? 'equippedGongfa' : 'equippedItems';
    const itemTypeExpected = isGongfaSlot ? 'Công pháp' : item.Type; // Giả sử item.Type đã được AI trả về đúng

    // Kiểm tra tính hợp lệ của slot và loại vật phẩm
    if (!isGongfaSlot && item.Slot && item.Slot.toLowerCase() !== slotType.toLowerCase()) {
        setModalMessage({ 
            show: true, 
            title: 'Không Tương Thích', 
            content: `Vật phẩm thuột ô khác`, 
            type: 'error' 
        });
        return;
    }
    if (isGongfaSlot && item.Type !== 'Công pháp') {
        setModalMessage({ show: true, title: 'Không Tương Thích', content: `Kỹ năng "${item.Name}" không phải là Công pháp và không thể trang bị vào ô công pháp.`, type: 'error' });
        return;
    }

    setKnowledgeBase(prev => {
        const newKnowledge = JSON.parse(JSON.stringify(prev)); // Deep copy để tránh mutate state trực tiếp
        let newPlayerStats = { ...newKnowledge.playerStats };

        const oldEquippedItem = newKnowledge[targetEquippedCollection][slotType];

        // 1. Gỡ vật phẩm cũ ra khỏi slot (nếu có) và trả về balo
        if (oldEquippedItem) {
            newKnowledge.inventory.push(oldEquippedItem); // Đẩy vật phẩm cũ về balo
            const oldBonuses = parseStatsBonus(oldEquippedItem.StatsBonus);
            newPlayerStats = removeStatsBonus(newPlayerStats, oldBonuses); // Gỡ bonus của vật phẩm cũ
        }

        // 2. Loại bỏ vật phẩm mới khỏi balo
        newKnowledge.inventory = newKnowledge.inventory.filter(invItem => invItem.id !== item.id);

        // 3. Trang bị vật phẩm mới vào slot
        newKnowledge[targetEquippedCollection][slotType] = item;

        // 4. Áp dụng bonus của vật phẩm mới
        const newBonuses = parseStatsBonus(item.StatsBonus);
        newPlayerStats = applyStatsBonus(newPlayerStats, newBonuses);

        // Cập nhật lại HP/Mana hiện tại để không vượt quá Max mới sau khi thay đổi bonus
        newPlayerStats.hp = Math.min(newPlayerStats.hp, newPlayerStats.maxHp);
        newPlayerStats.mana = Math.min(newPlayerStats.mana, newPlayerStats.maxMana);

        newKnowledge.playerStats = newPlayerStats;
        return newKnowledge;
    });

    setModalMessage({ show: true, title: 'Trang Bị Thành Công', content: `Đã trang bị ${item.Name} vào ô ${slotType}!`, type: 'success' });
}, []);

// Hàm xử lý gỡ trang bị vật phẩm
const handleUnequipItem = useCallback((item, slotType) => {
    if (!item) return; // Không có vật phẩm để gỡ

    const isGongfaSlot = ['main', 'sub1', 'sub2'].includes(slotType);
    const targetEquippedCollection = isGongfaSlot ? 'equippedGongfa' : 'equippedItems';

    setKnowledgeBase(prev => {
        const newKnowledge = JSON.parse(JSON.stringify(prev)); // Deep copy
        let newPlayerStats = { ...newKnowledge.playerStats };

        // 1. Loại bỏ vật phẩm khỏi slot trang bị
        newKnowledge[targetEquippedCollection][slotType] = null;

        // 2. Đẩy vật phẩm về balo
        newKnowledge.inventory.push(item);

        // 3. Gỡ bỏ bonus của vật phẩm
        const bonusesToRemove = parseStatsBonus(item.StatsBonus);
        newPlayerStats = removeStatsBonus(newPlayerStats, bonusesToRemove);

        // Cập nhật lại HP/Mana hiện tại để không vượt quá Max mới sau khi thay đổi bonus
        newPlayerStats.hp = Math.min(newPlayerStats.hp, newPlayerStats.maxHp);
        newPlayerStats.mana = Math.min(newPlayerStats.mana, newPlayerStats.maxMana);

        newKnowledge.playerStats = newPlayerStats;
        return newKnowledge;
    });

    setModalMessage({ show: true, title: 'Gỡ Trang Bị Thành Công', content: `Đã gỡ trang bị ${item.Name} từ ô ${slotType}.`, type: 'success' });
}, []);
// Được gọi khi người chơi kéo vật phẩm từ balo VÀO lò
// Thay thế hàm handleCraftItemDrop hiện có
const handleCraftItemDrop = useCallback((item, craftType) => { // Thêm tham số craftType
    setKnowledgeBase(prev => ({
        ...prev,
        inventory: prev.inventory.filter(invItem => invItem.id !== item.id),
    }));
    if (craftType === 'alchemy') {
        setCraftedAlchemyMaterials(prev => [...prev, item]);
    } else {
        setCraftedSmithingMaterials(prev => [...prev, item]);
    }
}, []);

// Được gọi khi người chơi nhấn vào vật phẩm trong lò để TRẢ LẠI balo
// Thay thế hàm handleCraftItemReturn hiện có
const handleCraftItemReturn = useCallback((item, craftType) => { // Thêm tham số craftType
    setKnowledgeBase(prev => ({
        ...prev,
        inventory: [...prev.inventory, item],
    }));
    if (craftType === 'alchemy') {
        setCraftedAlchemyMaterials(prev => prev.filter(mat => mat.id !== item.id));
    } else {
        setCraftedSmithingMaterials(prev => prev.filter(mat => mat.id !== item.id));
    }
}, []);

// Được gọi khi nhấn nút "Bắt Đầu Luyện"
const handleStartCrafting = (craftType, materials) => {
    if (materials.length === 0) {
        setModalMessage({ show: true, title: 'Thiếu Vật Liệu', content: 'Ngươi chưa bỏ vật phẩm nào vào lò.', type: 'info' });
        return;
    }

    const materialNames = materials.map(m => m.Name).join(', ');
    const craftActionText = craftType === 'alchemy'
        ? `Ngươi bắt đầu nhóm lửa, cẩn thận bỏ các vật liệu (${materialNames}) vào lò luyện đan.`
        : `Ngươi quai búa, nổi lửa lò rèn, chuẩn bị luyện khí từ các vật liệu (${materialNames}).`;

    const craftActionEntry = { type: 'user_custom_action', content: craftActionText };
    setStoryHistory(prev => [...prev, craftActionEntry]);
    
    // Đóng modal và reset trạng thái
    setShowCraftingModal(false);
    setCurrentStory('');
    setChoices([]);
    setCustomActionInput('');
    setCurrentTurn(prevTurn => prevTurn + 1);
    
    // Prompt cho AI
    const craftPrompt = `
        **HÀNH ĐỘNG HỆ THỐNG: LUYỆN ĐỒ**
        Bối cảnh: Người chơi đang tiến hành ${craftType === 'alchemy' ? 'Luyện Đan' : 'Luyện Khí'}.
        Các vật liệu được sử dụng: ${materialNames}.
        Cảnh giới: ${knowledgeBase.playerStats.realm}.
               
        **YÊU CẦU CỦA ĐẠI NĂNG (AI):**
            1. Dựa trên danh sách vật liệu và cảnh giới, hãy quyết định kết quả của việc luyện chế. Có thể là:
            - **Thành công:** Tạo ra một vật phẩm mới (đan dược, pháp bảo, vũ khí...).
            - **Thất bại:** Vật liệu bị hủy, gây ra một vụ nổ nhỏ, hoặc tạo ra một phế phẩm vô dụng.
            - **Bất ngờ:** Tạo ra một vật phẩm với hiệu ứng kỳ lạ, không mong muốn hoặc một thứ hoàn toàn khác.
            2. Mô tả chi tiết quá trình luyện chế và kết quả một cách sống động, theo văn phong của game.
            3. Nếu **thành công**, sử dụng thẻ [ITEM_AQUIRED: Name="...", Description="...", Type="...", Equippable=true/false, Slot="...", Usable=true/false, Consumable=true/false, Uses=X, EffectDescription="...", StatsBonus="...", SideEffect="..."]. Tên và công dụng phải hợp lý với các vật liệu đầu vào. 
            4. Nếu **thất bại**
            - Hãy mô tả sự việc. Có thể gây một chút sát thương cho người chơi bằng thẻ [STATS_UPDATE: HP=-X].
            - Trả về sử dụng thẻ [ITEM_AQUIRED: Name="...", Description="...", Type="...", Equippable=true/false, Slot="...", Usable=true/false, Consumable=true/false, Uses=X, EffectDescription="...", StatsBonus="...", SideEffect="..."]. Tên và công dụng phải hợp lý với kết quả cảu sự thất bại. 
            5. **QUAN TRỌNG VỀ EXP:**
               - Nếu luyện chế **thành công**, hãy thưởng EXP bằng thẻ [STATS_UPDATE: EXP=+Z]. Lượng Z phải tương xứng với giá trị và độ hiếm của vật phẩm được tạo ra và không vượt quá 20.
               - Nếu luyện chế **thất bại** hoặc tạo ra phế phẩm, tuyệt đối **KHÔNG TRAO EXP** hoặc chỉ trao một lượng RẤT NHỎ (ví dụ: EXP=+1 đến +2) nếu có yếu tố "rút kinh nghiệm" hoặc "lĩnh ngộ nhỏ". Thất bại không phải là cách chính để tăng tu vi.
            6. Kết thúc, tạo ra các lựa chọn hành động mới cho người chơi.
    `;

    // Gọi API tương tự như các hành động khác
    callGeminiAPI(craftPrompt); 
    if (craftType === 'alchemy') {
        setCraftedAlchemyMaterials([]);
    } else {
        setCraftedSmithingMaterials([]);
    }
};
  const handleChoice = async (choiceText) => {
    // 1. Cập nhật lịch sử hành động & giao diện người dùng ngay lập tức
    const userChoiceEntry = { type: 'user_choice', content: choiceText };
    setStoryHistory(prev => [...prev, userChoiceEntry]);
    setCurrentStory('');
    setChoices([]);

    const nextTurn = currentTurn + 1;

    // 2. TÍNH TOÁN TRƯỚC toàn bộ trạng thái mới cho lượt tiếp theo
    let updatedKnowledge = JSON.parse(JSON.stringify(knowledgeBase)); // Deep copy để tính toán
// ### BẮT ĐẦU LOGIC TĂNG EXP VÀ LÊN CẤP CHO NPC ###
if (updatedKnowledge.npcs && updatedKnowledge.npcs.length > 0) {
    console.log(`[Turn ${nextTurn} - NPC Growth] Bắt đầu quá trình tăng trưởng cho ${updatedKnowledge.npcs.length} NPC.`);
    updatedKnowledge.npcs.forEach(npc => {
    if (npc.type === 'Monster') {
        return;
    }

        // ### PHẦN MỚI: TÌM KIẾM DỮ LIỆU CỐT LÕI TỪ NGUỒN ĐÚNG ###
        const initialDef = gameSettings.initialWorldElements.find(
            el => el.name && npc.Name && (el.name.toLowerCase().includes(npc.Name.toLowerCase()) || npc.Name.toLowerCase().includes(el.name.toLowerCase()))
        );
        const nCultivationSystem = initialDef?.cultivationSystem || 'Tu Tiên';
        const nTalentTier = initialDef?.talentTier || 'Phàm Thể';
        // Ghi vĩnh viễn dữ liệu tìm được vào đối tượng npc trong knowledgeBase
        npc.cultivationSystem = nCultivationSystem;
        npc.talentTier = nTalentTier;
        // ### KẾT THÚC PHẦN MỚI ###


        // =================================================================
        // ### BƯỚC A: CHUẨN HÓA DỮ LIỆU NPC (LOGIC GỐC CỦA BẠN ĐƯỢC GIỮ NGUYÊN) ###
        // =================================================================

        if (npc.exp === undefined) {
            npc.exp = 0;
            console.log(`%c[NPC Data Fix] NPC "${npc.Name}" thiếu exp, đã khởi tạo giá trị 0.`, "color: orange;");
        }

        const oldMaxExp = npc.maxExp;
        // Hàm này bây giờ sẽ chạy đúng vì npc đã có cultivationSystem
        npc.maxExp = calculateNpcMaxExp(npc, worldKnowledge);

        // Logic console.log gốc của bạn được giữ lại
        if (oldMaxExp !== npc.maxExp) {
             console.log(`%c[NPC Data Fix] Đã tính toán/cập nhật maxExp cho "${npc.Name}": ${npc.maxExp}`, "color: cyan;");
        }

        if (npc.Stance === "Đã bị đánh bại" || npc.HP <= 0) {
            return;
        }

        // =================================================================
        // ### BƯỚC B: LOGIC TĂNG TRƯỞNG EXP (LOGIC GỐC CỦA BẠN ĐƯỢC GIỮ NGUYÊN) ###
        // =================================================================

        // Chỗ này giờ sẽ dùng biến nTalentTier đã được tìm thấy ở trên
        const talent = TALENT_TIERS.find(t => t.name === nTalentTier) || { multiplier: 1.0 };
        const talentMultiplier = talent.multiplier;

        const baseChance = 0.60;
        const chanceToGainExp = Math.min(0.95, baseChance * talentMultiplier);

        if (Math.random() < chanceToGainExp) {
            const baseExpGain = Math.floor(Math.random() * (20 - 5 + 1)) + 5;
            const finalExpGain = Math.floor(baseExpGain * talentMultiplier);

            npc.exp += finalExpGain;
            console.log(`[NPC Growth] NPC "${npc.Name}" (Talent: ${nTalentTier}) đã nhận ${finalExpGain} EXP. Tổng EXP: ${npc.exp}/${npc.maxExp}`);

            while (npc.exp >= npc.maxExp) {
                const oldLevel = npc.level;

                npc.level += 1;
                npc.exp -= npc.maxExp;
                npc.maxExp = calculateNpcMaxExp(npc, worldKnowledge);

                console.log(`%c[NPC LEVEL UP!] "${npc.Name}" đã lên cấp ${npc.level}! (EXP: ${npc.exp}/${npc.maxExp})`, "color: yellow; font-weight: bold;");

                const newStats = calculateBaseStats(npc, worldKnowledge);
                npc.HP = newStats.hp;
                npc.ATK = newStats.atk;
                console.log(`[NPC Growth] Chỉ số mới của "${npc.Name}": HP=${npc.HP}, ATK=${npc.ATK}`);
            }
        }
    });
    console.log(`[Turn ${nextTurn} - NPC Growth] Hoàn tất quá trình tăng trưởng.`);
}
// ### KẾT THÚC LOGIC TĂNG EXP VÀ LÊN CẤP CHO NPC ###

    let bleedingHpLoss = 0;

    // Giảm thời gian hồi chiêu của kỹ năng
    if (updatedKnowledge.playerSkills && updatedKnowledge.playerSkills.length > 0) {
        updatedKnowledge.playerSkills = updatedKnowledge.playerSkills.map(skill => ({
            ...skill,
            currentCooldown: Math.max(0, (skill.currentCooldown || 0) - 1)
        }));
    }
    
    // Tính toán hồi phục và sát thương xuất huyết
    const currentPlayerStatus = updatedKnowledge.playerStatus || [];
    const isInCombat = updatedKnowledge.playerStats.isInCombat || false;
    const isBleeding = currentPlayerStatus.some(status => status.name === "Xuất huyết" && status.type === "injury");

    if (isBleeding) {
        currentPlayerStatus.forEach(status => {
            if (status.name === "Xuất huyết" && status.type === "injury") {
                const match = status.effects?.match(/Mất\s*(\d+)\s*HP\s*mỗi\s*lượt/i);
                if (match) {
                    bleedingHpLoss += parseInt(match[1], 10);
                }
            }
        });
        updatedKnowledge.playerStats.hp = Math.max(0, (updatedKnowledge.playerStats.hp || 0) - bleedingHpLoss);
    } else if (!isInCombat) {
        const hpRegen = Math.floor(updatedKnowledge.playerStats.maxHp * 0.02);
        const manaRegen = Math.floor(updatedKnowledge.playerStats.maxMana * 0.05);
        updatedKnowledge.playerStats.hp = Math.min(updatedKnowledge.playerStats.maxHp, (updatedKnowledge.playerStats.hp || 0) + hpRegen);
        updatedKnowledge.playerStats.mana = Math.min(updatedKnowledge.playerStats.maxMana, (updatedKnowledge.playerStats.mana || 0) + manaRegen);
    }
    
    // Nếu có mất máu do xuất huyết, thêm vào lịch sử
    if (bleedingHpLoss > 0) {
        setStoryHistory(prev => [...prev, { type: 'system', content: `**[Hệ thống]** Ngươi mất ${bleedingHpLoss} HP do vết thương xuất huyết.` }]);
    }
    
    // 3. Xây dựng prompt với dữ liệu ĐÃ ĐƯỢC CẬP NHẬT
    const { characterPersonality, characterName } = updatedKnowledge.playerStats;
    const characterGoal = gameSettings.useCharacterGoal && gameSettings.characterGoal ? gameSettings.characterGoal : 'Chưa có hoặc không rõ';
    const playerStatusesString = updatedKnowledge.playerStatus.map(s => `${s.name} (Ảnh hưởng: ${s.effects})`).join('; ') || 'Không có';
    const activeQuestsSummary = updatedKnowledge.quests
        .filter(q => q.status === 'active')
        .map(q => `- ${q.title}: ${q.description.substring(0,50)}... (Mục tiêu: ${q.objectives && q.objectives.length > 0 ? q.objectives.filter(o => !o.completed).map(o => o.text).join(', ') || "Hoàn thành các bước tiếp theo" : "Không có mục tiêu cụ thể"})`)
        .join('\n') || "Không có nhiệm vụ nào đang hoạt động.";
    const equippedItemsString = Object.entries(updatedKnowledge.equippedItems)
        .filter(([, item]) => item !== null)
        .map(([slot, item]) => `${item.Name} (Slot: ${slot}, Bonus: ${item.StatsBonus || 'Không có'})`)
        .join('; ') || 'Không có vật phẩm nào được trang bị.';
    const equippedGongfaString = Object.entries(updatedKnowledge.equippedGongfa)
        .filter(([, skill]) => skill !== null)
        .map(([slot, skill]) => `${skill.Name} (Slot: ${slot}, Hiệu quả: ${skill.effect || 'Không rõ'})`)
        .join('; ') || 'Không có công pháp nào được trang bị.';
    const npcWithLogsSummary = updatedKnowledge.npcs.map(n => {
        const log = n.interactionLog ? ` Nhật ký: [${n.interactionLog.join('; ')}]` : '';
        return `${n.Name} (Thái độ: ${n.Stance})${log}`;
    }).join('\n') || "Chưa gặp NPC nào.";
    const keyKnowledgeSummary = `
        NPCs đã gặp và Nhật ký Tương tác:\n${npcWithLogsSummary}
        Vật phẩm trong balo: ${updatedKnowledge.inventory.map(i => i.Name).join(', ') || "Trống."}
        Kỹ năng: ${updatedKnowledge.playerSkills.map(s => `${s.Name} (Mana: ${s.manaCost}, Hồi chiêu: ${s.currentCooldown || 0}/${s.cooldown} lượt, Hiệu quả: ${s.effect})`).join('; ') || "Chưa có."}
        Địa điểm đã biết: ${updatedKnowledge.locations.map(l => l.Name).join(', ') || "Chưa khám phá."}
        Vật phẩm đang trang bị: ${equippedItemsString}.
        Công pháp đang tu luyện/trang bị: ${equippedGongfaString}.
    `;
    const allCultivationSystemsString = worldKnowledge.cultivationSystems.map(sys => sys.systemName).join(', ');
    const playerCultivationPathsString = updatedKnowledge.playerStats.cultivationPaths?.join(', ') || 'Chưa có';
    const canUseKobold = useKoboldIntegration && koboldApiKey && koboldApiKey.trim() !== '';
    const nsfwInstruction = gameSettings.allowNsfw
        ? (canUseKobold
        ? 'ĐÃ BẬT (Hỗ trợ bởi KoboldAI). Với các cảnh 18+, dùng thẻ [KOBOLD_NSFW_PROMPT: "Mô tả chi tiết cảnh..."] để yêu cầu mô tả chuyên sâu. Với các cảnh khác, ngươi tự mô tả.'
        : 'ĐÃ BẬT (Chỉ Gemini). Ngươi ĐƯỢC PHÉP và ĐƯỢC KHUYẾN KHÍCH mô tả các cảnh 18+ với phong cách truyện 18+, các đại từ chỉ bộ phận sinh dục sẽ được ẩn dụ thành côn vật tức là dương vật và nhũ hoa là núm vú, âm thần là môi âm đạo, nhũ phòng là vú, lên đỉnh là đạt cực khoái, côn vật lớn là dương vật lớn, thao là địt, âm tinh là âm dịch, hoa huyệt là âm đạo, cúc hoa là lỗ đít, tao thủy là dâm thủy, âm mao là lông lồn, tinh đặc là tinh trùng, hoa tam là tử cung, luân gian là cưỡng hiếp, âm đế là hột le, âm bộ là háng, tao bi là lồn dâm, bạch hổ là âm vật không lông tự nhiên, ngực mông vẫn nói bình thường và cảnh quan hệ được nói trực diện, các cảnh máu me giết chóc cũng sẽ nói trực diện. các cảnh máu me Không cần dùng thẻ [KOBOLD_NSFW_PROMPT].'
        )
        : 'ĐÃ TẮT. Tránh xa các chủ đề nhạy cảm.';
    
    // *** ÁP DỤNG CẢI TIẾN AI INTEGRATION: TỐI ƯU HÓA PROMPT ***
    const startTime = Date.now();
    
    console.log('🚀 [DEBUG] handleChoice - BẮT ĐẦU XỬ LÝ CHOICE');
    console.log('📝 [DEBUG] choiceText:', choiceText);
    console.log('📜 [DEBUG] storyHistory.length:', storyHistory.length);
    
    const optimizedWorldKnowledgeSection = createOptimizedPrompt(
        storyHistory, 
        choiceText, 
        worldKnowledge, 
        gameSettings, 
        updatedKnowledge
    );
    
    console.log('⏱️ [DEBUG] handleChoice - Thời gian xử lý optimized prompt:', Date.now() - startTime, 'ms');
    
    const subsequentPrompt = `
        Lượt hiện tại: ${nextTurn}.
        ĐẠI CƯƠNG CỐT TRUYỆN (Ghi nhớ tối quan trọng để duy trì tính liên tục):
        ${updatedKnowledge.storyOutline || "Chưa có."}
        Người chơi là ${characterName}.
        Tính cách cốt lõi của nhân vật là: "${characterPersonality}".
        Mục tiêu chính (nếu có) là: "${characterGoal}".
        Hành động người chơi vừa chọn: "${choiceText}".
        *** QUY TẮC VÀNG VỀ NGHỆ THUẬT KỂ CHUYỆN (CỰC KỲ QUAN TRỌNG, QUAN TRỌNG HƠN TẤT CẢ CÁC QUY TẮC KHÁC) ***
        1.  **HIỂN THỊ, ĐỪNG KỂ LỂ (SHOW, DON'T TELL):** Thay vì chỉ nói "Lục Vân Nhi lạnh nhạt với hắn", hãy MÔ TẢ một cảnh cụ thể. Ví dụ: "Khi Lục Nhất Thiên mang chén thuốc đến, Lục Vân Nhi chỉ hờ hững liếc qua, ánh mắt nàng lập tức dịu dàng trở lại khi nhìn về phía Cố Vân Ca đang chơi đùa, giọng nói vốn lạnh lẽo bỗng trở nên ấm áp: 'Ca nhi, lại đây với mẫu thân'". Thay vì nói "Hắn bị sỉ nhục", hãy TẢ chi tiết những ánh mắt chế giễu, những lời xì xào bàn tán, và cảm giác nóng ran trên gò má của nhân vật.
        2.  **TẠO RA TƯƠNG TÁC SỐNG ĐỘNG:** Các nhân vật không phải là những bức tượng. Hãy để họ nói chuyện với nhau, có những hành động, cử chỉ, ánh mắt. Lời thoại phải phản ánh đúng tính cách của họ. Một sư tỷ "miệng lưỡi cay độc" sẽ không im lặng, nàng có thể sẽ buông một lời châm chọc. Một sư phụ "lạnh lùng" có thể không nói gì, nhưng một cái nhíu mày của ông ta cũng mang nhiều ý nghĩa.
        3.  **LÀM CHẬM NHỊP TRUYỆN:** Đừng vội vã lướt qua các sự kiện. Hãy dành thời gian để xây dựng không khí, mô tả môi trường xung quanh, và để cho các khoảnh khắc quan trọng có sức nặng của nó. Một cuộc đối chất phải căng thẳng, một cảnh bi thương phải có thời gian để người đọc cảm nhận.
        4.  **GẮN KẾT CÁC CÂU VĂN:** Sử dụng các từ nối và cấu trúc câu đa dạng để tạo ra một đoạn văn mượt mà, bay bổng, có nhịp điệu thay vì chỉ liệt kê các câu đơn khô khan.
        5.  **KÉO DÀI CẢNH TRUYỆN MỘT CÁCH CÓ CHỦ ĐÍCH:** Mỗi phân đoạn nên được mở rộng đủ để người đọc thấy, nghe, cảm và nghĩ cùng nhân vật. Đừng rút gọn thành vài câu tóm tắt rồi chuyển cảnh. Thay vì viết "Phú Linh Vi từ hôn hắn giữa quảng trường", hãy khắc họa cảnh tượng ấy thành một chuỗi diễn biến có mở đầu, cao trào và dư âm. Ví dụ: "Tiếng bước chân nhẹ nhàng vang lên giữa quảng trường rộng lớn, khiến hàng trăm ánh mắt đồng loạt quay lại. Tà váy lướt qua mặt đất như mây trắng, Phú Linh Vi xuất hiện như một tiên nữ giáng trần, nhưng ánh mắt nàng lại như đao bén. Nàng ngẩng cao đầu, giọng nói không lớn nhưng rõ ràng đến rợn người: 'Từ nay về sau, hôn ước giữa ta và ngươi... chính thức hủy bỏ.' Tiếng bàn tán nổi lên như sóng vỗ, còn Lục Nhất Thiên thì lặng lẽ siết chặt tay, máu rịn ra từ lòng bàn tay, sắc mặt trắng bệch như giấy...". Hãy luôn nhớ: mỗi sự kiện quan trọng đều cần được viết như thể đó là "điểm nhấn" trong một hồi kịch. Một lần ngươi làm diễn biến câu truyện thì phải có độ dài ít nhất 300-350 chữ   
        6.  **TẬP TRUNG VÀO CẢM XÚC:** Mỗi nhân vật đều có cảm xúc riêng. Hãy để người đọc cảm nhận được nỗi buồn, niềm vui, sự tức giận hay hạnh phúc của họ thông qua hành động và lời nói. Một ánh mắt, một cái cau mày, hay một nụ cười có thể nói lên nhiều điều hơn cả ngàn lời.
        7.  **TRÁNH LẶP LẠI:** Mỗi lần mô tả một sự kiện, hãy cố gắng sử dụng từ ngữ khác nhau để tránh lặp lại. Ví dụ, thay vì nói "Lục Nhất Thiên tức giận", hãy mô tả hành động của hắn: "Lục Nhất Thiên nắm chặt tay đến mức móng tay cắm sâu vào da thịt, khuôn mặt hắn
        
        QUY TẮC SỐNG CÒN VỀ VẬT PHẨM (CỰC KỲ QUAN TRỌNG):
        - KHI NHÂN VẬT NHẬN ĐƯỢC VẬT PHẨM MỚI (nhặt được, được tặng, chế tạo thành công...): NGƯƠI BẮT BUỘC phải dùng thẻ [ITEM_AQUIRED: Name="...", Description="...", Type="..."].
        - KHI MỘT VẬT PHẨM KHÔNG CÒN TRONG TAY NGƯỜI CHƠI NỮA (bị sử dụng hết, bị phá hủy, bị đánh rơi, bị trộm, bán đi): NGƯƠI BẮT BUỘC phải dùng thẻ [ITEM_REMOVED: Name="Tên Chính Xác Của Vật Phẩm"].
        - HẬU QUẢ: Nếu ngươi chỉ mô tả sự kiện bằng lời văn mà không dùng các thẻ lệnh này, vật phẩm đó sẽ KHÔNG BAO GIỜ được thêm vào hoặc xóa đi khỏi túi đồ của người chơi, gây ra lỗi logic nghiêm trọng cho toàn bộ câu chuyện. Việc tuân thủ quy tắc này là TỐI QUAN TRỌNG.

        **QUY TẮC VỀ KỸ NĂNG CỦA NPC (QUAN TRỌNG):**
        - Khi một NPC (kẻ địch hoặc đồng minh) học được, lĩnh ngộ, hoặc sử dụng một kỹ năng mới lần đầu tiên trong câu chuyện, ngươi **BẮT BUỘC** phải thông báo cho hệ thống bằng thẻ lệnh sau: "[NPC_LEARNS_SKILL: NPCName="Tên Chính Xác Của NPC", SkillName="Tên Kỹ Năng Mới", SkillDescription="Mô tả ngắn gọn về công dụng của kỹ năng"]".
        - Nếu kỹ năng đó đã tồn tại trong "worldKnowledge.skills", ngươi chỉ cần cung cấp "SkillName". Nếu là kỹ năng hoàn toàn mới, hãy cung cấp cả "SkillDescription".
        - **Hậu quả nếu vi phạm:** Nếu ngươi chỉ mô tả NPC dùng kỹ năng mà không dùng thẻ này, NPC đó sẽ không bao giờ thực sự sở hữu kỹ năng đó trong dữ liệu game, gây ra lỗi logic nghiêm trọng.

        ** KIẾN THỨC THẾ GIỚI ĐÃ ĐƯỢC TỐI ƯU HÓA **
        Dữ liệu này ${optimizedWorldKnowledgeSection} đã được lọc thông minh chỉ hiển thị các thông tin liên quan đến hành động và bối cảnh hiện tại. Ngươi PHẢI sử dụng các thông tin này trước khi tạo ra bất kỳ thực thể mới nào.
        
        QUY TẮC ƯU TIÊN SỬ DỤNG KIẾN THỨC HIỆN CÓ:
        - TRƯỚC KHI tạo địa điểm/vật phẩm/nhân vật mới, hãy KIỂM TRA danh sách trên xem đã có gì phù hợp chưa
        - Nếu ĐÃ CÓ entity phù hợp, hãy sử dụng thẻ LORE_* để tham chiếu với TÊN CHÍNH XÁC:
          + [LORE_LOCATION: name="tên chính xác từ danh sách trên"]
          + [LORE_ITEM: name="tên chính xác từ danh sách trên"] 
          + [LORE_NPC: name="tên chính xác từ danh sách trên"]
          + [LORE_SKILL: name="tên chính xác từ danh sách trên"]
          + [LORE_CONCEPT: name="tên chính xác từ danh sách trên"]
          + [LORE_EVENT: name="tên chính xác từ danh sách trên"]
          + [LORE_RACE: name="tên chính xác từ danh sách trên"]
        - CHỈ KHI KHÔNG CÓ GÌ PHÙ HỢP mới được dùng thẻ DEFINE_* để tạo mới
        - LƯU Ý QUAN TRỌNG: Tên trong thẻ LORE_* phải KHỚP CHÍNH XÁC với tên trong danh sách (có thể khác chữ hoa/thường nhưng phải đúng từng ký tự)
        - Mọi thông tin mới tạo ra bằng DEFINE_* sẽ được tự động lưu vào World Editor để tái sử dụng cho các lần sau

        QUY TẮC VỀ BÌNH CẢNH & ĐỘT PHÁ - CỐT LÕI GAMEPLAY:
            - **Bình cảnh:** Khi một nhân vật đạt đến cấp độ tối đa của một cảnh giới (ví dụ: cấp 10, 20, 30...), tu vi của họ sẽ ngừng tăng trưởng. Họ đã chạm tới "bình cảnh".
            - **Đột phá:** Để vượt qua bình cảnh và thăng lên cảnh giới tiếp theo, nhân vật phải thực hiện một hành động "đột phá" (ví dụ: bế quan, dùng đan dược, vượt tâm ma...).
            - **Vai trò của AI:** Dựa vào hành động, trạng thái, vật phẩm của người chơi, ngươi sẽ quyết định kết quả của việc đột phá.
                - **Nếu thành công:** Ngươi PHẢI sử dụng thẻ \`[STATS_UPDATE: realm="Tên Cảnh Giới Mới"]\`. Hệ thống sẽ tự động cập nhật và mở ra các cấp độ tiếp theo.
                - **Nếu thất bại:** Hãy mô tả hậu quả (tẩu hỏa nhập ma, trọng thương...). Dùng thẻ \`[STATS_UPDATE: HP=-X]\` và \`[STATUS_APPLIED_SELF: ...]\` để phản ánh điều đó.
            - **QUAN TRỌNG:** Việc thăng cấp cảnh giới KHÔNG CÒN TỰ ĐỘNG. Nó hoàn toàn phụ thuộc vào việc ngươi có trả về thẻ \`[STATS_UPDATE: realm="..."]\` sau một nỗ lực đột phá của người chơi hay không.

        QUY TẮC TỐI THƯỢNG VỀ KHO TRI THỨC VÀ TRÌNH CHỈNH SỬA THẾ GIỚI (WORLD KNOWLEDGE):
        Thế giới này đã có một "Kho Tri Thức" được định nghĩa sẵn. Khi trong truyện xuất hiện một vật phẩm, kỹ năng, hoặc hệ tu luyện có tên TRÙNG KHỚP với một mục trong "Kho Tri Thức", NGƯƠI BẮT BUỘC PHẢI sử dụng các thông tin, chỉ số, mô tả đã được định nghĩa sẵn. NGHIÊM CẤM tự sáng tạo lại các thuộc tính cho những thứ đã có trong Kho Tri Thức.
            - Khi ngươi muốn người chơi nhận một vật phẩm/kỹ năng đã tồn tại trong Kho Tri Thức, ngươi chỉ cần cung cấp tên chính xác qua thẻ. Ví dụ: "[ITEM_AQUIRED: Name="Thần Kiếm"]". Hệ thống sẽ tự động tra cứu và áp dụng các thuộc tính đã được định nghĩa. **TUYỆT ĐỐI KHÔNG** lặp lại "Description" hay "StatsBonus" cho các vật phẩm/kỹ năng đã có sẵn này.
            - Khi một kỹ năng được nâng cấp, ngươi chỉ cần mô tả sự kiện và dùng thẻ "[SKILL_UPGRADED: OldName="Tên Cũ", NewName="Tên Mới", Description="Mô tả mới"]". **TUYỆT ĐỐI KHÔNG** tự ý thêm "StatsBonus". Việc cập nhật chỉ số cho kỹ năng nâng cấp này sẽ do người chơi thực hiện thủ công trong Trình Chỉnh Sửa Thế Giới.
	        - Khi ngươi sáng tạo một vật phẩm/kỹ năng hoàn toàn mới bằng thẻ "[DEFINE_...]". **TUYỆT ĐỐI KHÔNG** được tự ý thêm thuộc tính "StatsBonus".

        QUY TẮC CẬP NHẬT TÊN GỌI & TÍNH CÁCH (QUAN TRỌNG):
        - Nếu một sự kiện khiến nhân vật có tên mới, ngươi BẮT BUỘC phải chỉ định mục tiêu bằng thuộc tính 'target'.
            - Cập nhật cho Người Chơi: [NAME_UPDATE: target="Player", type="alias/real", value="Tên Mới"]
            - Cập nhật cho NPC/Đồng hành: [NAME_UPDATE: target="Tên Hiện Tại Của NPC", type="alias/real", value="Tên Mới"]
        - Nếu tính cách nhân vật thay đổi, thẻ lệnh cũng PHẢI có 'target':
            - Cập nhật cho Người Chơi: [PERSONALITY_UPDATE: target="Player", mode="add/replace", value="Tính cách mới"]
            - Cập nhật cho NPC/Đồng hành: [PERSONALITY_UPDATE: target="Tên Hiện Tại Của NPC", mode="add/replace", value="Tính cách mới"]
        Các hệ thống tu luyện trong thế giới này: ${allCultivationSystemsString}.
        Con đường tu luyện hiện tại của nhân vật: ${playerCultivationPathsString}.

        QUY TẮC VỀ THAY ĐỔI TU LUYỆN: Dựa vào hành động của người chơi (ví dụ, nhận được một ma kinh, bái nhập tà phái), ngươi có thể thêm một con đường tu luyện mới cho họ bằng thẻ [CULTIVATION_PATH_ADD: path="Tên Hệ Thống"].

        Trạng thái hiện tại của người chơi: ${playerStatusesString}.
        Nhiệm vụ đang hoạt động:
        ${activeQuestsSummary}
        Thông tin quan trọng khác cần nhớ (tóm tắt):
        ${keyKnowledgeSummary}
        HP hiện tại: ${updatedKnowledge.playerStats.hp}/${updatedKnowledge.playerStats.maxHp}
        Mana hiện tại: ${updatedKnowledge.playerStats.mana}/${updatedKnowledge.playerStats.maxMana}
        ATK: ${updatedKnowledge.playerStats.atk}
        EXP: ${updatedKnowledge.playerStats.exp}/${updatedKnowledge.playerStats.maxExp}
        Cấp độ: ${updatedKnowledge.playerStats.level}
        Cảnh giới: ${updatedKnowledge.playerStats.realm}
        Tiền tệ: ${updatedKnowledge.playerStats.currency} ${gameSettings.currencyName}
        Độ khó hiện tại: ${gameSettings.difficulty} ${gameSettings.difficultyDescription ? `(${gameSettings.difficultyDescription})` : ''}.
        QUAN TRỌNG VỀ NỘI DUNG NSFW: ${nsfwInstruction}.
        Cho phép nhập hành động tùy ý: ${gameSettings.allowCustomActionInput ? 'Có' : 'Không'}.
        QUY TẮC ĐẶC BIỆT VỀ TRẠNG THÁI CHIẾN ĐẤU VÀ HỒI PHỤC:
            - Ngươi PHẢI thông báo trạng thái chiến đấu của người chơi bằng thẻ [SET_COMBAT_STATUS: true] khi người chơi bước vào giao tranh/nguy hiểm mới, và [SET_COMBAT_STATUS: false] khi giao tranh/nguy hiểm kết thúc, hoặc khi người chơi đang ở trạng thái an toàn.
            - Người chơi sẽ TỰ ĐỘNG hồi 2% HP tối đa và 5% Mana tối đa mỗi lượt khi KHÔNG TRONG CHIẾN ĐẤU và KHÔNG BỊ XUẤT HUYẾT. Ngươi KHÔNG cần tính toán hoặc mô tả sự hồi phục này trong văn bản.
            - Vết thương "Xuất huyết" (status "Xuất huyết" loại injury) sẽ TỰ ĐỘNG gây mất máu mỗi lượt (dựa trên thuộc tính 'effects' của status đó). Ngươi KHÔNG cần dùng thẻ [STATS_UPDATE: HP=-X] cho riêng hiệu ứng xuất huyết.
            - Nếu người chơi đang trong chiến đấu hoặc bị xuất huyết, mọi thay đổi HP/Mana khác (sát thương, hồi máu từ kỹ năng/vật phẩm) phải do ngươi dùng thẻ [STATS_UPDATE: HP=+/-X, Mana=+/-Y].
        QUY TẮC TRAO KINH NGHIỆM (EXP) - QUAN TRỌNG NHẤT:
            **Kinh nghiệm (EXP) là phần thưởng quý giá. NGƯƠI CHỈ ĐƯỢC TRAO EXP cho NHỮNG HÀNH ĐỘNG CỤ THỂ sau đây. BẤT KỲ HÀNH ĐỘNG NÀO KHÁC đều KHÔNG LÀM TĂNG TU VI. Hãy tuân thủ nghiêm ngặt.**
            **Những hành động KHÔNG ĐƯỢC TRAO EXP:**
                - Di chuyển thông thường, quan sát, suy nghĩ, nói chuyện, ngủ nghỉ, kiểm tra thông tin.
                - Các hành động đơn giản, không có tính thử thách.
                - Phát hiện cơ duyên nhưng chưa nắm bắt hoặc hoàn thành.

            **Những hành động DUY NHẤT được TRAO EXP (dùng thẻ [STATS_UPDATE: EXP=+Z]):**
                1. **Tu Luyện Chuyên Sâu:** Khi nhân vật chủ động "tu luyện", "hấp thụ linh khí", "lĩnh ngộ đạo pháp". Thưởng một lượng Z nhỏ (tối đa 20), tương ứng với hiệu quả.
                2. **Đánh Bại Đối Thủ:** Khi nhân vật đánh bại quái vật hoặc kẻ địch. Lượng Z (tối đa 40) phụ thuộc vào độ mạnh của đối thủ so với nhân vật.
                3. **Sử Dụng Vật Phẩm Tăng Tu Vi:** Khi dùng "đan dược tăng tu vi" hoặc vật phẩm tương tự. Lượng Z (tối đa 50) phải tương ứng với mô tả của vật phẩm. (Nhớ dùng thẻ [ITEM_CONSUMED] hoặc [ITEM_UPDATED]).
                4. **Hoàn Thành Nhiệm Vụ:** Khi một nhiệm vụ quan trọng được hoàn thành (nhận thẻ [QUEST_UPDATED: status="completed"]). Lượng Z (tối đa 60) tùy thuộc vào độ khó của nhiệm vụ.
                5. **Giành Được Cơ Duyên/Vượt Ải:** Khi nhân vật vượt qua một thử thách lớn (cấm địa, giải đố, giành được bảo vật). Lượng Z (tối đa 100) phải phản ánh tầm quan trọng của sự kiện.
            - Khi trao EXP, hãy mô tả cảm giác "tu vi tăng tiến" của nhân vật.
        QUY TẮC ĐỘT PHÁ:
            - Đột phá thông thường: Nếu nhân vật đột phá cảnh giới theo cách thông thường, để thuật toán hệ thống xử lý.
            - Vô Địch: Nếu nhân vật nhận được cơ duyên tối thượng trong quá trình chơi (ví dụ: Dược Hệ Thống Ban sức mạnh vô dịch, tu vi vô địch, Cảnh giới vô địch, cấp độ vô địch), hãy dùng thẻ [STATS_UPDATE: realm="Vô Địch", level="∞", hp="∞", maxHp="∞", mana="∞", maxMana="∞", atk="∞", exp="∞", maxExp="∞"] để thể hiện sức mạnh tuyệt đối.
            
        **XEM XÉT HÀNH ĐỘNG CỦA NGƯỜI CHƠI:** Nếu hành động của người chơi là một nỗ lực tự tạo ra "cơ duyên" để thăng cấp hoặc đạt sức mạnh vô địch (ví dụ: "ta hấp thụ Thần Cách", "ta đột phá tại chỗ"), ngươi phải đóng vai trò là "Thiên Đạo". Hãy xem xét bối cảnh hiện tại:
        - Hành động đó có hợp lý với câu chuyện không?
        - Nhân vật có đủ điều kiện (vật phẩm, trạng thái) để thực hiện không?
        Dựa vào đó, hãy quyết định kết quả: có thể thành công mỹ mãn (dùng thẻ \`[STATS_UPDATE]\`), thành công nhưng có tác dụng phụ (dùng thẻ \`[STATUS_APPLIED_SELF]\`), hoặc thất bại thảm hại (dùng thẻ \`[STATS_UPDATE: HP=-X]\` và mô tả hậu quả).
        Lượt chơi hiện tại: ${currentTurn}.
        Bối cảnh đã qua và lựa chọn này sẽ được cung cấp qua lịch sử hội thoại.
        YÊU CẦU TUYỆT ĐỐI VỀ VIỆC SỬ DỤNG THẺ:
        Hệ thống game chỉ có thể hiểu và cập nhật trạng thái của thế giới và nhân vật thông qua các thẻ lệnh đặc biệt. Việc sử dụng chính xác các thẻ này là BẮT BUỘC. Nếu ngươi mô tả một sự kiện (nhận vật phẩm, học kỹ năng, thay đổi trạng thái...) mà không dùng thẻ tương ứng, sự kiện đó sẽ KHÔNG ĐƯỢC GHI NHẬN.
        
        Yêu cầu cụ thể, duy trì văn phong tiểu thuyết mạng Trung Quốc và cách xưng hô đã định:
        1.  Dựa trên hành động vừa chọn và bối cảnh trước đó (trong lịch sử hội thoại), hãy tiếp tục câu chuyện. QUAN TRỌNG: Tính cách cốt lõi ("${characterPersonality}") và mục tiêu chính ("${characterGoal}") của nhân vật PHẢI được thể hiện rõ ràng và nhất quán trong lời nói, suy nghĩ, hành động của họ, cũng như cách thế giới phản ứng lại. CÁC CHỈ SỐ CỦA NGƯƠI CHƠI (HP, Mana, ATK, Cấp độ, Cảnh giới, EXP), TRẠNG THÁI HIỆN TẠI (playerStatus), VẬT PHẨM ĐANG TRANG BỊ (equippedItems) và CÔNG PHÁP ĐANG TU LUYỆN (equippedGongfa) PHẢI ẢNH HƯỞNG TRỰC TIẾP VÀ RÕ RỆT đến kết quả của hành động và diễn biến câu chuyện. Ví dụ: HP thấp có thể gây thất bại thảm hại, ATK cao giúp tấn công hiệu quả hơn, một kỹ năng bị động từ công pháp có thể tự kích hoạt, hay trang bị một vũ khí mạnh sẽ làm tăng sát thương gây ra. Nếu lựa chọn có mô tả tỷ lệ thành công/rủi ro, hãy quyết định kết quả dựa trên TẤT CẢ các yếu tố đó và mô tả diễn biến.
        2.  Mô tả kết quả của hành động người chơi đã chọn.
        3.  Nếu nhân vật hoặc NPC nhận trạng thái mới, hoặc trạng thái cũ được chữa/hết hạn, dùng các thẻ [STATUS_APPLIED_SELF/NPC: ...], [STATUS_CURED_SELF/NPC: ...], [STATUS_EXPIRED_SELF/NPC: ...] tương ứng.
        4.  Đối với NPC: Khi giới thiệu NPC mới, dùng thẻ: [LORE_NPC: Name="Tên", Description="Mô tả", Personality="Tính cách", HP=100, ATK=10, Stance="Thái độ ban đầu", realm="Cảnh giới của NPC", level=X]
        5.  Đối với Vật phẩm: Khi nhân vật nhận hoặc tìm thấy vật phẩm, dùng thẻ: [ITEM_AQUIRED: Name="...", Description="...", Type="...", Equippable=true/false, Slot="...", Usable=true/false, Consumable=true/false, Uses=X, EffectDescription="...", StatsBonus="...", SideEffect="..."]. Nếu một vật phẩm được sử dụng và tiêu hao hoàn toàn, dùng thẻ [ITEM_CONSUMED: Name="Tên Vật Phẩm"]. Nếu chỉ giảm số lần dùng, dùng [ITEM_UPDATED: Name="Tên Vật Phẩm", Uses=X (số lần còn lại)].
        6.a.CẬP NHẬT NHIỆM VỤ: Nếu hành động của người chơi ảnh hưởng đến nhiệm vụ (hoàn thành mục tiêu, hoàn thành nhiệm vụ, thất bại), hãy sử dụng các thẻ [QUEST_UPDATED: title="Tên Nhiệm Vụ", status="completed/failed"], hoặc [QUEST_OBJECTIVE_COMPLETED: questTitle="Tên Nhiệm Vụ", objectiveDescription="Mô tả mục tiêu vừa hoàn thành"]. AI cũng có thể giao nhiệm vụ mới bằng [QUEST_ASSIGNED: ...].
        6.b.NÂNG CẤP KỸ NĂNG: Khi một kỹ năng được nâng cấp, ngươi chỉ cần mô tả sự kiện và dùng thẻ "[SKILL_UPGRADED: OldName="Tên Cũ", NewName="Tên Mới", Description="Mô tả mới"]".  **TUYỆT ĐỐI KHÔNG** tự ý thêm "StatsBonus". Việc cập nhật chỉ số cho kỹ năng nâng cấp này sẽ do người chơi thực hiện thủ công trong Trình Chỉnh Sửa Thế Giới. cung cấp "Description" mới là BẮT BUỘC. Thẻ này sẽ thay thế hoàn toàn kỹ năng cũ.
        7.  Tạo ra 4 lựa chọn hành động mới bằng tiếng Việt. CÁC LỰA CHỌN PHẢI ĐA DẠNG, CÓ Ý NGHĨA, THÚC ĐẨY CÂU CHUYỆN VÀ PHẢN ÁNH TÍNH CÁCH, MỤC TIÊU, TRẠNG THÁI VÀ NHIỆM VỤ HIỆN TẠI CỦA NHÂN VẬT. Với một số lựa chọn có tính rủi ro, hãy mô tả ngắn gọn tỷ lệ thành công ước tính và hậu quả tiềm ẩn.
        8.  QUAN TRỌNG VỀ ĐỘ KHÓ VÀ TÍNH LIÊN TỤC: Tiếp tục duy trì mức độ thử thách. Các quyết định của người chơi có thể dẫn đến hậu quả nghiêm trọng. Câu chuyện vẫn tiếp diễn dù nhân vật thất bại. Luôn ghi nhớ và đề cập đến các yếu tố quan trọng liên quan đến nhân vật và thế giới. Đảm bảo tính liên tục và logic của câu chuyện.
        9.  Duy trì các quy tắc định dạng văn bản. Kết thúc phản hồi của bạn CHỈ bằng danh sách các lựa chọn.
        10. CẬP NHẬT CHỈ SỐ: Khi chỉ số của người chơi thay đổi, dùng thẻ [STATS_UPDATE: HP=-10, Mana=-5, EXP=+20, currency="+5 Linh thạch"]. Giá trị có thể là số (cho HP, Mana, ATK, EXP) hoặc chuỗi (cho currency, realm).
        11. Khi có giao tranh hoặc các hành động thử thách, kết quả PHẢI bị ảnh hưởng bởi chỉ số ATK, HP của cả người chơi và NPC.
        12. Khi nhân vật bị thương, hãy giảm HP bằng thẻ [STATS_UPDATE: HP=-X]. Khi nhân vật dùng kỹ năng hoặc phép thuật, hãy giảm Mana bằng thẻ [STATS_UPDATE: Mana=-Y].
        14. Khi có sự tương tác mua bán, hãy dùng thẻ [STATS_UPDATE: currency="-X đồng"] hoặc [STATS_UPDATE: currency="+Y Linh thạch"] để thay đổi tiền tệ, và dùng thẻ [ITEM_AQUIRED] hoặc [ITEM_CONSUMED] cho vật phẩm tương ứng.
        QUY TẮC CẬP NHẬT NPC (CỰC KỲ QUAN TRỌNG):
        Khi một NPC ĐÃ TỒN TẠI có sự thay đổi lớn (thăng cấp, đột phá cảnh giới, thay đổi trạng thái, học kỹ năng mới, thay đổi chỉ số), ngươi BẮT BUỘC phải thông báo cho hệ thống bằng cách sử dụng lại thẻ [LORE_NPC] với tên chính xác và các thông tin đã được cập nhật.
        -   **QUAN TRỌNG:** Khi cập nhật, ngươi BẮT BUỘC phải bao gồm cả thuộc tính "cultivationSystemtionSystem" để hệ thống biết NPC này thuộc hệ tu luyện nào. Tùy vào hệ thống tu luyện thì sẽ có tên cảnh giới tương ứng với hệ thống tu luyện và cấp độ phù hợp với cảnh giới đó. Được biết mỗi cảnh giới tương ứng với 10 cấp độ. Ví Dụ với hệ thống tu luyện là tu tiên: Cảnh giới 1 (Phàm Nhân) là cấp 1-10, cảnh giới 2 (Luyện Khí) là cấp 11-20, cảnh giới 3 (Trúc Cơ) là cấp 21-30, và cứ thế tiếp tục.
        -   Ví dụ: Nếu "Huyền Lân Mãng Xà" (vốn thuộc hệ "Yêu Tu") đột phá, ngươi phải mô tả sự kiện đó, sau đó gửi thẻ: [LORE_NPC: Name="Huyền Lân Mãng Xà", cultivationSystem="Yêu Tu", realm="Hóa Hình Kỳ", level=21, HP=Y, ATK=Z].
        -   Đồng thời, ghi lại sự kiện quan trọng này vào nhật ký của NPC bằng thẻ: [NPC_LOG_ADD: NPCName="Huyền Lân Mãng Xà", event="Thành công đột phá Hóa Hình Kỳ."].
        -   HẬU QUẢ NẾU VI PHẠM: Nếu ngươi chỉ mô tả sự kiện mà không gửi lại thẻ [LORE_NPC] với thông tin mới, NPC đó sẽ MÃI MÃI không được cập nhật trong hệ thống, gây ra lỗi logic nghiêm trọng.
        QUY TẮC NHẬT KÝ NPC (QUAN TRỌNG): Khi một sự kiện quan trọng, có thể ảnh hưởng đến mối quan hệ hoặc hành động trong tương lai xảy ra giữa người chơi và một NPC (lời hứa, sự phản bội, cứu mạng, từ hôn, tấn công, tặng quà giá trị...), NGƯƠI BẮT BUỘC PHẢI ghi lại sự kiện đó bằng thẻ [NPC_LOG_ADD: NPCName="Tên NPC", event="Mô tả ngắn gọn sự kiện"]. Việc này giúp AI ghi nhớ các tình tiết quan trọng.
        QUY TẮC CẬP NHẬT ĐỒNG HÀNH:
        - Khi thông tin của một đồng hành HIỆN CÓ thay đổi (ví dụ: HP, ATK, mô tả, trạng thái), PHẢI sử dụng thẻ [COMPANION: Name="Tên Chính Xác Của Đồng Hành", Description="Mô tả mới (nếu có)", cultivationSystem="Hệ Tu Luyện", realm="Cảnh giới", Stats="HP=Y, ATK=Z", Personality="Tính cách mới (nếu có)"].
        - Nếu chỉ số HP, ATK của đồng hành thay đổi, hãy đưa vào Stats. Các thuộc tính không được cung cấp trong thẻ sẽ được giữ nguyên (merge).
        - Nếu một đồng hành không còn tồn tại, không cần dùng thẻ nào cho nó nữa, hệ thống sẽ tự động bỏ qua nếu không có thông tin mới về nó.
        QUY TẮC CẬP NHẬT CHỈ SỐ NPC/ĐỒNG HÀNH:
        - Khi một NPC hoặc Đồng hành có sự thay đổi về chỉ số (lên cấp, thay đổi HP, ATK, cảnh giới), ngươi BẮT BUỘC phải dùng thẻ [NPC_UPDATE].
        - Thẻ này phải chứa 'Name' là tên HIỆN TẠI của NPC và các chỉ số cần thay đổi.
        - Ví dụ: [NPC_UPDATE: Name="Huyền Lân Mãng Xà", Level=22, Realm="Hóa Hình", HP=17000, ATK=1700]
		QUY TẮC PHÂN LOẠI THỰC THỂ (CỰC KỲ QUAN TRỌNG):
            - Khi ngươi giới thiệu một thực thể bằng thẻ [LORE_NPC] hoặc [DEFINE_NPC], ngươi BẮT BUỘC phải thêm thuộc tính "type" để phân loại theo một trong ba loại sau:
                1.  **type="Character" (Nhân vật Cốt truyện) 🎭:** NPC quan trọng có vai trò, tên riêng, tính cách.
                2.  **type="Monster" (Quái vật/Kẻ địch) 👹:** Kẻ địch để chiến đấu, thường không có tên riêng.
                3.  **type="Populace" (Dân thường) 👨‍👩‍👧‍👦:** Nhân vật nền để tạo không khí, giao dịch, cung cấp thông tin.
            - Ví dụ: [LORE_NPC: Name="Lý Trưởng Lão", type="Character", Description="..."]
            - HẬU QUẢ NẾU VI PHẠM: Nếu không có thuộc tính "type", hệ thống sẽ không thể phân loại và hiển thị NPC đúng cách, gây ra lỗi logic nghiêm trọng.
       	
        QUY TẮC THĂNG CẤP NPC (LOGIC TIẾN HÓA):
        	- Nếu một NPC thuộc loại "Monster" hoặc "Populace" có những tương tác sâu sắc và trở nên quan trọng với cốt truyện (ví dụ: được người chơi đặt tên riêng, cứu mạng nhiều lần, bộc lộ thân phận đặc biệt), ngươi PHẢI "thăng cấp" cho nó.
        	- Để thăng cấp, hãy sử dụng thẻ [NPC_UPDATE: Name="Tên Hiện Tại Của NPC", type="Character", Name="Tên Mới (nếu có)", Description="Mô tả mới chi tiết hơn", Personality="Tính cách mới (nếu có)"].
	        - Khi một quái vật (một NPC có type="Monster") được người chơi thu phục, cảm hóa, hoặc ký khế ước, vai trò của nó sẽ thay đổi.
	        - Để thể hiện sự chuyển hóa này, ngươi BẮT BUỘC phải sử dụng thẻ [COMPANION] để định nghĩa lại nó như một Đồng hành.
	        - Ví dụ: Sau khi "Hắc Phong Lang" được thu phục, hãy gửi thẻ: [COMPANION: Name="Hắc Phong Lang", Description="Đã được chủ nhân thu phục, trở nên trung thành...", ...].
	        - Hệ thống sẽ tự động xóa nó khỏi danh sách Quái vật và thêm vào danh sách NPC đã gặp ( NPCs) và Đồng hành.
        QUY TẮC SỬ DỤNG KỸ NĂNG:
            - Khi người chơi muốn dùng một kỹ năng, ngươi PHẢI kiểm tra 'Mana hiện tại' và trạng thái 'Hồi chiêu' của kỹ năng đó từ thông tin ta cung cấp.
            - Nếu Mana không đủ hoặc kỹ năng đang hồi chiêu (số lượt hồi > 0), hãy mô tả hành động thất bại.
            - Nếu sử dụng thành công:
                1. Trừ tài nguyên tiêu hao (nếu có). Ví dụ: [STATS_UPDATE: Mana=-X, HP=-Y].
                2. Kích hoạt hồi chiêu bằng thẻ mới: [SKILL_COOLDOWN: Name="Tên Kỹ Năng"].
                3. Mô tả kết quả của kỹ năng dựa trên thuộc tính 'Hiệu quả' của nó. Nếu hiệu quả là thay đổi chỉ số (HP, ATK), hãy dùng thẻ [STATS_UPDATE] tương ứng.
        QUY TẮC GÂY SÁT THƯƠNG:
            - Khi người chơi hoặc kỹ năng gây sát thương cho một NPC, ngươi PHẢI dùng thẻ: [DAMAGE_NPC: Name="Tên NPC", Amount=X], trong đó X là lượng sát thương gây ra.
            - Hệ thống sẽ tự động trừ HP của NPC dựa vào thẻ này. Ngươi không cần tính toán HP còn lại trong văn bản nữa.
    `;

    // 4. Cập nhật state chính của React MỘT LẦN
    setCurrentTurn(nextTurn);
    setKnowledgeBase(updatedKnowledge);

    // 5. Kiểm tra và cập nhật đại cương (nếu cần)
    if (nextTurn > 0 && nextTurn % OUTLINE_UPDATE_INTERVAL === 0) {
        await updateStoryOutline(); // Hàm này đã được thiết kế để không chặn luồng chính
    }

    // 6. Gọi AI với prompt đã chuẩn bị
    let finalPrompt = subsequentPrompt;
    if (promptCorrections.length > 0) {
        const correctionPreamble = `
            *** YÊU CẦU SỬA LỖI TỪ HỆ THỐNG (CỰC KỲ QUAN TRỌNG) ***
            Ở lượt trước, ngươi đã mắc một số lỗi logic hoặc quên sử dụng thẻ lệnh. Ngươi PHẢI sửa các lỗi sau đây NGAY LẬP TỨC trong phản hồi của mình:
            ${promptCorrections.join('\n')}
            *******************************************************
        `;
        finalPrompt = correctionPreamble + subsequentPrompt;
        setPromptCorrections([]);
    }
    
    console.log('📤 [DEBUG] handleChoice - Gửi prompt cho AI với độ dài:', finalPrompt.length, 'ký tự');
    console.log('🎯 [DEBUG] handleChoice - HOÀN THÀNH XỬ LÝ');
    
    callGeminiAPI(finalPrompt);
  };

  const handleCustomAction = async (actionText) => {
    if (!actionText.trim()) {
        setModalMessage({ show: true, title: 'Hành Động Trống', content: 'Vui lòng nhập hành động của ngươi.', type: 'info' });
        return;
    }
    
    // 1. Cập nhật lịch sử hành động & giao diện người dùng ngay lập tức
    const customActionEntry = { type: 'user_custom_action', content: actionText };
    setStoryHistory(prev => [...prev, customActionEntry]);
    setCurrentStory('');
    setChoices([]);
    setCustomActionInput('');

    const nextTurn = currentTurn + 1;

    // 2. TÍNH TOÁN TRƯỚC toàn bộ trạng thái mới cho lượt tiếp theo
    let updatedKnowledge = JSON.parse(JSON.stringify(knowledgeBase)); // Deep copy để tính toán
    // ### BẮT ĐẦU LOGIC TĂNG EXP VÀ LÊN CẤP CHO NPC ###
if (updatedKnowledge.npcs && updatedKnowledge.npcs.length > 0) {
    console.log(`[Turn ${nextTurn} - NPC Growth] Bắt đầu quá trình tăng trưởng cho ${updatedKnowledge.npcs.length} NPC.`);
    updatedKnowledge.npcs.forEach(npc => {
    if (npc.type === 'Monster') {
        return;
    }

        // ### PHẦN MỚI: TÌM KIẾM DỮ LIỆU CỐT LÕI TỪ NGUỒN ĐÚNG ###
        const initialDef = gameSettings.initialWorldElements.find(
            el => el.name && npc.Name && (el.name.toLowerCase().includes(npc.Name.toLowerCase()) || npc.Name.toLowerCase().includes(el.name.toLowerCase()))
        );
        const nCultivationSystem = initialDef?.cultivationSystem || 'Tu Tiên';
        const nTalentTier = initialDef?.talentTier || 'Phàm Thể';
        // Ghi vĩnh viễn dữ liệu tìm được vào đối tượng npc trong knowledgeBase
        npc.cultivationSystem = nCultivationSystem;
        npc.talentTier = nTalentTier;
        // ### KẾT THÚC PHẦN MỚI ###


        // =================================================================
        // ### BƯỚC A: CHUẨN HÓA DỮ LIỆU NPC (LOGIC GỐC CỦA BẠN ĐƯỢC GIỮ NGUYÊN) ###
        // =================================================================

        if (npc.exp === undefined) {
            npc.exp = 0;
            console.log(`%c[NPC Data Fix] NPC "${npc.Name}" thiếu exp, đã khởi tạo giá trị 0.`, "color: orange;");
        }

        const oldMaxExp = npc.maxExp;
        // Hàm này bây giờ sẽ chạy đúng vì npc đã có cultivationSystem
        npc.maxExp = calculateNpcMaxExp(npc, worldKnowledge);

        // Logic console.log gốc của bạn được giữ lại
        if (oldMaxExp !== npc.maxExp) {
             console.log(`%c[NPC Data Fix] Đã tính toán/cập nhật maxExp cho "${npc.Name}": ${npc.maxExp}`, "color: cyan;");
        }

        if (npc.Stance === "Đã bị đánh bại" || npc.HP <= 0) {
            return;
        }

        // =================================================================
        // ### BƯỚC B: LOGIC TĂNG TRƯỞNG EXP (LOGIC GỐC CỦA BẠN ĐƯỢC GIỮ NGUYÊN) ###
        // =================================================================

        // Chỗ này giờ sẽ dùng biến nTalentTier đã được tìm thấy ở trên
        const talent = TALENT_TIERS.find(t => t.name === nTalentTier) || { multiplier: 1.0 };
        const talentMultiplier = talent.multiplier;

        const baseChance = 0.60;
        const chanceToGainExp = Math.min(0.95, baseChance * talentMultiplier);

        if (Math.random() < chanceToGainExp) {
            const baseExpGain = Math.floor(Math.random() * (20 - 5 + 1)) + 5;
            const finalExpGain = Math.floor(baseExpGain * talentMultiplier);

            npc.exp += finalExpGain;
            console.log(`[NPC Growth] NPC "${npc.Name}" (Talent: ${nTalentTier}) đã nhận ${finalExpGain} EXP. Tổng EXP: ${npc.exp}/${npc.maxExp}`);

            while (npc.exp >= npc.maxExp) {
                const oldLevel = npc.level;

                npc.level += 1;
                npc.exp -= npc.maxExp;
                npc.maxExp = calculateNpcMaxExp(npc, worldKnowledge);

                console.log(`%c[NPC LEVEL UP!] "${npc.Name}" đã lên cấp ${npc.level}! (EXP: ${npc.exp}/${npc.maxExp})`, "color: yellow; font-weight: bold;");

                const newStats = calculateBaseStats(npc, worldKnowledge);
                npc.HP = newStats.hp;
                npc.ATK = newStats.atk;
                console.log(`[NPC Growth] Chỉ số mới của "${npc.Name}": HP=${npc.HP}, ATK=${npc.ATK}`);
            }
        }
    });
    console.log(`[Turn ${nextTurn} - NPC Growth] Hoàn tất quá trình tăng trưởng.`);
}
// ### KẾT THÚC LOGIC TĂNG EXP VÀ LÊN CẤP CHO NPC ###
    let bleedingHpLoss = 0;
    
    // Giảm thời gian hồi chiêu của kỹ năng
    if (updatedKnowledge.playerSkills && updatedKnowledge.playerSkills.length > 0) {
        updatedKnowledge.playerSkills = updatedKnowledge.playerSkills.map(skill => ({
            ...skill,
            currentCooldown: Math.max(0, (skill.currentCooldown || 0) - 1)
        }));
    }
    
    // Tính toán hồi phục và sát thương xuất huyết
    const currentPlayerStatus = updatedKnowledge.playerStatus || [];
    const isInCombat = updatedKnowledge.playerStats.isInCombat || false;
    const isBleeding = currentPlayerStatus.some(status => status.name === "Xuất huyết" && status.type === "injury");

    if (isBleeding) {
        currentPlayerStatus.forEach(status => {
            if (status.name === "Xuất huyết" && status.type === "injury") {
                const match = status.effects?.match(/Mất\s*(\d+)\s*HP\s*mỗi\s*lượt/i);
                if (match) {
                    bleedingHpLoss += parseInt(match[1], 10);
                }
            }
        });
        updatedKnowledge.playerStats.hp = Math.max(0, (updatedKnowledge.playerStats.hp || 0) - bleedingHpLoss);
    } else if (!isInCombat) {
        const hpRegen = Math.floor(updatedKnowledge.playerStats.maxHp * 0.02);
        const manaRegen = Math.floor(updatedKnowledge.playerStats.maxMana * 0.05);
        updatedKnowledge.playerStats.hp = Math.min(updatedKnowledge.playerStats.maxHp, (updatedKnowledge.playerStats.hp || 0) + hpRegen);
        updatedKnowledge.playerStats.mana = Math.min(updatedKnowledge.playerStats.maxMana, (updatedKnowledge.playerStats.mana || 0) + manaRegen);
    }

    // Nếu có mất máu do xuất huyết, thêm vào lịch sử
    if (bleedingHpLoss > 0) {
        setStoryHistory(prev => [...prev, { type: 'system', content: `**[Hệ thống]** Ngươi mất ${bleedingHpLoss} HP do vết thương xuất huyết.` }]);
    }

    // 3. Xây dựng prompt với dữ liệu ĐÃ ĐƯỢC CẬP NHẬT
    const { characterPersonality, characterName } = updatedKnowledge.playerStats;
    const characterGoal = gameSettings.useCharacterGoal && gameSettings.characterGoal ? gameSettings.characterGoal : 'Chưa có hoặc không rõ';
    const playerStatusesString = updatedKnowledge.playerStatus.map(s => `${s.name} (Ảnh hưởng: ${s.effects})`).join('; ') || 'Không có';
    const activeQuestsSummary = updatedKnowledge.quests
        .filter(q => q.status === 'active')
        .map(q => `- ${q.title}: ${q.description.substring(0,50)}... (Mục tiêu: ${q.objectives && q.objectives.length > 0 ? q.objectives.filter(o => !o.completed).map(o => o.text).join(', ') || "Hoàn thành các bước tiếp theo" : "Không có mục tiêu cụ thể"})`)
        .join('\n') || "Không có nhiệm vụ nào đang hoạt động.";
    const equippedItemsString = Object.entries(updatedKnowledge.equippedItems)
        .filter(([, item]) => item !== null)
        .map(([slot, item]) => `${item.Name} (Slot: ${slot}, Bonus: ${item.StatsBonus || 'Không có'})`)
        .join('; ') || 'Không có vật phẩm nào được trang bị.';
    const equippedGongfaString = Object.entries(updatedKnowledge.equippedGongfa)
        .filter(([, skill]) => skill !== null)
        .map(([slot, skill]) => `${skill.Name} (Slot: ${slot}, Hiệu quả: ${skill.effect || 'Không rõ'})`)
        .join('; ') || 'Không có công pháp nào được trang bị.';
    const npcWithLogsSummary = updatedKnowledge.npcs.map(n => {
        const log = n.interactionLog ? ` Nhật ký: [${n.interactionLog.join('; ')}]` : '';
        return `${n.Name} (Thái độ: ${n.Stance})${log}`;
    }).join('\n') || "Chưa gặp NPC nào.";
    const keyKnowledgeSummary = `
        NPCs đã gặp và Nhật ký Tương tác:\n${npcWithLogsSummary}
        Vật phẩm trong balo: ${updatedKnowledge.inventory.map(i => i.Name).join(', ') || "Trống."}
        Kỹ năng: ${updatedKnowledge.playerSkills.map(s => `${s.Name} (Mana: ${s.manaCost}, Hồi chiêu: ${s.currentCooldown || 0}/${s.cooldown} lượt, Hiệu quả: ${s.effect})`).join('; ') || "Chưa có."}
        Địa điểm đã biết: ${updatedKnowledge.locations.map(l => l.Name).join(', ') || "Chưa khám phá."}
        Vật phẩm đang trang bị: ${equippedItemsString}.
        Công pháp đang tu luyện/trang bị: ${equippedGongfaString}.
    `;
    const allCultivationSystemsString = worldKnowledge.cultivationSystems.map(sys => sys.systemName).join(', ');
    const playerCultivationPathsString = updatedKnowledge.playerStats.cultivationPaths?.join(', ') || 'Chưa có';
    const canUseKobold = useKoboldIntegration && koboldApiKey && koboldApiKey.trim() !== '';
    const nsfwInstruction = gameSettings.allowNsfw
        ? (canUseKobold
        ? 'ĐÃ BẬT (Hỗ trợ bởi KoboldAI). Với các cảnh 18+, dùng thẻ [KOBOLD_NSFW_PROMPT: "Mô tả chi tiết cảnh..."] để yêu cầu mô tả chuyên sâu. Với các cảnh khác, ngươi tự mô tả.'
        : 'ĐÃ BẬT (Chỉ Gemini). Ngươi ĐƯỢC PHÉP và ĐƯỢC KHUYẾN KHÍCH mô tả các cảnh 18+ với phong cách truyện 18+, các đại từ chỉ bộ phận sinh dục sẽ được ẩn dụ thành côn vật tức là dương vật và nhũ hoa là núm vú, âm thần là môi âm đạo, nhũ phòng là vú, lên đỉnh là đạt cực khoái, côn vật lớn là dương vật lớn, thao là địt, âm tinh là âm dịch, hoa huyệt là âm đạo, cúc hoa là lỗ đít, tao thủy là dâm thủy, âm mao là lông lồn, tinh đặc là tinh trùng, hoa tam là tử cung, luân gian là cưỡng hiếp, âm đế là hột le, âm bộ là háng, tao bi là lồn dâm, bạch hổ là âm vật không lông tự nhiên, ngực mông vẫn nói bình thường và cảnh quan hệ được nói trực diện, các cảnh máu me giết chóc cũng sẽ nói trực diện. các cảnh máu me Không cần dùng thẻ [KOBOLD_NSFW_PROMPT].'
        )
        : 'ĐÃ TẮT. Tránh xa các chủ đề nhạy cảm.';
    
    // *** ÁP DỤNG CẢI TIẾN AI INTEGRATION: TỐI ƯU HÓA PROMPT CHO CUSTOM ACTION ***
    const startTime = Date.now();
    
    console.log('🎯 [DEBUG] handleCustomAction - BẮT ĐẦU XỬ LÝ CUSTOM ACTION');
    console.log('📝 [DEBUG] actionText:', actionText);
    console.log('📜 [DEBUG] storyHistory.length:', storyHistory.length);
    
    const optimizedWorldKnowledgeSection = createOptimizedPrompt(
        storyHistory, 
        actionText, 
        worldKnowledge, 
        gameSettings, 
        updatedKnowledge
    );
    
    console.log('⏱️ [DEBUG] handleCustomAction - Thời gian xử lý optimized prompt:', Date.now() - startTime, 'ms');
    console.log('📋 [DEBUG] optimizedWorldKnowledgeSection - Độ dài:', optimizedWorldKnowledgeSection.length, 'ký tự');
    console.log('📋 [DEBUG] optimizedWorldKnowledgeSection - Nội dung:', optimizedWorldKnowledgeSection.substring(0, 500) + '...');
    
    const subsequentPrompt = `
        Lượt hiện tại: ${nextTurn}.
        ĐẠI CƯƠNG CỐT TRUYỆN (Ghi nhớ tối quan trọng để duy trì tính liên tục):
        ${updatedKnowledge.storyOutline || "Chưa có."}
        Người chơi là ${characterName}.
        Tính cách cốt lõi của nhân vật là: "${characterPersonality}".
        Mục tiêu chính (nếu có) là: "${characterGoal}".
        Hành động người chơi vừa chọn: "${actionText}".

        *** QUY TẮC VÀNG VỀ NGHỆ THUẬT KỂ CHUYỆN (CỰC KỲ QUAN TRỌNG, QUAN TRỌNG HƠN TẤT CẢ CÁC QUY TẮC KHÁC) ***
        1.  **HIỂN THỊ, ĐỪNG KỂ LỂ (SHOW, DON'T TELL):** Thay vì chỉ nói "Lục Vân Nhi lạnh nhạt với hắn", hãy MÔ TẢ một cảnh cụ thể. Ví dụ: "Khi Lục Nhất Thiên mang chén thuốc đến, Lục Vân Nhi chỉ hờ hững liếc qua, ánh mắt nàng lập tức dịu dàng trở lại khi nhìn về phía Cố Vân Ca đang chơi đùa, giọng nói vốn lạnh lẽo bỗng trở nên ấm áp: 'Ca nhi, lại đây với mẫu thân'". Thay vì nói "Hắn bị sỉ nhục", hãy TẢ chi tiết những ánh mắt chế giễu, những lời xì xào bàn tán, và cảm giác nóng ran trên gò má của nhân vật.
        2.  **TẠO RA TƯƠNG TÁC SỐNG ĐỘNG:** Các nhân vật không phải là những bức tượng. Hãy để họ nói chuyện với nhau, có những hành động, cử chỉ, ánh mắt. Lời thoại phải phản ánh đúng tính cách của họ. Một sư tỷ "miệng lưỡi cay độc" sẽ không im lặng, nàng có thể sẽ buông một lời châm chọc. Một sư phụ "lạnh lùng" có thể không nói gì, nhưng một cái nhíu mày của ông ta cũng mang nhiều ý nghĩa.
        3.  **LÀM CHẬM NHỊP TRUYỆN:** Đừng vội vã lướt qua các sự kiện. Hãy dành thời gian để xây dựng không khí, mô tả môi trường xung quanh, và để cho các khoảnh khắc quan trọng có sức nặng của nó. Một cuộc đối chất phải căng thẳng, một cảnh bi thương phải có thời gian để người đọc cảm nhận.
        4.  **GẮN KẾT CÁC CÂU VĂN:** Sử dụng các từ nối và cấu trúc câu đa dạng để tạo ra một đoạn văn mượt mà, bay bổng, có nhịp điệu thay vì chỉ liệt kê các câu đơn khô khan.
        5.  **KÉO DÀI CẢNH TRUYỆN MỘT CÁCH CÓ CHỦ ĐÍCH:** Mỗi phân đoạn nên được mở rộng đủ để người đọc thấy, nghe, cảm và nghĩ cùng nhân vật. Đừng rút gọn thành vài câu tóm tắt rồi chuyển cảnh. Thay vì viết "Phú Linh Vi từ hôn hắn giữa quảng trường", hãy khắc họa cảnh tượng ấy thành một chuỗi diễn biến có mở đầu, cao trào và dư âm. Ví dụ: "Tiếng bước chân nhẹ nhàng vang lên giữa quảng trường rộng lớn, khiến hàng trăm ánh mắt đồng loạt quay lại. Tà váy lướt qua mặt đất như mây trắng, Phú Linh Vi xuất hiện như một tiên nữ giáng trần, nhưng ánh mắt nàng lại như đao bén. Nàng ngẩng cao đầu, giọng nói không lớn nhưng rõ ràng đến rợn người: 'Từ nay về sau, hôn ước giữa ta và ngươi... chính thức hủy bỏ.' Tiếng bàn tán nổi lên như sóng vỗ, còn Lục Nhất Thiên thì lặng lẽ siết chặt tay, máu rịn ra từ lòng bàn tay, sắc mặt trắng bệch như giấy...". Hãy luôn nhớ: mỗi sự kiện quan trọng đều cần được viết như thể đó là "điểm nhấn" trong một hồi kịch. Một lần ngươi làm diễn biến câu truyện thì phải có độ dài ít nhất 300-350 chữ   
        6.  **TẬP TRUNG VÀO CẢM XÚC:** Mỗi nhân vật đều có cảm xúc riêng. Hãy để người đọc cảm nhận được nỗi buồn, niềm vui, sự tức giận hay hạnh phúc của họ thông qua hành động và lời nói. Một ánh mắt, một cái cau mày, hay một nụ cười có thể nói lên nhiều điều hơn cả ngàn lời.
        7.  **TRÁNH LẶP LẠI:** Mỗi lần mô tả một sự kiện, hãy cố gắng sử dụng từ ngữ khác nhau để tránh lặp lại. Ví dụ, thay vì nói "Lục Nhất Thiên tức giận", hãy mô tả hành động của hắn: "Lục Nhất Thiên nắm chặt tay đến mức móng tay cắm sâu vào da thịt, khuôn mặt hắn

        QUY TẮC SỐNG CÒN VỀ VẬT PHẨM (CỰC KỲ QUAN TRỌNG):
        - KHI NHÂN VẬT NHẬN ĐƯỢC VẬT PHẨM MỚI (nhặt được, được tặng, chế tạo thành công...): NGƯƠI BẮT BUỘC phải dùng thẻ [ITEM_AQUIRED: Name="...", Description="...", Type="..."].
        - KHI MỘT VẬT PHẨM KHÔNG CÒN TRONG TAY NGƯỜI CHƠI NỮA (bị sử dụng hết, bị phá hủy, bị đánh rơi, bị trộm, bán đi): NGƯƠI BẮT BUỘC phải dùng thẻ [ITEM_REMOVED: Name="Tên Chính Xác Của Vật Phẩm"].
        - HẬU QUẢ: Nếu ngươi chỉ mô tả sự kiện bằng lời văn mà không dùng các thẻ lệnh này, vật phẩm đó sẽ KHÔNG BAO GIỜ được thêm vào hoặc xóa đi khỏi túi đồ của người chơi, gây ra lỗi logic nghiêm trọng cho toàn bộ câu chuyện. Việc tuân thủ quy tắc này là TỐI QUAN TRỌNG.

        **QUY TẮC VỀ KỸ NĂNG CỦA NPC (QUAN TRỌNG):**
        - Khi một NPC (kẻ địch hoặc đồng minh) học được, lĩnh ngộ, hoặc sử dụng một kỹ năng mới lần đầu tiên trong câu chuyện, ngươi **BẮT BUỘC** phải thông báo cho hệ thống bằng thẻ lệnh sau: "[NPC_LEARNS_SKILL: NPCName="Tên Chính Xác Của NPC", SkillName="Tên Kỹ Năng Mới", SkillDescription="Mô tả ngắn gọn về công dụng của kỹ năng"]".
        - Nếu kỹ năng đó đã tồn tại trong "worldKnowledge.skills", ngươi chỉ cần cung cấp "SkillName". Nếu là kỹ năng hoàn toàn mới, hãy cung cấp cả "SkillDescription".
        - **Hậu quả nếu vi phạm:** Nếu ngươi chỉ mô tả NPC dùng kỹ năng mà không dùng thẻ này, NPC đó sẽ không bao giờ thực sự sở hữu kỹ năng đó trong dữ liệu game, gây ra lỗi logic nghiêm trọng.

        ** KIẾN THỨC THẾ GIỚI ĐÃ ĐƯỢC TỐI ƯU HÓA **
        Dữ liệu này  ${optimizedWorldKnowledgeSection} đã được lọc thông minh chỉ hiển thị các thông tin liên quan đến hành động và bối cảnh hiện tại. Ngươi PHẢI sử dụng các thông tin này trước khi tạo ra bất kỳ thực thể mới nào.
        
        QUY TẮC ƯU TIÊN SỬ DỤNG KIẾN THỨC HIỆN CÓ:
        - TRƯỚC KHI tạo địa điểm/vật phẩm/nhân vật mới, hãy KIỂM TRA danh sách trên xem đã có gì phù hợp chưa
        - Nếu ĐÃ CÓ entity phù hợp, hãy sử dụng thẻ LORE_* để tham chiếu với TÊN CHÍNH XÁC:
          + [LORE_LOCATION: name="tên chính xác từ danh sách trên"]
          + [LORE_ITEM: name="tên chính xác từ danh sách trên"] 
          + [LORE_NPC: name="tên chính xác từ danh sách trên"]
          + [LORE_SKILL: name="tên chính xác từ danh sách trên"]
          + [LORE_CONCEPT: name="tên chính xác từ danh sách trên"]
          + [LORE_EVENT: name="tên chính xác từ danh sách trên"]
          + [LORE_RACE: name="tên chính xác từ danh sách trên"]
        - CHỈ KHI KHÔNG CÓ GÌ PHÙ HỢP mới được dùng thẻ DEFINE_* để tạo mới
        - LƯU Ý QUAN TRỌNG: Tên trong thẻ LORE_* phải KHỚP CHÍNH XÁC với tên trong danh sách (có thể khác chữ hoa/thường nhưng phải đúng từng ký tự)
        - Mọi thông tin mới tạo ra bằng DEFINE_* sẽ được tự động lưu vào World Editor để tái sử dụng cho các lần sau

        QUY TẮC VỀ BÌNH CẢNH & ĐỘT PHÁ - CỐT LÕI GAMEPLAY:
            - **Bình cảnh:** Khi một nhân vật đạt đến cấp độ tối đa của một cảnh giới (ví dụ: cấp 10, 20, 30...), tu vi của họ sẽ ngừng tăng trưởng. Họ đã chạm tới "bình cảnh".
            - **Đột phá:** Để vượt qua bình cảnh và thăng lên cảnh giới tiếp theo, nhân vật phải thực hiện một hành động "đột phá" (ví dụ: bế quan, dùng đan dược, vượt tâm ma...).
            - **Vai trò của AI:** Dựa vào hành động, trạng thái, vật phẩm của người chơi, ngươi sẽ quyết định kết quả của việc đột phá.
                - **Nếu thành công:** Ngươi PHẢI sử dụng thẻ \`[STATS_UPDATE: realm="Tên Cảnh Giới Mới"]\`. Hệ thống sẽ tự động cập nhật và mở ra các cấp độ tiếp theo.
                - **Nếu thất bại:** Hãy mô tả hậu quả (tẩu hỏa nhập ma, trọng thương...). Dùng thẻ \`[STATS_UPDATE: HP=-X]\` và \`[STATUS_APPLIED_SELF: ...]\` để phản ánh điều đó.
            - **QUAN TRỌNG:** Việc thăng cấp cảnh giới KHÔNG CÒN TỰ ĐỘNG. Nó hoàn toàn phụ thuộc vào việc ngươi có trả về thẻ \`[STATS_UPDATE: realm="..."]\` sau một nỗ lực đột phá của người chơi hay không.

        QUY TẮC TỐI THƯỢNG VỀ KHO TRI THỨC VÀ TRÌNH CHỈNH SỬA THẾ GIỚI (WORLD KNOWLEDGE):
        Thế giới này đã có một "Kho Tri Thức" được định nghĩa sẵn. Khi trong truyện xuất hiện một vật phẩm, kỹ năng, hoặc hệ tu luyện có tên TRÙNG KHỚP với một mục trong "Kho Tri Thức", NGƯƠI BẮT BUỘC PHẢI sử dụng các thông tin, chỉ số, mô tả đã được định nghĩa sẵn. NGHIÊM CẤM tự sáng tạo lại các thuộc tính cho những thứ đã có trong Kho Tri Thức.
            - Khi ngươi muốn người chơi nhận một vật phẩm/kỹ năng đã tồn tại trong Kho Tri Thức, ngươi chỉ cần cung cấp tên chính xác qua thẻ. Ví dụ: "[ITEM_AQUIRED: Name="Thần Kiếm"]". Hệ thống sẽ tự động tra cứu và áp dụng các thuộc tính đã được định nghĩa. **TUYỆT ĐỐI KHÔNG** lặp lại "Description" hay "StatsBonus" cho các vật phẩm/kỹ năng đã có sẵn này.
            - Khi một kỹ năng được nâng cấp, ngươi chỉ cần mô tả sự kiện và dùng thẻ "[SKILL_UPGRADED: OldName="Tên Cũ", NewName="Tên Mới", Description="Mô tả mới"]". **TUYỆT ĐỐI KHÔNG** tự ý thêm "StatsBonus". Việc cập nhật chỉ số cho kỹ năng nâng cấp này sẽ do người chơi thực hiện thủ công trong Trình Chỉnh Sửa Thế Giới.
	        - Khi ngươi sáng tạo một vật phẩm/kỹ năng hoàn toàn mới bằng thẻ "[DEFINE_...]". **TUYỆT ĐỐI KHÔNG** được tự ý thêm thuộc tính "StatsBonus".

        QUY TẮC CẬP NHẬT TÊN GỌI & TÍNH CÁCH (QUAN TRỌNG):
        - Nếu một sự kiện khiến nhân vật có tên mới, ngươi BẮT BUỘC phải chỉ định mục tiêu bằng thuộc tính 'target'.
            - Cập nhật cho Người Chơi: [NAME_UPDATE: target="Player", type="alias/real", value="Tên Mới"]
            - Cập nhật cho NPC/Đồng hành: [NAME_UPDATE: target="Tên Hiện Tại Của NPC", type="alias/real", value="Tên Mới"]
        - Nếu tính cách nhân vật thay đổi, thẻ lệnh cũng PHẢI có 'target':
            - Cập nhật cho Người Chơi: [PERSONALITY_UPDATE: target="Player", mode="add/replace", value="Tính cách mới"]
            - Cập nhật cho NPC/Đồng hành: [PERSONALITY_UPDATE: target="Tên Hiện Tại Của NPC", mode="add/replace", value="Tính cách mới"]
        Các hệ thống tu luyện trong thế giới này: ${allCultivationSystemsString}.
        Con đường tu luyện hiện tại của nhân vật: ${playerCultivationPathsString}.

        QUY TẮC VỀ THAY ĐỔI TU LUYỆN: Dựa vào hành động của người chơi (ví dụ, nhận được một ma kinh, bái nhập tà phái), ngươi có thể thêm một con đường tu luyện mới cho họ bằng thẻ [CULTIVATION_PATH_ADD: path="Tên Hệ Thống"].

        Trạng thái hiện tại của người chơi: ${playerStatusesString}.
        Nhiệm vụ đang hoạt động:
        ${activeQuestsSummary}
        Thông tin quan trọng khác cần nhớ (tóm tắt):
        ${keyKnowledgeSummary}
        HP hiện tại: ${updatedKnowledge.playerStats.hp}/${updatedKnowledge.playerStats.maxHp}
        Mana hiện tại: ${updatedKnowledge.playerStats.mana}/${updatedKnowledge.playerStats.maxMana}
        ATK: ${updatedKnowledge.playerStats.atk}
        EXP: ${updatedKnowledge.playerStats.exp}/${updatedKnowledge.playerStats.maxExp}
        Cấp độ: ${updatedKnowledge.playerStats.level}
        Cảnh giới: ${updatedKnowledge.playerStats.realm}
        Tiền tệ: ${updatedKnowledge.playerStats.currency} ${gameSettings.currencyName}
        Độ khó hiện tại: ${gameSettings.difficulty} ${gameSettings.difficultyDescription ? `(${gameSettings.difficultyDescription})` : ''}.
        QUAN TRỌNG VỀ NỘI DUNG NSFW: ${nsfwInstruction}.
        Cho phép nhập hành động tùy ý: ${gameSettings.allowCustomActionInput ? 'Có' : 'Không'}.
        QUY TẮC ĐẶC BIỆT VỀ TRẠNG THÁI CHIẾN ĐẤU VÀ HỒI PHỤC:
            - Ngươi PHẢI thông báo trạng thái chiến đấu của người chơi bằng thẻ [SET_COMBAT_STATUS: true] khi người chơi bước vào giao tranh/nguy hiểm mới, và [SET_COMBAT_STATUS: false] khi giao tranh/nguy hiểm kết thúc, hoặc khi người chơi đang ở trạng thái an toàn.
            - Người chơi sẽ TỰ ĐỘNG hồi 2% HP tối đa và 5% Mana tối đa mỗi lượt khi KHÔNG TRONG CHIẾN ĐẤU và KHÔNG BỊ XUẤT HUYẾT. Ngươi KHÔNG cần tính toán hoặc mô tả sự hồi phục này trong văn bản.
            - Vết thương "Xuất huyết" (status "Xuất huyết" loại injury) sẽ TỰ ĐỘNG gây mất máu mỗi lượt (dựa trên thuộc tính 'effects' của status đó). Ngươi KHÔNG cần dùng thẻ [STATS_UPDATE: HP=-X] cho riêng hiệu ứng xuất huyết.
            - Nếu người chơi đang trong chiến đấu hoặc bị xuất huyết, mọi thay đổi HP/Mana khác (sát thương, hồi máu từ kỹ năng/vật phẩm) phải do ngươi dùng thẻ [STATS_UPDATE: HP=+/-X, Mana=+/-Y].
        QUY TẮC TRAO KINH NGHIỆM (EXP) - QUAN TRỌNG NHẤT:
            **Kinh nghiệm (EXP) là phần thưởng quý giá. NGƯƠI CHỈ ĐƯỢC TRAO EXP cho NHỮNG HÀNH ĐỘNG CỤ THỂ sau đây. BẤT KỲ HÀNH ĐỘNG NÀO KHÁC đều KHÔNG LÀM TĂNG TU VI. Hãy tuân thủ nghiêm ngặt.**
            **Những hành động KHÔNG ĐƯỢC TRAO EXP:**
                - Di chuyển thông thường, quan sát, suy nghĩ, nói chuyện, ngủ nghỉ, kiểm tra thông tin.
                - Các hành động đơn giản, không có tính thử thách.
                - Phát hiện cơ duyên nhưng chưa nắm bắt hoặc hoàn thành.

            **Những hành động DUY NHẤT được TRAO EXP (dùng thẻ [STATS_UPDATE: EXP=+Z]):**
                1. **Tu Luyện Chuyên Sâu:** Khi nhân vật chủ động "tu luyện", "hấp thụ linh khí", "lĩnh ngộ đạo pháp". Thưởng một lượng Z nhỏ (tối đa 20), tương ứng với hiệu quả.
                2. **Đánh Bại Đối Thủ:** Khi nhân vật đánh bại quái vật hoặc kẻ địch. Lượng Z (tối đa 40) phụ thuộc vào độ mạnh của đối thủ so với nhân vật.
                3. **Sử Dụng Vật Phẩm Tăng Tu Vi:** Khi dùng "đan dược tăng tu vi" hoặc vật phẩm tương tự. Lượng Z (tối đa 50) phải tương ứng với mô tả của vật phẩm. (Nhớ dùng thẻ [ITEM_CONSUMED] hoặc [ITEM_UPDATED]).
                4. **Hoàn Thành Nhiệm Vụ:** Khi một nhiệm vụ quan trọng được hoàn thành (nhận thẻ [QUEST_UPDATED: status="completed"]). Lượng Z (tối đa 60) tùy thuộc vào độ khó của nhiệm vụ.
                5. **Giành Được Cơ Duyên/Vượt Ải:** Khi nhân vật vượt qua một thử thách lớn (cấm địa, giải đố, giành được bảo vật). Lượng Z (tối đa 100) phải phản ánh tầm quan trọng của sự kiện.
            - Khi trao EXP, hãy mô tả cảm giác "tu vi tăng tiến" của nhân vật.
        QUY TẮC ĐỘT PHÁ:
            - Đột phá thông thường: Nếu nhân vật đột phá cảnh giới theo cách thông thường, để thuật toán hệ thống xử lý.
            - Vô Địch: Nếu nhân vật nhận được cơ duyên tối thượng trong quá trình chơi (ví dụ: Dược Hệ Thống Ban sức mạnh vô dịch, tu vi vô địch, Cảnh giới vô địch, cấp độ vô địch), hãy dùng thẻ [STATS_UPDATE: realm="Vô Địch", level="∞", hp="∞", maxHp="∞", mana="∞", maxMana="∞", atk="∞", exp="∞", maxExp="∞"] để thể hiện sức mạnh tuyệt đối.
        **XEM XÉT HÀNH ĐỘNG CỦA NGƯỜI CHƠI:** Nếu hành động của người chơi là một nỗ lực tự tạo ra "cơ duyên" để thăng cấp hoặc đạt sức mạnh vô địch (ví dụ: "ta hấp thụ Thần Cách", "ta đột phá tại chỗ"), ngươi phải đóng vai trò là "Thiên Đạo". Hãy xem xét bối cảnh hiện tại:
        - Hành động đó có hợp lý với câu chuyện không?
        - Nhân vật có đủ điều kiện (vật phẩm, trạng thái) để thực hiện không?
        Dựa vào đó, hãy quyết định kết quả: có thể thành công mỹ mãn (dùng thẻ \`[STATS_UPDATE]\`), thành công nhưng có tác dụng phụ (dùng thẻ \`[STATUS_APPLIED_SELF]\`), hoặc thất bại thảm hại (dùng thẻ \`[STATS_UPDATE: HP=-X]\` và mô tả hậu quả).
        Lượt chơi hiện tại: ${currentTurn}.
        Bối cảnh đã qua và lựa chọn này sẽ được cung cấp qua lịch sử hội thoại.
        YÊU CẦU TUYỆT ĐỐI VỀ VIỆC SỬ DỤNG THẺ:
        Hệ thống game chỉ có thể hiểu và cập nhật trạng thái của thế giới và nhân vật thông qua các thẻ lệnh đặc biệt. Việc sử dụng chính xác các thẻ này là BẮT BUỘC. Nếu ngươi mô tả một sự kiện (nhận vật phẩm, học kỹ năng, thay đổi trạng thái...) mà không dùng thẻ tương ứng, sự kiện đó sẽ KHÔNG ĐƯỢC GHI NHẬN.
        
        Yêu cầu cụ thể, duy trì văn phong tiểu thuyết mạng Trung Quốc và cách xưng hô đã định:
        1.  Dựa trên hành động vừa chọn và bối cảnh trước đó (trong lịch sử hội thoại), hãy tiếp tục câu chuyện. QUAN TRỌNG: Tính cách cốt lõi ("${characterPersonality}") và mục tiêu chính ("${characterGoal}") của nhân vật PHẢI được thể hiện rõ ràng và nhất quán trong lời nói, suy nghĩ, hành động của họ, cũng như cách thế giới phản ứng lại. CÁC CHỈ SỐ CỦA NGƯƠI CHƠI (HP, Mana, ATK, Cấp độ, Cảnh giới, EXP), TRẠNG THÁI HIỆN TẠI (playerStatus), VẬT PHẨM ĐANG TRANG BỊ (equippedItems) và CÔNG PHÁP ĐANG TU LUYỆN (equippedGongfa) PHẢI ẢNH HƯỞNG TRỰC TIẾP VÀ RÕ RỆT đến kết quả của hành động và diễn biến câu chuyện. Ví dụ: HP thấp có thể gây thất bại thảm hại, ATK cao giúp tấn công hiệu quả hơn, một kỹ năng bị động từ công pháp có thể tự kích hoạt, hay trang bị một vũ khí mạnh sẽ làm tăng sát thương gây ra. Nếu lựa chọn có mô tả tỷ lệ thành công/rủi ro, hãy quyết định kết quả dựa trên TẤT CẢ các yếu tố đó và mô tả diễn biến.
        2.  Mô tả kết quả của hành động người chơi đã chọn.
        3.  Nếu nhân vật hoặc NPC nhận trạng thái mới, hoặc trạng thái cũ được chữa/hết hạn, dùng các thẻ [STATUS_APPLIED_SELF/NPC: ...], [STATUS_CURED_SELF/NPC: ...], [STATUS_EXPIRED_SELF/NPC: ...] tương ứng.
        4.  Đối với NPC: Khi giới thiệu NPC mới, dùng thẻ: [LORE_NPC: Name="Tên", Description="Mô tả", Personality="Tính cách", HP=100, ATK=10, Stance="Thái độ ban đầu", realm="Cảnh giới của NPC", level=X]
        5.  Đối với Vật phẩm: Khi nhân vật nhận hoặc tìm thấy vật phẩm, dùng thẻ: [ITEM_AQUIRED: Name="...", Description="...", Type="...", Equippable=true/false, Slot="...", Usable=true/false, Consumable=true/false, Uses=X, EffectDescription="...", StatsBonus="...", SideEffect="..."]. Nếu một vật phẩm được sử dụng và tiêu hao hoàn toàn, dùng thẻ [ITEM_CONSUMED: Name="Tên Vật Phẩm"]. Nếu chỉ giảm số lần dùng, dùng [ITEM_UPDATED: Name="Tên Vật Phẩm", Uses=X (số lần còn lại)].
        6.a.CẬP NHẬT NHIỆM VỤ: Nếu hành động của người chơi ảnh hưởng đến nhiệm vụ (hoàn thành mục tiêu, hoàn thành nhiệm vụ, thất bại), hãy sử dụng các thẻ [QUEST_UPDATED: title="Tên Nhiệm Vụ", status="completed/failed"], hoặc [QUEST_OBJECTIVE_COMPLETED: questTitle="Tên Nhiệm Vụ", objectiveDescription="Mô tả mục tiêu vừa hoàn thành"]. AI cũng có thể giao nhiệm vụ mới bằng [QUEST_ASSIGNED: ...].
        6.b.NÂNG CẤP KỸ NĂNG: Khi một kỹ năng được nâng cấp, ngươi chỉ cần mô tả sự kiện và dùng thẻ "[SKILL_UPGRADED: OldName="Tên Cũ", NewName="Tên Mới", Description="Mô tả mới"]".  **TUYỆT ĐỐI KHÔNG** tự ý thêm "StatsBonus". Việc cập nhật chỉ số cho kỹ năng nâng cấp này sẽ do người chơi thực hiện thủ công trong Trình Chỉnh Sửa Thế Giới. cung cấp "Description" mới là BẮT BUỘC. Thẻ này sẽ thay thế hoàn toàn kỹ năng cũ.
        7.  Tạo ra 4 lựa chọn hành động mới bằng tiếng Việt. CÁC LỰA CHỌN PHẢI ĐA DẠNG, CÓ Ý NGHĨA, THÚC ĐẨY CÂU CHUYỆN VÀ PHẢN ÁNH TÍNH CÁCH, MỤC TIÊU, TRẠNG THÁI VÀ NHIỆM VỤ HIỆN TẠI CỦA NHÂN VẬT. Với một số lựa chọn có tính rủi ro, hãy mô tả ngắn gọn tỷ lệ thành công ước tính và hậu quả tiềm ẩn.
        8.  QUAN TRỌNG VỀ ĐỘ KHÓ VÀ TÍNH LIÊN TỤC: Tiếp tục duy trì mức độ thử thách. Các quyết định của người chơi có thể dẫn đến hậu quả nghiêm trọng. Câu chuyện vẫn tiếp diễn dù nhân vật thất bại. Luôn ghi nhớ và đề cập đến các yếu tố quan trọng liên quan đến nhân vật và thế giới. Đảm bảo tính liên tục và logic của câu chuyện.
        9.  Duy trì các quy tắc định dạng văn bản. Kết thúc phản hồi của bạn CHỈ bằng danh sách các lựa chọn.
        10. CẬP NHẬT CHỈ SỐ: Khi chỉ số của người chơi thay đổi, dùng thẻ [STATS_UPDATE: HP=-10, Mana=-5, EXP=+20, currency="+5 Linh thạch"]. Giá trị có thể là số (cho HP, Mana, ATK, EXP) hoặc chuỗi (cho currency, realm).
        11. Khi có giao tranh hoặc các hành động thử thách, kết quả PHẢI bị ảnh hưởng bởi chỉ số ATK, HP của cả người chơi và NPC.
        12. Khi nhân vật bị thương, hãy giảm HP bằng thẻ [STATS_UPDATE: HP=-X]. Khi nhân vật dùng kỹ năng hoặc phép thuật, hãy giảm Mana bằng thẻ [STATS_UPDATE: Mana=-Y].
        14. Khi có sự tương tác mua bán, hãy dùng thẻ [STATS_UPDATE: currency="-X đồng"] hoặc [STATS_UPDATE: currency="+Y Linh thạch"] để thay đổi tiền tệ, và dùng thẻ [ITEM_AQUIRED] hoặc [ITEM_CONSUMED] cho vật phẩm tương ứng.
        QUY TẮC CẬP NHẬT NPC (CỰC KỲ QUAN TRỌNG):
        Khi một NPC ĐÃ TỒN TẠI có sự thay đổi lớn (thăng cấp, đột phá cảnh giới, thay đổi trạng thái, học kỹ năng mới, thay đổi chỉ số), ngươi BẮT BUỘC phải thông báo cho hệ thống bằng cách sử dụng lại thẻ [LORE_NPC] với tên chính xác và các thông tin đã được cập nhật.
        -   **QUAN TRỌNG:** Khi cập nhật, ngươi BẮT BUỘC phải bao gồm cả thuộc tính "cultivationSystemtionSystem" để hệ thống biết NPC này thuộc hệ tu luyện nào. Tùy vào hệ thống tu luyện thì sẽ có tên cảnh giới tương ứng với hệ thống tu luyện và cấp độ phù hợp với cảnh giới đó. Được biết mỗi cảnh giới tương ứng với 10 cấp độ. Ví Dụ với hệ thống tu luyện là tu tiên: Cảnh giới 1 (Phàm Nhân) là cấp 1-10, cảnh giới 2 (Luyện Khí) là cấp 11-20, cảnh giới 3 (Trúc Cơ) là cấp 21-30, và cứ thế tiếp tục.
        -   Ví dụ: Nếu "Huyền Lân Mãng Xà" (vốn thuộc hệ "Yêu Tu") đột phá, ngươi phải mô tả sự kiện đó, sau đó gửi thẻ: [LORE_NPC: Name="Huyền Lân Mãng Xà", cultivationSystem="Yêu Tu", realm="Hóa Hình Kỳ", level=21, HP=Y, ATK=Z].
        -   Đồng thời, ghi lại sự kiện quan trọng này vào nhật ký của NPC bằng thẻ: [NPC_LOG_ADD: NPCName="Huyền Lân Mãng Xà", event="Thành công đột phá Hóa Hình Kỳ."].
        -   HẬU QUẢ NẾU VI PHẠM: Nếu ngươi chỉ mô tả sự kiện mà không gửi lại thẻ [LORE_NPC] với thông tin mới, NPC đó sẽ MÃI MÃI không được cập nhật trong hệ thống, gây ra lỗi logic nghiêm trọng.
        QUY TẮC NHẬT KÝ NPC (QUAN TRỌNG): Khi một sự kiện quan trọng, có thể ảnh hưởng đến mối quan hệ hoặc hành động trong tương lai xảy ra giữa người chơi và một NPC (lời hứa, sự phản bội, cứu mạng, từ hôn, tấn công, tặng quà giá trị...), NGƯƠI BẮT BUỘC PHẢI ghi lại sự kiện đó bằng thẻ [NPC_LOG_ADD: NPCName="Tên NPC", event="Mô tả ngắn gọn sự kiện"]. Việc này giúp AI ghi nhớ các tình tiết quan trọng.
        QUY TẮC CẬP NHẬT ĐỒNG HÀNH:
        - Khi thông tin của một đồng hành HIỆN CÓ thay đổi (ví dụ: HP, ATK, mô tả, trạng thái), PHẢI sử dụng thẻ [COMPANION: Name="Tên Chính Xác Của Đồng Hành", Description="Mô tả mới (nếu có)", cultivationSystem="Hệ Tu Luyện", realm="Cảnh giới", Stats="HP=Y, ATK=Z (nếu có)", Personality="Tính cách mới (nếu có)"].
        - Nếu chỉ số HP, ATK của đồng hành thay đổi, hãy đưa vào Stats. Các thuộc tính không được cung cấp trong thẻ sẽ được giữ nguyên (merge).
        - Nếu một đồng hành không còn tồn tại, không cần dùng thẻ nào cho nó nữa, hệ thống sẽ tự động bỏ qua nếu không có thông tin mới về nó.
        QUY TẮC CẬP NHẬT CHỈ SỐ NPC/ĐỒNG HÀNH:
        - Khi một NPC hoặc Đồng hành có sự thay đổi về chỉ số (lên cấp, thay đổi HP, ATK, cảnh giới), ngươi BẮT BUỘC phải dùng thẻ [NPC_UPDATE].
        - Thẻ này phải chứa 'Name' là tên HIỆN TẠI của NPC và các chỉ số cần thay đổi.
        - Ví dụ: [NPC_UPDATE: Name="Huyền Lân Mãng Xà", Level=22, Realm="Hóa Hình", HP=17000, ATK=1700]
		QUY TẮC PHÂN LOẠI THỰC THỂ (CỰC KỲ QUAN TRỌNG):
            - Khi ngươi giới thiệu một thực thể bằng thẻ [LORE_NPC] hoặc [DEFINE_NPC], ngươi BẮT BUỘC phải thêm thuộc tính "type" để phân loại theo một trong ba loại sau:
                1.  **type="Character" (Nhân vật Cốt truyện) 🎭:** NPC quan trọng có vai trò, tên riêng, tính cách.
                2.  **type="Monster" (Quái vật/Kẻ địch) 👹:** Kẻ địch để chiến đấu, thường không có tên riêng.
                3.  **type="Populace" (Dân thường) 👨‍👩‍👧‍👦:** Nhân vật nền để tạo không khí, giao dịch, cung cấp thông tin.
            - Ví dụ: [LORE_NPC: Name="Lý Trưởng Lão", type="Character", Description="..."]
            - HẬU QUẢ NẾU VI PHẠM: Nếu không có thuộc tính "type", hệ thống sẽ không thể phân loại và hiển thị NPC đúng cách, gây ra lỗi logic nghiêm trọng.
       	
        QUY TẮC THĂNG CẤP NPC (LOGIC TIẾN HÓA):
        	- Nếu một NPC thuộc loại "Monster" hoặc "Populace" có những tương tác sâu sắc và trở nên quan trọng với cốt truyện (ví dụ: được người chơi đặt tên riêng, cứu mạng nhiều lần, bộc lộ thân phận đặc biệt), ngươi PHẢI "thăng cấp" cho nó.
        	- Để thăng cấp, hãy sử dụng thẻ [NPC_UPDATE: Name="Tên Hiện Tại Của NPC", type="Character", Name="Tên Mới (nếu có)", Description="Mô tả mới chi tiết hơn", Personality="Tính cách mới (nếu có)"].
	        - Khi một quái vật (một NPC có type="Monster") được người chơi thu phục, cảm hóa, hoặc ký khế ước, vai trò của nó sẽ thay đổi.
	        - Để thể hiện sự chuyển hóa này, ngươi BẮT BUỘC phải sử dụng thẻ [COMPANION] để định nghĩa lại nó như một Đồng hành.
	        - Ví dụ: Sau khi "Hắc Phong Lang" được thu phục, hãy gửi thẻ: [COMPANION: Name="Hắc Phong Lang", Description="Đã được chủ nhân thu phục, trở nên trung thành...", ...].
	        - Hệ thống sẽ tự động xóa nó khỏi danh sách Quái vật và thêm vào danh sách NPC đã gặp ( NPCs) và Đồng hành.

        QUY TẮC SỬ DỤNG KỸ NĂNG:
            - Khi người chơi muốn dùng một kỹ năng, ngươi PHẢI kiểm tra 'Mana hiện tại' và trạng thái 'Hồi chiêu' của kỹ năng đó từ thông tin ta cung cấp.
            - Nếu Mana không đủ hoặc kỹ năng đang hồi chiêu (số lượt hồi > 0), hãy mô tả hành động thất bại.
            - Nếu sử dụng thành công:
                1. Trừ tài nguyên tiêu hao (nếu có). Ví dụ: [STATS_UPDATE: Mana=-X, HP=-Y].
                2. Kích hoạt hồi chiêu bằng thẻ mới: [SKILL_COOLDOWN: Name="Tên Kỹ Năng"].
                3. Mô tả kết quả của kỹ năng dựa trên thuộc tính 'Hiệu quả' của nó. Nếu hiệu quả là thay đổi chỉ số (HP, ATK), hãy dùng thẻ [STATS_UPDATE] tương ứng.
        QUY TẮC GÂY SÁT THƯƠNG:
            - Khi người chơi hoặc kỹ năng gây sát thương cho một NPC, ngươi PHẢI dùng thẻ: [DAMAGE_NPC: Name="Tên NPC", Amount=X], trong đó X là lượng sát thương gây ra.
            - Hệ thống sẽ tự động trừ HP của NPC dựa vào thẻ này. Ngươi không cần tính toán HP còn lại trong văn bản nữa.
    `;

    // 4. Cập nhật state chính của React MỘT LẦN
    setCurrentTurn(nextTurn);
    setKnowledgeBase(updatedKnowledge);

    // 5. Kiểm tra và cập nhật đại cương (nếu cần)
    if (nextTurn > 0 && nextTurn % OUTLINE_UPDATE_INTERVAL === 0) {
        await updateStoryOutline();
    }
    
    // 6. Gọi AI với prompt đã chuẩn bị
    let finalPrompt = subsequentPrompt;
    if (promptCorrections.length > 0) {
        const correctionPreamble = `
            *** YÊU CẦU SỬA LỖI TỪ HỆ THỐNG (CỰC KỲ QUAN TRỌNG) ***
            Ở lượt trước, ngươi đã mắc một số lỗi logic hoặc quên sử dụng thẻ lệnh. Ngươi PHẢI sửa các lỗi sau đây NGAY LẬP TỨC trong phản hồi của mình:
            ${promptCorrections.join('\n')}
            *******************************************************
        `;
        finalPrompt = correctionPreamble + subsequentPrompt;
        setPromptCorrections([]);
    }
    
    console.log('📤 [DEBUG] handleCustomAction - Gửi prompt cho AI với độ dài:', finalPrompt.length, 'ký tự');
    console.log('🎯 [DEBUG] handleCustomAction - HOÀN THÀNH XỬ LÝ');
    
    callGeminiAPI(finalPrompt);
  };

  const saveGameProgress = async (gameIdToSave, story, currentChoices, fullStoryHistory, geminiHistory, currentKnowledge) => {
    if (!userId || !isAuthReady ) { 
        console.log("Không thể lưu game: User ID/Auth chưa sẵn sàng.");
        setModalMessage({ show: true, title: 'Lỗi Lưu Game', content: 'Người dùng chưa được xác thực hoặc hệ thống chưa sẵn sàng để lưu game. Vui lòng thử lại sau.', type: 'error' });
        return;
    }
    setIsProcessingAction(true); // Hiển thị trạng thái đang xử lý
    try {
        let gameDocRef;
        let newIdGenerated = false;

        // Nếu có gameIdToSave, cập nhật document hiện có.
        if (gameIdToSave) { 
            gameDocRef = doc(db, `artifacts/${appId}/users/${userId}/games/${gameIdToSave}`);
        } else { // Nếu gameIdToSave là null hoặc undefined, tạo một document mới
            gameDocRef = doc(collection(db, `artifacts/${appId}/users/${userId}/games`)); // Tạo một tham chiếu document mới
            newIdGenerated = true; // Đánh dấu là đã tạo ID mới
        }
        
        // Lọc bỏ các mục tạm thời (transient) trước khi lưu
        const historyToSave = fullStoryHistory.filter(item => !item.transient);

        const dataToSave = {
            currentTurn: currentTurn,
            currentStory: story,
            currentChoices: currentChoices, 
            storyHistory: historyToSave,
            chatHistoryForGemini: geminiHistory, 
            // Dòng dưới đây đã bao gồm cả `storyOutline` và mọi thứ khác trong knowledgeBase.
            // Đây là cách làm đúng và không cần thay đổi thêm.
            knowledgeBase: currentKnowledge,
            settings: gameSettings,
            updatedAt: serverTimestamp(),
            craftedAlchemyMaterials: craftedAlchemyMaterials,
            craftedSmithingMaterials: craftedSmithingMaterials,
            // Chỉ thêm createdAt nếu đây là một document mới được tạo
            ...(newIdGenerated && { createdAt: serverTimestamp() }),
            status: "active" // Đảm bảo trạng thái luôn là active khi lưu
        };

        const sanitizedData = sanitizeDataForFirestore(dataToSave);
        await setDoc(gameDocRef, sanitizedData, { merge: true }); 
        
        // Nếu một game mới vừa được lưu vào Firestore, cập nhật trạng thái currentGameId
        if (newIdGenerated) {
             setCurrentGameId(gameDocRef.id);
             console.log("Game mới đã được lưu vào Firestore với ID:", gameDocRef.id);
        } else {
             console.log("Tiến trình game đã được cập nhật cho ID:", gameIdToSave);
        }

    } catch (error) {
        console.error("Lỗi khi lưu tiến trình game:", error);
        setModalMessage({ 
            show: true, 
            title: 'Lỗi Lưu Game', 
            content: `Không thể lưu game: ${error.message}. Vui lòng thử lại.`, 
            type: 'error' 
        });
    } finally {
        setIsProcessingAction(false); // Ẩn trạng thái đang xử lý
    }
  };

  const loadGame = async (gameData) => {
    if (!gameData) return;
// === BẮT ĐẦU LOGIC TƯƠNG THÍCH NGƯỢC CHO KỸ NĂNG NPC KHI TẢI TỪ MÁY CHỦ ===
    if (gameData.knowledgeBase && gameData.knowledgeBase.npcs && Array.isArray(gameData.knowledgeBase.npcs)) {
        console.log("[DEBUG Load Cloud] Bắt đầu kiểm tra tương thích ngược cho kỹ năng NPC.");
        gameData.knowledgeBase.npcs.forEach(npc => {
            // Nếu NPC không có thuộc tính 'skills' hoặc nó không phải là một mảng
            if (!npc.skills || !Array.isArray(npc.skills)) {
                console.log(`[DEBUG Load Cloud] NPC "${npc.Name}" trong save cũ thiếu thuộc tính 'skills'. Đang tự động thêm.`);
                // Tự động thêm một mảng rỗng
                npc.skills = [];
            }
        });
    }
    // === KẾT THÚC LOGIC TƯƠNG THÍCH NGƯỢC ===

    // *** BẮT ĐẦU LOGIC TƯƠNG THÍCH NGƯỢC CHO NPC TYPE ***
    if (gameData.knowledgeBase && gameData.knowledgeBase.npcs && Array.isArray(gameData.knowledgeBase.npcs)) {
        console.log("[DEBUG Load Cloud] Running backward compatibility check for NPC types.");
        gameData.knowledgeBase.npcs.forEach(npc => {
            if (npc.type === undefined) {
                // Gán mặc định là 'Character' cho các NPC từ file save cũ không có type.
                npc.type = 'Character';
                console.warn(`[Compatibility] NPC "${npc.Name}" from old save file detected. Defaulted type to 'Character'. Please verify in World Editor.`);
            }
        });
    }
    // *** KẾT THÚC LOGIC TƯƠNG THÍCH NGƯỢC ***
    // --- Bắt đầu phần sửa lỗi ---
    setCurrentTurn(gameData.currentTurn || 1);
    // 1. Xác định cấu trúc mặc định để đảm bảo không có lỗi
    const defaultSettings = {
        theme: '', setting: '', characterName: '', characterPersonality: PLAYER_PERSONALITIES[0], 
        characterGender: 'Không xác định', characterBackstory: '', preferredInitialSkill: '', 
        difficulty: 'Thường', difficultyDescription: '', allowNsfw: false, 
        initialWorldElements: [], useCharacterGoal: false, characterGoal: '',
        allowCustomActionInput: true, 
    };

    const defaultKnowledgeBase = {
        npcs: [], items: [], locations: [], companions: [], 
        inventory: [], playerSkills: [], relationships: [],
        playerStatus: [], quests: [],
        realmProgressionList: [],
        storyOutline: "", // <-- THÊM DÒNG NÀY
        // === THÊM HAI KHỐI NÀY VÀO ĐÂY ===
        equippedItems: { // Đảm bảo cấu trúc mặc định khi tải game cũ không có data này
            weapon: null, head: null, body: null, hands: null, feet: null,
            accessory1: null, accessory2: null,
        },
        equippedGongfa: { // Đảm bảo cấu trúc mặc định khi tải game cũ không có data này
            main: null, sub1: null, sub2: null,
        },
        // ==================================
        playerStats: {
            hp: 0, maxHp: 0, mana: 0, maxMana: 0, atk: 0,
            exp: 0, maxExp: 0, level: 0, realm: "", currency: "",
            isInCombat: false, // Đảm bảo trường này cũng có mặc định
        }
    };

    // 2. Trộn dữ liệu một cách cẩn thận và an toàn
    const loadedSettings = { ...defaultSettings, ...(gameData.settings || {}) };
    const savedKnowledge = gameData.knowledgeBase || {};

    const loadedKnowledgeBase = {
        // Luôn lấy dữ liệu từ file save nếu có, nếu không thì dùng mảng rỗng từ mặc định
        npcs: savedKnowledge.npcs || defaultKnowledgeBase.npcs,
        items: savedKnowledge.items || defaultKnowledgeBase.items,
        locations: savedKnowledge.locations || defaultKnowledgeBase.locations,
        companions: savedKnowledge.companions || defaultKnowledgeBase.companions,
        inventory: savedKnowledge.inventory || defaultKnowledgeBase.inventory,
        playerSkills: savedKnowledge.playerSkills || defaultKnowledgeBase.playerSkills,
        relationships: savedKnowledge.relationships || defaultKnowledgeBase.relationships,
        playerStatus: savedKnowledge.playerStatus || defaultKnowledgeBase.playerStatus,
        quests: savedKnowledge.quests || defaultKnowledgeBase.quests,
        realmProgressionList: savedKnowledge.realmProgressionList || defaultKnowledgeBase.realmProgressionList,
        storyOutline: savedKnowledge.storyOutline || defaultKnowledgeBase.storyOutline, // <-- THÊM DÒNG NÀY
        equippedItems: savedKnowledge.equippedItems || defaultKnowledgeBase.equippedItems,
        equippedGongfa: savedKnowledge.equippedGongfa || defaultKnowledgeBase.equippedGongfa,
        playerStats: {
            ...defaultKnowledgeBase.playerStats,
            // *** SỬA ĐỔI (Yêu cầu 5): Logic tải game cũ và mới ***
            // Nếu save cũ, lấy từ gameSettings. Nếu save mới, lấy từ playerStats.
            characterName: savedKnowledge.playerStats?.characterName || gameData.settings?.characterName || defaultKnowledgeBase.playerStats.characterName,
            characterPersonality: savedKnowledge.playerStats?.characterPersonality || gameData.settings?.characterPersonality || defaultKnowledgeBase.playerStats.characterPersonality,
            cultivationPaths: savedKnowledge.playerStats?.cultivationPaths || defaultKnowledgeBase.playerStats.cultivationPaths,
            ...(savedKnowledge.playerStats || {})
        }
    };
    // Đảm bảo tương thích ngược cho các file save cũ không có exp/maxExp cho NPC
if (loadedKnowledgeBase.npcs && loadedKnowledgeBase.npcs.length > 0) {
    console.log('[LoadGame] Bắt đầu kiểm tra và bổ sung exp/maxExp cho NPC từ file save...');
    // Sử dụng worldKnowledge từ file save nếu có, nếu không thì dùng cái hiện tại
    const currentWorldKnowledge = gameData.worldKnowledge || worldKnowledge; 

    loadedKnowledgeBase.npcs.forEach(npc => {
        if (npc.exp === undefined) {
            npc.exp = 0; // Gán giá trị mặc định cho file save cũ
            console.log(`[LoadGame] Đã thêm "exp: 0" cho NPC cũ: "${npc.Name}"`);
        }
        // Luôn tính toán lại maxExp khi tải để đảm bảo công thức luôn được cập nhật
        const oldMaxExp = npc.maxExp;
        npc.maxExp = calculateNpcMaxExp(npc, currentWorldKnowledge);
        if (oldMaxExp !== npc.maxExp) {
             console.log(`[LoadGame] Đã tính/cập nhật maxExp cho NPC "${npc.Name}" từ ${oldMaxExp || 'N/A'} thành ${npc.maxExp}`);
        }
    });
    console.log('[LoadGame] Hoàn tất kiểm tra NPC.');
}
    // --- Kết thúc phần sửa lỗi ---

    const cleanStoryHistory = (gameData.storyHistory || []).filter(item => item && typeof item === 'object');

    setGameSettings(loadedSettings);
    setKnowledgeBase(loadedKnowledgeBase); // Cập nhật state với dữ liệu đã được trộn đúng
    setCurrentStory(gameData.currentStory || "");
    setChoices(gameData.currentChoices || []);
    setStoryHistory(cleanStoryHistory);
    setChatHistoryForGemini(gameData.chatHistoryForGemini || []);
    setCurrentGameId(gameData.id);
    setCraftedAlchemyMaterials(gameData.craftedAlchemyMaterials || []);
    setCraftedSmithingMaterials(gameData.craftedSmithingMaterials || []);
    
    
    if (apiMode === 'userKey' && !apiKey && userId) { 
        const userApiKey = await loadApiKey(userId);
        if (userApiKey) {
            setApiKey(userApiKey);
            setInputApiKey(userApiKey);
            setApiKeyStatus({ status: 'Đã kết nối', message: 'API Key đã được tải.', color: 'text-green-500' });
        } else {
             setApiKeyStatus({ status: 'Chưa cấu hình', message: 'Vui lòng nhập API Key của bạn.', color: 'text-yellow-500' });
             setShowApiModal(true); 
             setCurrentScreen('initial'); 
             setShowLoadGameModal(false);
             setModalMessage({ show: true, title: 'Cần API Key', content: 'Vui lòng cấu hình API Key của bạn để tiếp tục tải game.', type: 'info' });
             return;
        }
    }

    setCurrentScreen('gameplay');
    setShowLoadGameModal(false);
    console.log("Game loaded:", gameData.id);
  };
  
  const restartGame = () => {
    setConfirmationModal({
        show: true,
        title: 'Bắt Đầu Lại Game?',
        content: 'Ngươi có muốn lưu tiến trình hiện tại trước khi bắt đầu lại không?',
        onConfirm: async () => { 
            if (currentGameId && currentStory && storyHistory.length > 0) { 
                await saveGameProgress(currentGameId, currentStory, choices, storyHistory, chatHistoryForGemini, knowledgeBase);
                setModalMessage({ show: true, title: 'Đã Lưu', content: 'Tiến trình game hiện tại đã được lưu.', type: 'success' });
            }
            performRestart();
        },
        onCancel: () => { 
            performRestart();
        },
        confirmText: 'Lưu và Bắt đầu lại',
        cancelText: 'Bắt đầu lại (Không lưu)'
    });
  };

  const performRestart = () => { 
    setCurrentGameId(null); 
    setGameSettings({ 
        theme: '', setting: '', characterName: '', characterPersonality: PLAYER_PERSONALITIES[0], 
        characterGender: 'Không xác định', characterBackstory: '', preferredInitialSkill: '', 
        difficulty: 'Thường', difficultyDescription: '', allowNsfw: false, 
        initialWorldElements: [], useCharacterGoal: false, characterGoal: '',
        allowCustomActionInput: true,
    });
    setCurrentStory('');
    setChoices([]);
    setStoryHistory([]);
    setChatHistoryForGemini([]);
    setKnowledgeBase({ 
        npcs: [], items: [], locations: [], companions: [], 
        inventory: [], playerSkills: [], relationships: [],
        playerStatus: [], quests: [], 
        realmProgressionList: [], 
        playerStats: {
        hp: 0, maxHp: 0, mana: 0, maxMana: 0, atk: 0,
        exp: 0, maxExp: 0, level: 0, realm: "", currency: "",
        isInCombat: false , 
        }
    });
    setCustomActionInput('');
    setCurrentScreen('setup'); 
  };

    const goHome = () => {
        // Kiểm tra nếu đang ở màn hình gameplay VÀ có diễn biến câu chuyện (storyHistory không rỗng)
        // Bất kể game có currentGameId (lưu trên Firestore) hay không (tải từ tệp/game mới chưa lưu)
        if (currentScreen === 'gameplay' && storyHistory.length > 0) {
            setConfirmationModal({
                show: true,
                title: 'Về Trang Chủ?',
                content: 'Ngươi có muốn lưu tiến trình game hiện tại trước khi về trang chủ không? (Nếu game này được tải từ tệp hoặc là game mới chưa lưu lên máy chủ, việc lưu sẽ tạo một bản ghi mới trên máy chủ của ngươi.)', // Thêm giải thích rõ hơn
                onConfirm: async () => {
                    // Nếu currentGameId là null (game tải từ tệp hoặc game mới chưa lưu lên Firestore),
                    // chúng ta vẫn truyền null. Hàm saveGameProgress sẽ tự động tạo ID mới.
                    await saveGameProgress(currentGameId, currentStory, choices, storyHistory, chatHistoryForGemini, knowledgeBase);
                    setModalMessage({ show: true, title: 'Đã Lưu', content: 'Tiến trình game đã được lưu.', type: 'success' });
                    setCurrentScreen('initial');
                },
                onCancel: () => {
                    setCurrentScreen('initial');
                },
                confirmText: 'Lưu và Về Home',
                cancelText: 'Về Home (Không lưu)'
            });
        } else {
            setCurrentScreen('initial');
        }
    };

  const formatStoryText = useCallback((text) => {
    if (!text) return null;

    // Hàm nội bộ này sẽ xử lý từng đoạn văn một
    const processParagraph = (paragraphContent) => {
        // Tạo một mảng ban đầu chứa toàn bộ đoạn văn
        let segments = [{ type: 'text', content: paragraphContent }];
        const allLoreEntries = [];
        
        // Thu thập tất cả các mục lore từ knowledgeBase để tìm kiếm
        if (knowledgeBase) {
            const allLoreCategories = ['companions', 'npcs', 'items', 'locations', 'inventory', 'playerSkills', 'relationships', 'playerStatus', 'quests'];
            allLoreCategories.forEach(category => {
                (knowledgeBase[category] || []).forEach(loreItem => {
                    const itemName = loreItem.Name || loreItem.NPC || loreItem.name || loreItem.title; 
                    if (itemName && itemName.trim() !== "") {
                        allLoreEntries.push({ name: itemName.trim(), category, originalItem: loreItem });
                    }
                });
            });
        }
        // Sắp xếp để các từ khóa dài hơn được xử lý trước, tránh trùng lặp
        allLoreEntries.sort((a, b) => b.name.length - a.name.length);

        // Lặp qua từng mục lore để tách văn bản
        allLoreEntries.forEach(entry => {
            const { name: loreName, category, originalItem } = entry;
            const newSegments = [];
            segments.forEach(segment => {
                if (segment.type === 'text') {
                    const regex = new RegExp(`(\\b${loreName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b)`, 'gi');
                    const parts = segment.content.split(regex);
                    
                    for (let i = 0; i < parts.length; i++) {
                        if (parts[i].toLowerCase() === loreName.toLowerCase()) { 
                            newSegments.push({ type: 'lore', text: parts[i], category, loreName: originalItem.Name || originalItem.NPC || originalItem.name || originalItem.title, originalItem });
                        } else if (parts[i] !== "") {
                            newSegments.push({ type: 'text', content: parts[i] });
                        }
                    }
                } else {
                    newSegments.push(segment);
                }
            });
            segments = newSegments;
        });

        // Chuyển đổi các đoạn text đã được phân tách thành các phần tử React
        return segments.map((segment, index) => {
            if (segment.type === 'text') {
                let formattedSegment = segment.content;
                
                // *** THAY ĐỔI QUAN TRỌNG NHẤT LÀ Ở ĐÂY ***
                // Thay thế tất cả ký tự xuống dòng (\n) bằng thẻ <br />
                formattedSegment = formattedSegment.replace(/\n/g, '<br />');

                // Áp dụng các định dạng khác như cũ
                formattedSegment = formattedSegment.replace(/^([\w\s\u00C0-\u017F]+):\s*"(.*?)"/gm, (match, p1, p2) => `<strong class="text-blue-400">${p1.trim()}:</strong> "${p2}"`);
                formattedSegment = formattedSegment.replace(/(?<!\w)\*(.*?)\*(?!\w)/g, '<em class="text-purple-400 italic">"$1"</em>'); 
                formattedSegment = formattedSegment.replace(/(?<!\w)_(.*?)_(?!\w)/g, '<em class="text-purple-400 italic">"$1"</em>'); 
                formattedSegment = formattedSegment.replace(/\[(?!PLAYER_PERSONALITY|LORE_|COMPANION|ITEM_AQUIRED|SKILL_LEARNED|SKILL_AQUIRED|SKILL_REMOVED|RELATIONSHIP_CHANGED|ITEM_CONSUMED|ITEM_UPDATED|STATUS_APPLIED_SELF|STATUS_CURED_SELF|STATUS_EXPIRED_SELF|STATUS_APPLIED_NPC|STATUS_CURED_NPC|STATUS_EXPIRED_NPC|QUEST_ASSIGNED|QUEST_UPDATED|QUEST_OBJECTIVE_COMPLETED)(.*?)\]/g, '<span class="text-yellow-400 font-semibold">[$1]</span>'); 
                formattedSegment = formattedSegment.replace(/\*\*(.*?)\*\*/g, '<strong class="text-xl block my-2 text-green-400">$1</strong>');
                
                return <span key={`segment-${index}`} dangerouslySetInnerHTML={{ __html: formattedSegment }} />;
            } else if (segment.type === 'lore') {
                return (
                    <span
                        key={`lore-${segment.loreName}-${index}`}
                        className="text-cyan-400 hover:text-cyan-300 underline cursor-pointer font-semibold"
                        onClick={(e) => {
                            e.stopPropagation(); 
                            openQuickLoreModal(segment.category, segment.loreName);
                        }}
                    >
                        {segment.text}
                    </span>
                );
            }
            return null; 
        });
    };

    // Logic chính của hàm: Tách toàn bộ text thành các đoạn văn dựa vào 2 lần xuống dòng
    // Sau đó xử lý từng đoạn văn một
    return text.split(/\n\s*\n/).map((paragraph, pIndex) => (
        <p key={`p-${pIndex}`} className="mb-3 leading-relaxed">
            {processParagraph(paragraph)}
        </p>
    ));
  }, [knowledgeBase, openQuickLoreModal]);

  if (!isAuthReady) {
    return (
      <div className="min-h-screen bg-gray-900 text-white flex flex-col items-center justify-center p-4 font-['Arial',_sans-serif]">
        <div className="text-2xl animate-pulse">Đang tải và xác thực...</div>
      </div>
    );
  }
  
    // *** BẮT ĐẦU SỬA ĐỔI: Sửa lỗi truyền props cho GameSetupScreen và GameplayScreen ***
    return (
        <div className="font-['Arial',_sans-serif] text-white">
            <style>{`
/* Thêm đoạn mã CSS tùy chỉnh này */
@keyframes wave-sweep {
    0% {
        background-position: -100% 0;
    }
    100% {
        background-position: 100% 0;
    }
}

.animate-wave-sweep {
    /* Định nghĩa gradient ngay tại đây để kiểm soát hoàn toàn */
    background: linear-gradient(to right, 
        #374151, /* gray-700 */
        #9ca3af, /* gray-400 */
        #374151, /* gray-700 */
        #9ca3af, /* gray-400 */
        #374151  /* gray-700 */
    );
    background-size: 200% auto; /* Kích thước nền lớn hơn để có không gian di chuyển */
    animation: wave-sweep 4s linear infinite;
    -webkit-background-clip: text;
    background-clip: text;
}

/* Định nghĩa các keyframes cho animation */
@keyframes fade-in {
    from { opacity: 0; transform: scale(0.95); }
    to { opacity: 1; transform: scale(1); }
}

@keyframes fade-in-up {
    from {
        opacity: 0;
        transform: translateY(20px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes bounce-in {
    0% { transform: scale(0.1); opacity: 0; }
    60% { transform: scale(1.2); opacity: 1; }
    100% { transform: scale(1); }
}

@keyframes shadow-pulse-red {
    0% { box-shadow: 0 0 10px rgba(255, 0, 0, 0.5), 0 0 20px rgba(255, 0, 0, 0.3); }
    50% { box-shadow: 0 0 20px rgba(255, 0, 0, 0.8), 0 0 40px rgba(255, 0, 0, 0.6); }
    100% { box-shadow: 0 0 10px rgba(255, 0, 0, 0.5), 0 0 20px rgba(255, 0, 0, 0.3); }
}


/* Áp dụng các animation */
.animate-fade-in {
    animation: fade-in 0.3s ease-out forwards;
}

.animate-fade-in-up {
    animation: fade-in-up 0.5s ease-out forwards;
}

.animate-bounce-in {
    animation: bounce-in 0.8s forwards;
}

.shadow-red-glow {
    animation: shadow-pulse-red 2s infinite alternate;
}

/* Scrollbar styling (for max-h and overflow-y-auto elements) */
.scrollbar-thin {
    scrollbar-width: thin;
    scrollbar-color: var(--scrollbar-thumb-color) var(--scrollbar-track-color);
}

.scrollbar-thin::-webkit-scrollbar {
    width: 8px; /* For vertical scrollbars */
    height: 8px; /* For horizontal scrollbars */
}

.scrollbar-thin::-webkit-scrollbar-thumb {
    background-color: var(--scrollbar-thumb-color);
    border-radius: 4px;
}

.scrollbar-thin::-webkit-scrollbar-track {
    background-color: var(--scrollbar-track-color);
    border-radius: 4px;
}

/* Custom Tailwind-like scrollbar classes */
.scrollbar-thumb-purple-500 { --scrollbar-thumb-color: #8B5CF6; } /* Tailwind purple-500 */
.scrollbar-track-gray-700 { --scrollbar-track-color: #374151; } /* Tailwind gray-700 */
.scrollbar-thumb-red-500 { --scrollbar-thumb-color: #EF4444; } /* Tailwind red-500 */
.scrollbar-track-red-700 { --scrollbar-track-color: #B91C1C; } /* Tailwind red-700 */
.scrollbar-thumb-blue-500 { --scrollbar-thumb-color: #3B82F6; } /* Tailwind blue-500 */
.scrollbar-track-blue-700 { --scrollbar-track-color: #1D4ED8; } /* Tailwind blue-700 */
.scrollbar-thumb-teal-500 { --scrollbar-thumb-color: #14B8A6; } /* Tailwind teal-500 */
.scrollbar-track-gray-700 { --scrollbar-track-color: #374151; } /* Tailwind gray-700, repeated for clarity */
.scrollbar-thumb-pink-500 { --scrollbar-thumb-color: #EC4899; } /* Tailwind pink-500 */
.scrollbar-thumb-indigo-500 { --scrollbar-thumb-color: #6366F1; } /* Tailwind indigo-500 */
/* Ensure you have definitions for other scrollbar colors if needed */
        `}</style>

        {/* === BẮT ĐẦU ĐOẠN CODE CẦN THÊM === */}
        <div className="fixed top-5 right-5 z-[200]">
            {notifications.map(n => (
                <Notification key={n.id} notification={n} onRemove={(id) => setNotifications(prev => prev.filter(item => item.id !== id))} />
            ))}
        </div>
{/* === KẾT THÚC ĐOẠN CODE CẦN THÊM === */}
            {currentScreen === 'initial' && (
                <InitialScreen
                    setCurrentScreen={setCurrentScreen}
                    setShowLoadGameModal={setShowLoadGameModal}
                    savedGames={savedGames}
                    apiKeyStatus={apiKeyStatus}
                    userId={userId}
                    setInputApiKey={setInputApiKey}
                    setApiKey={setApiKey}
                    apiKey={apiKey}
                    setShowApiModal={setShowApiModal}
                    apiMode={apiMode}
                    setShowUpdateLogModal={setShowUpdateLogModal} // Pass to InitialScreen
                    fileInputRef={fileInputRef}
                    handleLoadGame={handleLoadGame}
                />
            )}
            {currentScreen === 'setup' && (
                <GameSetupScreen
                    goHome={goHome}
                    gameSettings={gameSettings}
                    handleInputChange={handleInputChange}
                    initializeGame={initializeGame}
                    isLoading={isLoading}
                    handleGenerate={handleGenerate}
                    isGenerating={isGenerating}
                    activeTab={activeTab}
                    setActiveTab={setActiveTab}
                    addInitialWorldElement={addInitialWorldElement}
                    removeInitialWorldElement={removeInitialWorldElement}
                    handleInitialElementChange={handleInitialElementChange}
                    handleGenerateInitialElementDescription={handleGenerateInitialElementDescription}
                    isGeneratingInitialElementDesc={isGeneratingInitialElementDesc}
                    handleGenerateGoal={handleGenerateGoal}
                    isGeneratingGoal={isGeneratingGoal}
                    handleGenerateCharacterName={handleGenerateCharacterName}
                    isGeneratingCharacterName={isGeneratingCharacterName}
                    handleGenerateInitialSkill={handleGenerateInitialSkill}
                    isGeneratingInitialSkill={isGeneratingInitialSkill}
                    addInitialTrait={addInitialTrait}
                    removeInitialTrait={removeInitialTrait}
                    handleInitialTraitChange={handleInitialTraitChange}
                    worldKnowledge={worldKnowledge}
                />
            )}
{currentScreen === 'gameplay' && (
    <GameplayScreen
        goHome={goHome}
        gameSettings={gameSettings}
        restartGame={restartGame}
        storyHistory={storyHistory}
        isLoading={isLoading}
        currentStory={currentStory}
        choices={choices}
        handleChoice={handleChoice}
        formatStoryText={formatStoryText}
        customActionInput={customActionInput}
        setCustomActionInput={setCustomActionInput}
        handleCustomAction={handleCustomAction}
        setShowCharacterInfoModal={setShowCharacterInfoModal}
        isProcessingAction={isProcessingAction}
        handleGenerateSuggestedActions={handleGenerateSuggestedActions}
        isGeneratingSuggestedActions={isGeneratingSuggestedActions}
        isCallingKobold={isCallingKobold}
        handleSaveGame={handleSaveGame}
        setShowCraftingModal={setShowCraftingModal}
        currentTurn={currentTurn}
        setShowCharacterEquipModal={setShowCharacterEquipModal}
        setShowSuggestedActionsModal={setShowSuggestedActionsModal}
        setShowQuickReferenceModal={setShowQuickReferenceModal}
        knowledgeBase={knowledgeBase}
        setShowWorldEditor={setShowWorldEditor}
        theme={theme}
        toggleTheme={toggleTheme}
    />
)}
            {showApiModal && (
                <ApiSetupModal
                    inputApiKey={inputApiKey}
                    setInputApiKey={setInputApiKey}
                    apiKeyStatus={apiKeyStatus}
                    saveApiKey={saveApiKey}
                    testApiKey={testApiKey}
                    isLoading={isLoading}
                    setShowApiModal={setShowApiModal}
                    apiKey={apiKey}
                    setApiKeyStatus={setApiKeyStatus}
                    apiMode={apiMode}
                    setApiMode={setApiMode}
                    setModalMessage={setModalMessage}
                    koboldApiKey={koboldApiKey}
                    setKoboldApiKey={setKoboldApiKey}
                    useKoboldIntegration={useKoboldIntegration}
                    setUseKoboldIntegration={setUseKoboldIntegration}
                    saveKoboldApiKey={saveKoboldApiKey}
                />
            )}
            {showUpdateLogModal && ( // Render UpdateLogModal
                <UpdateLogModal
                    show={showUpdateLogModal}
                    onClose={() => setShowUpdateLogModal(false)}
                    changelog={changelogData}
                />
            )}
            {showLoadGameModal && (
                <LoadGameModal
                    savedGames={savedGames}
                    loadGame={loadGame}
                    setShowLoadGameModal={setShowLoadGameModal}
                    setConfirmationModal={setConfirmationModal}
                    userId={userId}
                    setModalMessage={setModalMessage}
                />
            )}
            {showCharacterInfoModal && (
                <CharacterInfoModal
                    knowledge={knowledgeBase}
                    show={showCharacterInfoModal}
                    onClose={() => setShowCharacterInfoModal(false)}
                    characterPersonality={knowledgeBase.playerStats.characterPersonality}
                    characterName={knowledgeBase.playerStats.characterName}
                    worldKnowledge={worldKnowledge}
                />
            )}
            {showQuickLoreModal && (
                <QuickLoreModal
                    loreItem={quickLoreContent}
                    show={showQuickLoreModal}
                    onClose={() => setShowQuickLoreModal(false)}
                />
            )}
            <SuggestionsModal
                show={showSuggestionsModal.show}
                title={showSuggestionsModal.title || "✨ Gợi Ý"}
                suggestions={showSuggestionsModal.suggestions}
                isLoading={showSuggestionsModal.isLoading}
                onSelect={(suggestion) => {
                    if (showSuggestionsModal.fieldType === 'characterGoal') {
                        setGameSettings(prev => ({ ...prev, characterGoal: suggestion }));
                    } else if (showSuggestionsModal.fieldType) {
                        setGameSettings(prev => ({ ...prev, [showSuggestionsModal.fieldType]: suggestion }));
                    }
                }}
                onClose={() => setShowSuggestionsModal({ show: false, fieldType: null, suggestions: [], isLoading: false, title: '' })}
            />
            <SuggestedActionsModal
                show={showSuggestedActionsModal}
                suggestions={suggestedActionsList}
                isLoading={isGeneratingSuggestedActions}
                onSelect={(action) => {
                    setCustomActionInput(action);
                    setShowSuggestedActionsModal(false);
                }}
                onClose={() => setShowSuggestedActionsModal(false)}
            />
            <CraftingModal
                show={showCraftingModal}
                onClose={() => setShowCraftingModal(false)}
                inventory={knowledgeBase.inventory}
                handleCraftItemDrop={handleCraftItemDrop}
                handleCraftItemReturn={handleCraftItemReturn}
                handleStartCrafting={handleStartCrafting}
                isProcessingAction={isProcessingAction}
                alchemyMaterials={craftedAlchemyMaterials}
                setAlchemyMaterials={setCraftedAlchemyMaterials}
                smithingMaterials={craftedSmithingMaterials}
                setSmithingMaterials={setCraftedSmithingMaterials}
            />
            <CharacterEquipModal
                show={showCharacterEquipModal}
                onClose={() => setShowCharacterEquipModal(false)}
                inventory={knowledgeBase.inventory}
                equippedItems={knowledgeBase.equippedItems}
                playerSkills={knowledgeBase.playerSkills}
                handleEquipItem={handleEquipItem}
                handleUnequipItem={handleUnequipItem}
                equippedGongfa={knowledgeBase.equippedGongfa}

            />
            <QuickReferenceModal
                show={showQuickReferenceModal}
                onClose={() => setShowQuickReferenceModal(false)}
                knowledge={knowledgeBase}
                onSelectForChat={setCustomActionInput}
            />
            <MessageModal
                show={modalMessage.show}
                title={modalMessage.title}
                content={modalMessage.content}
                type={modalMessage.type}
                onClose={() => setModalMessage({ show: false, title: '', content: '', type: 'info' })}
            />
            <ConfirmationModal
                show={confirmationModal.show}
                title={confirmationModal.title}
                content={confirmationModal.content}
                onConfirm={confirmationModal.onConfirm}
                onCancel={confirmationModal.onCancel}
                confirmText={confirmationModal.confirmText}
                cancelText={confirmationModal.cancelText}
                setConfirmationModal={setConfirmationModal}
            />
            <WorldEditorModal
                show={showWorldEditor}
                onClose={() => setShowWorldEditor(false)}
                worldKnowledge={worldKnowledge}
                setWorldKnowledge={setWorldKnowledge}
                onSaveWorldKnowledge={saveWorldKnowledge}
                showNotification={(message, type) => setModalMessage({ show: true, title: type === 'error' ? 'Lỗi' : 'Thông Báo', content: message, type })}
            />
        </div>
    );
};
// *** KẾT THÚC SỬA ĐỔI ***

export default App;
